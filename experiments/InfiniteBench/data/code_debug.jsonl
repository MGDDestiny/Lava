{"id": 0, "context": "Package: pyarmor\n\nFile: pyarmor/cli/core/features.py\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#############################################################\n#                                                           #\n#      Copyright @ 2023 -  Dashingsoft corp.                #\n#      All rights reserved.                                 #\n#                                                           #\n#      Pyarmor                                              #\n#                                                           #\n#      Version: 8.2.4 -                                     #\n#                                                           #\n#############################################################\n#\n#\n#  @File: pyarmor/core/features.py\n#\n#  @Author: Jondy Zhao (pyarmor@163.com)\n#\n#  @Create Date: Tue Jun  6 07:57:55 CST 2023\n#\n\n# Each log\n#    revision, age, (new features), (changed features), (removed features)\n__CHANGE_LOGS__ = (\n    (1, 0, (), (), ()),\n)\n\n\nclass PyarmorFeature(object):\n\n    def features(self):\n        '''return features list from change logs'''\n        result = set()\n        [result.update(item[2]) for item in __CHANGE_LOGS__]\n        return result\n\n    def life(self, feature):\n        '''return first pyarmor_runtime version and last verstion to support\n        this feature.'''\n        minor, fin = None\n        for item in __CHANGE_LOGS__:\n            if feature in item[2] + item[3]:\n                minor = item[0]\n            if feature in item[-1]:\n                fin = item[0]\n        return minor, fin\n\n\nFile: pyarmor/cli/core/__init__.py\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#############################################################\n#                                                           #\n#      Copyright @ 2023 -  Dashingsoft corp.                #\n#      All rights reserved.                                 #\n#                                                           #\n#      Pyarmor                                              #\n#                                                           #\n#      Version: 8.0.1 -                                     #\n#                                                           #\n#############################################################\n#\n#\n#  @File: pyarmor/core/__init__.py\n#\n#  @Author: Jondy Zhao (pyarmor@163.com)\n#\n#  @Create Date: Thu Jan 12 17:29:25 CST 2023\n#\n\n__VERSION__ = '5.4.0'\n\n\ndef format_platform():\n    import platform\n    import sys\n    from struct import calcsize\n\n    def format_system():\n        plat = platform.system().lower()\n        plat = ('windows' if plat.startswith('cygwin') else\n                'linux' if plat.startswith('linux') else\n                'freebsd' if plat.startswith(\n                    ('freebsd', 'openbsd', 'isilon onefs')) else plat)\n        if plat == 'linux':\n            if hasattr(sys, 'getandroidapilevel'):\n                plat = 'android'\n            else:\n                cname, cver = platform.libc_ver()\n                if cname == 'musl':\n                    plat = 'alpine'\n                elif cname == 'libc':\n                    plat = 'android'\n        return plat\n\n    def format_machine():\n        mach = platform.machine().lower()\n        arch_table = (\n            ('x86', ('i386', 'i486', 'i586', 'i686')),\n            ('x86_64', ('x64', 'x86_64', 'amd64', 'intel')),\n            ('arm', ('armv5',)),\n            ('armv6', ('armv6l',)),\n            ('armv7', ('armv7l',)),\n            ('aarch32', ('aarch32',)),\n            ('aarch64', ('aarch64', 'arm64'))\n        )\n        for alias, archlist in arch_table:\n            if mach in archlist:\n                mach = alias\n                break\n        return mach\n\n    plat, mach = format_system(), format_machine()\n    if plat == 'windows' and mach == 'x86_64':\n        bitness = calcsize('P'.encode()) * 8\n        if bitness == 32:\n            mach = 'x86'\n    return plat, mach\n\n\ndef _import_pytransform3():\n    try:\n        return __import__(\n            'pytransform3', globals=globals(), locals=locals(),\n            fromlist=('__pyarmor__',), level=1\n        )\n    except ModuleNotFoundError:\n        plat, arch = format_platform()\n        modname = '.'.join([plat, arch, 'pytransform3'])\n        return __import__(\n            modname, globals=globals(), locals=locals(),\n            fromlist=('__pyarmor__',), level=1\n        )\n\n\nclass Pytransform3(object):\n\n    _pytransform3 = None\n\n    @staticmethod\n    def init(ctx=None):\n        if Pytransform3._pytransform3 is None:\n            Pytransform3._pytransform3 = m = _import_pytransform3()\n            if ctx:\n                m.init_ctx(ctx)\n        return Pytransform3._pytransform3\n\n    @staticmethod\n    def generate_obfuscated_script(ctx, res):\n        m = Pytransform3.init(ctx)\n        return m.generate_obfuscated_script(ctx, res)\n\n    @staticmethod\n    def generate_runtime_package(ctx, output, platforms=None):\n        m = Pytransform3.init(ctx)\n        return m.generate_runtime_package(ctx, output, platforms)\n\n    @staticmethod\n    def generate_runtime_key(ctx, outer=None):\n        m = Pytransform3.init(ctx)\n        return m.generate_runtime_key(ctx, outer)\n\n    @staticmethod\n    def pre_build(ctx):\n        m = Pytransform3.init(ctx)\n        return m.pre_build(ctx)\n\n    @staticmethod\n    def post_build(ctx):\n        m = Pytransform3.init(ctx)\n        return m.post_build(ctx)\n\n    @staticmethod\n    def _update_token(ctx):\n        m = Pytransform3.init(ctx)\n        m.init_ctx(ctx)\n\n    @staticmethod\n    def get_hd_info(hdtype, name=None):\n        m = Pytransform3.init()\n        return m.get_hd_info(hdtype, name) if name \\\n            else m.get_hd_info(hdtype)\n\n    @staticmethod\n    def version():\n        m = Pytransform3.init()\n        return m.revision\n\n\n#\n# Compatiable for pyarmor.cli < 8.3\n#\n\nclass PyarmorRuntime(object):\n\n    @staticmethod\n    def get(plat, extra=None):\n        from os import scandir, path as os_path\n        if not extra:\n            prefix = 'pyarmor_runtime'\n            for entry in scandir(os_path.dirname(__file__)):\n                parts = entry.name.split('.')\n                if parts[0] == prefix and parts[-1] in ('so', 'pyd', 'dylib'):\n                    return entry.name, os_path.abspath(entry.path)\n\n\nFile: pyarmor/cli/core/runtime.py\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#############################################################\n#                                                           #\n#      Copyright @ 2023 -  Dashingsoft corp.                #\n#      All rights reserved.                                 #\n#                                                           #\n#      Pyarmor                                              #\n#                                                           #\n#      Version: 8.2.4 -                                     #\n#                                                           #\n#############################################################\n#\n#\n#  @File: pyarmor/core/runtime.py\n#\n#  @Author: Jondy Zhao (pyarmor@163.com)\n#\n#  @Create Date: Tue Jun  6 07:50:00 CST 2023\n#\n\nPLATFORM_NAMES = (\n    'windows.x86_64', 'windows.x86',\n    'darwin.x86_64', 'darwin.arm64',\n    'linux.x86_64', 'linux.x86', 'linux.aarch64', 'linux.armv7',\n    'alpine.x86_64', 'alpine.aarch64',\n    'freebsd.x86_64',\n    'android.x86_64', 'android.x86', 'android.aarch64', 'android.armv7',\n)\n\n\ndef map_platform(platname):\n    if platname == 'darwin.aarch64':\n        return 'darwin.arm64'\n    return platname\n\n\nclass PyarmorRuntime(object):\n\n    @staticmethod\n    def get(plat, extra=None, native=True):\n        from os import scandir, path as os_path\n        prefix = 'pyarmor_runtime'\n\n        # Themida is only available for windows\n        if extra == 'themida' and not plat.startswith('windows'):\n            extra = None\n\n        pkgpath = os_path.dirname(__file__)\n        if native and not extra:\n            path = pkgpath\n            for entry in scandir(path):\n                parts = entry.name.split('.')\n                if parts[0] == prefix and parts[-1] in ('so', 'pyd', 'dylib'):\n                    return entry.name, os_path.abspath(entry.path)\n\n        dirnames = map_platform(plat).split('.')\n        path = os_path.join(pkgpath, extra if extra else '', *dirnames)\n        if not os_path.exists(path):\n            from pyarmor.cli.bootstrap import check_prebuilt_runtime_library\n            check_prebuilt_runtime_library(dirnames[:1], extra)\n\n        if os_path.exists(path):\n            for entry in scandir(path):\n                parts = entry.name.split('.')\n                if parts[0] == prefix and parts[-1] in ('so', 'pyd', 'dylib'):\n                    return entry.name, os_path.abspath(entry.path)\n\n        # Fallback to pyarmor.cli.runtime\n        try:\n            from pyarmor.cli.runtime import PyarmorRuntime, __VERSION__ as ver\n            from logging import getLogger\n            getLogger('cli').info('fallback to pyarmor.cli.runtime==%s', ver)\n            return PyarmorRuntime.get(plat, extra=extra)\n        except ModuleNotFoundError:\n            pass\n\n\nFile: pyarmor/cli/__init__.py\nimport logging\n\n__VERSION__ = '8.4.2'\n\nlogger = logging.getLogger('cli')\n\n\nclass CliError(Exception):\n    pass\n\n\ndef resoptions(meth):\n\n    def process(self, res, *args, **kwargs):\n        self._options = self.ctx.get_res_options(res.fullname, self._Catalog)\n        return meth(self, res, *args, **kwargs)\n\n    return process\n\n\nclass Component(object):\n\n    def __init__(self, ctx):\n        self.ctx = ctx\n        self._options = {}\n\n        self.logger = logging.getLogger(self.LOGNAME)\n\n    def __getattr__(self, opt):\n        if opt.startswith('o_'):\n            return self._options.get(opt[2:], '')\n        elif opt.startswith('oi_'):\n            return int(self._options.get(opt[3:]))\n        elif opt.startswith('ob_'):\n            v = self._options.get(opt[3:], '')\n            if isinstance(v, str):\n                if v.isdigit():\n                    return bool(int(v))\n                return v.lower() in ('1', 'true', 'on', 'yes')\n\n            return v\n        return AttributeError(opt)\n\n    def trace(self, res, node, value):\n        lineno = getattr(node, 'lineno', -1)\n        self.logger.info('%s:%s:%s', res.fullname, lineno, value)\n\n\nFile: pyarmor/cli/mixer.py\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#############################################################\n#                                                           #\n#      Copyright @ 2023 -  Dashingsoft corp.                #\n#      All rights reserved.                                 #\n#                                                           #\n#      Pyarmor                                              #\n#                                                           #\n#      Version: 8.0.1 -                                     #\n#                                                           #\n#############################################################\n#\n#\n#  @File: cli/mixer.py\n#\n#  @Author: Jondy Zhao (pyarmor@163.com)\n#\n#  @Create Date: 2022-12-06\n#\nimport ast\n\nfrom random import randint\n\n\nclass StrNodeTransformer(ast.NodeTransformer):\n\n    def _reform_str(self, s):\n        encoding = getattr(self, 'encoding')\n        value = bytearray(s.encode(encoding) if encoding else s.encode())\n        key = [randint(0, 255)] * len(value)\n        data = [x ^ y for x, y in zip(value, key)]\n        expr = 'bytearray([%s]).decode(%s)' % (\n            ','.join(['%s ^ %s' % k for k in zip(data, key)]),\n            '' if encoding is None else repr(encoding))\n        return ast.parse(expr).body[0].value\n\n    def _reform_value(self, value):\n        if isinstance(value, str):\n            return self._reform_str(value)\n\n        elif isinstance(value, dict):\n            return ast.Dict(**{\n                'keys': [ast.Constant(value=x) for x in value.keys()],\n                'values': [self._reform_str(x) if isinstance(x, str)\n                           else self._reform_value(x) for x in value.values()]\n            })\n\n        elif isinstance(value, (list, tuple, set)):\n            elts = [self._reform_str(x) if isinstance(x, str)\n                    else self._reform_value(x) for x in value]\n            if isinstance(value, set):\n                return ast.Set(elts=elts)\n            else:\n                cls = ast.List if isinstance(value, list) else ast.Tuple\n                return cls(elts=elts, ctx=ast.Load())\n\n        else:\n            return ast.Constant(value=value)\n\n    def reform_node(self, node):\n        value = node.s if isinstance(node, ast.Str) else node.value\n        if not isinstance(value, (list, tuple, set, dict, str)):\n            return node\n\n        obfnode = self._reform_value(value)\n        ast.copy_location(obfnode, node)\n        ast.fix_missing_locations(obfnode)\n        return obfnode\n\n    def filter_node(self, node):\n        return isinstance(node, (ast.Str, ast.Constant))\n\n    def _is_string_value(self, value):\n        return isinstance(value, ast.Str) or (\n            isinstance(value, ast.Constant) and isinstance(value.value, str))\n\n    def ignore_docstring(self, node):\n        return 1 if (\n            isinstance(node, ast.Module) and len(node.body) > 1 and\n            isinstance(node.body[1], ast.ImportFrom) and\n            node.body[1].module == '__future__' and\n            ast.get_docstring(node) is not None) else 0\n\n    def visit(self, node):\n        for field, value in ast.iter_fields(node):\n            if isinstance(value, list):\n                start = self.ignore_docstring(node) if field == 'body' else 0\n                for i in range(start, len(value)):\n                    if self.filter_node(value[i]):\n                        value[i] = self.reform_node(value[i])\n                    elif isinstance(value[i], ast.AST):\n                        self.visit(value[i])\n            elif self.filter_node(value):\n                setattr(node, field, self.reform_node(value))\n            elif isinstance(value, ast.AST):\n                self.visit(value)\n\n\nclass StrProtector(object):\n\n    def __init__(self, ctx):\n        self.ctx = ctx\n\n    def process(self, res):\n        snt = StrNodeTransformer()\n        snt.encoding = self.ctx.encoding\n        snt.visit(res.mtree)\n\n\nFile: pyarmor/cli/group.py\nimport argparse\nimport logging\nimport os\nimport socketserver\nimport struct\nimport sys\n\nfrom .context import Context\nfrom .generate import Builder, Pytransform3\nfrom .register import Register\n\nPORT = 29092\n\n\nclass DockerAuthHandler(socketserver.BaseRequestHandler):\n\n    WORKPATH = os.path.expanduser(os.path.join('~', '.pyarmor', 'docker'))\n    CTX = None\n\n    def handle(self):\n        data = self.request.recv(64)\n        logging.info('receive request from %s', self.client_address)\n        try:\n            logging.debug('data (%d): %s', len(data), data)\n            self.process(data)\n            logging.info('send auth result to %s', self.client_address)\n        except Exception as e:\n            logging.error('%s', str(e))\n            msg = 'failed to verify docker, please check host console'.encode()\n            msg += b'\\00'\n            self.request.send(struct.pack('!HH', 1, len(msg)) + msg)\n\n    def process(self, packet):\n        if packet[:4] == b'PADH':\n            self.request.send(self.MACHID)\n        else:\n            userdata = self.parse_packet(packet)\n            keydata = self.generate_runtime_key(userdata.decode('utf-8'))\n            self.request.send(struct.pack('!HH', 0, len(keydata)) + keydata)\n\n    def parse_packet(self, packet):\n        if len(packet) == 32 and packet[:4] == b'PADK':\n            return packet[12:]\n        raise RuntimeError('invalid auth request')\n\n    def generate_runtime_key(self, userdata):\n        ctx = self.CTX\n        ctx.cmd_options['user_data'] = userdata\n        return Builder(ctx).generate_runtime_key()\n\n\ndef register_pyarmor(ctx, regfile):\n    reg = Register(ctx)\n    logging.info('register \"%s\"', regfile)\n    reg.register_regfile(regfile)\n    if reg.license_info['features'] < 15:\n        raise RuntimeError('this feature is only for group license')\n\n    machid = reg._get_machine_id()\n    logging.debug('machine id: %s', machid)\n    DockerAuthHandler.MACHID = machid\n\n    Pytransform3._update_token(ctx)\n\n\ndef main_entry():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-p', '--port', type=int, default=PORT)\n    parser.add_argument('-s', '--sock', default='/var/run/docker.sock',\n                        help=argparse.SUPPRESS)\n    parser.add_argument('--home', help=argparse.SUPPRESS)\n    parser.add_argument('regfile', nargs=1,\n                        help='group device registration file for this machine')\n    args = parser.parse_args(sys.argv[1:])\n\n    home = DockerAuthHandler.WORKPATH\n    if args.home:\n        DockerAuthHandler.WORKPATH = args.home\n        home = args.home\n    logging.info('work path: %s', home)\n\n    ctx = Context(home=os.path.expanduser(home))\n    register_pyarmor(ctx, args.regfile[0])\n    DockerAuthHandler.CTX = ctx\n\n    host, port = '0.0.0.0', args.port\n    with socketserver.TCPServer((host, port), DockerAuthHandler) as server:\n        logging.info('listen docker auth request on %s:%s', host, args.port)\n        server.serve_forever()\n\n\ndef main():\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(asctime)s: %(message)s',\n    )\n    main_entry()\n\n\nif __name__ == '__main__':\n    main()\n\n\nFile: pyarmor/cli/shell.py\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#############################################################\n#                                                           #\n#      Copyright @ 2023 -  Dashingsoft corp.                #\n#      All rights reserved.                                 #\n#                                                           #\n#      Pyarmor                                              #\n#                                                           #\n#      Version: 8.0.1 -                                     #\n#                                                           #\n#############################################################\n#\n#\n#  @File: cli/shell.py\n#\n#  @Author: Jondy Zhao (pyarmor@163.com)\n#\n#  @Create Date: Thu Jan 12 10:27:05 CST 2023\n#\nimport configparser\nimport cmd\nimport os\n\n\nclass PyarmorShell(cmd.Cmd):\n\n    intro = 'Welcome to the Pyarmor shell. Type help or ? to list commands.\\n'\n    prompt = '(pyarmor) '\n\n    def __init__(self, ctx):\n        super().__init__()\n        self.ctx = ctx\n        self._reset()\n\n    def _reset(self):\n        ctx = self.ctx\n        cfg = configparser.ConfigParser(\n            empty_lines_in_values=False,\n            interpolation=configparser.ExtendedInterpolation(),\n        )\n        cfg.read([ctx.default_config, ctx.global_config, ctx.local_config])\n        self._cfg = cfg\n\n    def _reset_prompt(self):\n        prompts = ['(pyarmor) ']\n        self.prompt = '\\n'.join(prompts)\n\n    def do_exit(self, arg):\n        'Finish config and exit'\n        print('Thank you for using Pyarmor')\n        return True\n    do_EOF = do_q = do_exit\n\n    def do_use(self, arg):\n        'Select config file'\n\n    def do_ls(self, arg):\n        '''List all the available items in current scope'''\n\n    def do_cd(self, arg):\n        '''Change scope'''\n\n    def do_rm(self, arg):\n        '''Remove item in the scope'''\n\n    def do_set(self, arg):\n        'Change option value'\n\n    def do_show(self, arg):\n        'Show option value'\n\n\ndef parse(arg):\n    'Convert a series of zero or more numbers to an argument tuple'\n    return tuple(map(int, arg.split()))\n\n\nif __name__ == '__main__':\n    PyarmorShell().cmdloop()\n\n\nFile: pyarmor/cli/resource.py\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#############################################################\n#                                                           #\n#      Copyright @ 2023 -  Dashingsoft corp.                #\n#      All rights reserved.                                 #\n#                                                           #\n#      Pyarmor                                              #\n#                                                           #\n#      Version: 8.0.1 -                                     #\n#                                                           #\n#############################################################\n#\n#\n#  @File: cli/resource.py\n#\n#  @Author: Jondy Zhao (pyarmor@163.com)\n#\n#  @Create Date: 2022-12-06\n#\nimport ast\nimport os\n\nfrom datetime import datetime\nfrom fnmatch import fnmatch\nfrom string import Template\n\n\nclass Resource(object):\n\n    def __init__(self, path, name=None, parent=None):\n        self.parent = parent\n        self.path = path\n        self.name = name if name else self._format_name(path)\n\n    def __str__(self):\n        return self.fullname\n\n    def _format_name(self, path):\n        return os.path.splitext(os.path.basename(path))[0]\n\n    def is_top(self):\n        return self.parent is None\n\n    def is_script(self):\n        return isinstance(self, (FileResource, PycResource))\n\n    @property\n    def fullname(self):\n        return self.name if self.is_top() else \\\n            '.'.join([self.parent.fullname, self.name])\n\n    @property\n    def fullpath(self):\n        return self.path if self.is_top() else \\\n            os.path.join(self.parent.fullpath, self.path)\n\n    @property\n    def pkgname(self):\n        # if input path is '.', then pkgname will start with '..'\n        suffix = '.__init__'\n        if self.fullname.endswith(suffix):\n            return self.fullname[:-len(suffix)]\n        return self.fullname\n\n    @property\n    def output_path(self):\n        return '' if self.is_top() else \\\n            os.path.join(self.parent.output_path, self.parent.name)\n\n\nclass FileResource(Resource):\n\n    def __init__(self, path, name=None, parent=None):\n        super().__init__(path, name=name, parent=parent)\n\n        self.mtree = None\n        self.mco = None\n\n        # Do not touch these nodes in final protector\n        self.exclude_nodes = set()\n        # Do not touch these code objects in final patcher\n        self.exclude_co_objects = set()\n\n    def __str__(self):\n        return 'file %s%s' % (self.name, self.pyext)\n\n    def __iter__(self):\n        yield self\n\n    @property\n    def pyext(self):\n        return os.path.splitext(self.path)[-1]\n\n    @property\n    def output_filename(self):\n        return os.path.join(self.output_path, self.name + self.pyext)\n\n    @property\n    def frozenname(self):\n        n = self.fullname.find('.__init__')\n        return '<frozen %s>' % self.fullname[:None if n == -1 else n]\n\n    @property\n    def is_pyc(self):\n        return self.pyext.lower() == '.pyc'\n\n    def _get_encoding(self, encoding):\n        from codecs import BOM_UTF8\n        from re import search as research\n        with open(self.fullpath, 'rb') as f:\n            line = f.read(80)\n            if line and line[:3] == BOM_UTF8:\n                return 'utf-8'\n            if line and line[0] == 35:\n                n = line.find(b'\\n')\n                m = research(r'coding[=:]\\s*([-\\w.]+)', line[:n].decode())\n                if m:\n                    return m.group(1)\n                if n > -1 and len(line) > (n+1) and line[n+1] == 35:\n                    k = n + 1\n                    n = line.find(b'\\n', k)\n                    m = research(r'coding[=:]\\s*([-\\w.]+)', line[k:n].decode())\n                    return m and m.group(1)\n        return encoding\n\n    def readlines(self, encoding=None):\n        if not os.path.exists(self.fullpath):\n            raise RuntimeError('file \"%s\" doesn\\'t exists' % self.fullpath)\n\n        with open(self.fullpath, encoding=self._get_encoding(encoding)) as f:\n            # file.read() can't read the whole data of big files\n            return f.readlines()\n\n    def reparse(self, lines=None, encoding=None):\n        if lines is None:\n            lines = self.readlines(encoding=encoding)\n        self.mtree = ast.parse(''.join(lines), self.frozenname, 'exec')\n\n    def _recompile_pyc(self):\n        from importlib._bootstrap_external import SourcelessFileLoader\n        path, name = self.fullpath, self.pkgname\n        self.mco = SourcelessFileLoader(name, path).get_code(name)\n\n    def recompile(self, mtree=None, optimize=1):\n        if self.is_pyc:\n            return self._recompile_pyc()\n\n        if mtree is None:\n            mtree = self.mtree\n        assert mtree is not None\n        self.mco = compile(mtree, self.frozenname, 'exec', optimize=optimize)\n\n    def clean(self):\n        self.lines = None\n        self.mtree = None\n        self.mco = None\n        if hasattr(self, 'jit_iv'):\n            self.jit_iv = None\n        if hasattr(self, 'jit_data'):\n            self.jit_data = None\n\n    def generate_output(self, tpl, code, relative=0, pkgname='pyarmor_runtime',\n                        bootpath='__file__', rev=''):\n        if relative == 0:\n            prefix = ''\n        elif relative == 1:\n            prefix = '.' * self.fullname.count('.')\n        else:\n            assert(isinstance(relative, str))\n            prefix = relative + '.'\n            if self.fullname.startswith(prefix):\n                prefix = '.' * self.fullname.count('.')\n            elif prefix.startswith(self.pkgname + '.'):\n                prefix = prefix[len(self.pkgname):]\n\n        return Template(tpl).safe_substitute(\n            timestamp=datetime.now().isoformat(),\n            package=prefix + pkgname,\n            path=bootpath,\n            code=repr(code),\n            rev=rev)\n\n\nclass PycResource(FileResource):\n\n    def recompile(self, mtree=None, optimize=1):\n        from importlib._bootstrap_external import SourcelessFileLoader\n        path, name = self.fullpath, self.pkgname\n        self.mco = SourcelessFileLoader(name, path).get_code(name)\n\n\nclass PathResource(Resource):\n\n    def __init__(self, path, name=None, parent=None):\n        super().__init__(path, name=name, parent=parent)\n        self.respaths = []\n        self.resfiles = []\n\n    def __str__(self):\n        return 'path %s' % self.fullname\n\n    def __iter__(self):\n        for res in self.resfiles:\n            if res:\n                yield res\n        for child in self.respaths:\n            for res in child:\n                yield res\n\n    def rebuild(self, **options):\n        pyexts = options.get('pyexts', ['.py'])\n        recursive = options.get('recursive', False)\n        includes = options.get('includes', '').split()\n        excludes = options.get('excludes', '').split()\n        patterns = options.get('data_files', '').split()\n\n        def in_filter(path, name):\n            fullpath = os.path.join(path, name)\n            ext = os.path.splitext(name)[1]\n            return not ex_filter(path, name) and (\n                (ext and ext in pyexts)\n                or any([fnmatch(fullpath, x) for x in includes]))\n\n        def ex_filter(path, name):\n            fullpath = os.path.join(path, name)\n            return excludes and any([fnmatch(fullpath, x) for x in excludes])\n\n        def is_res(path, name):\n            s = os.path.join(path, name)\n            return any([fnmatch(s, x) for x in patterns])\n\n        for path, dirnames, filenames in os.walk(self.fullpath):\n            self.resfiles = [x for x in [\n                FileResource(name, parent=self) if in_filter(path, name)\n                else Resource(name, parent=self) if is_res(path, name)\n                else None for name in filenames\n            ] if x]\n            self.respaths = [PathResource(name, parent=self)\n                             for name in dirnames\n                             if not ex_filter(path, name)]\n            break\n\n        if recursive:\n            for res in self.respaths:\n                res.rebuild(**options)\n\n\nFile: pyarmor/cli/config.py\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#############################################################\n#                                                           #\n#      Copyright @ 2023 -  Dashingsoft corp.                #\n#      All rights reserved.                                 #\n#                                                           #\n#      Pyarmor                                              #\n#                                                           #\n#      Version: 8.0.1 -                                     #\n#                                                           #\n#############################################################\n#\n#\n#  @File: cli/config.py\n#\n#  @Author: Jondy Zhao (pyarmor@163.com)\n#\n#  @Create Date: Thu Jan 12 10:27:05 CST 2023\n#\nimport configparser\nimport fnmatch\nimport os\n\nfrom . import logger, CliError\n\n\ndef indent(lines, n=2):\n    fmt = ' ' * 2 + '%s'\n    return [fmt % x for x in lines]\n\n\ndef str_opt(k, v, n=30):\n    v = '\\n\\t'.join(v.splitlines())\n    return '  %s = %s%s' % (k, v[:n], '...' if len(v) > n else '')\n\n\nclass Configer(object):\n\n    SECTIONS = 'pyarmor', 'logging', 'finder', 'builder', 'runtime', \\\n        'pack', 'bcc', 'mix.str', 'assert.call', 'assert.import'\n\n    def __init__(self, ctx, encoding=None):\n        self.ctx = ctx\n        self._encoding = encoding\n\n    def _read_config(self, filename):\n        cfg = configparser.ConfigParser(empty_lines_in_values=False)\n        cfg.read(filename, encoding=self._encoding)\n        return cfg\n\n    def list_sections(self, local=True, name=None):\n        lines = ['All available sections:']\n        cfg = self.ctx.cfg\n        lines.extend(indent(self.SECTIONS))\n\n        lines.extend(['', 'Global sections'])\n        cfg = self._read_config(self.ctx.global_config)\n        lines.extend(indent(cfg.sections()))\n\n        if local:\n            lines.extend(['', 'Local sections'])\n            cfg = self._read_config(self.ctx.local_config)\n            lines.extend(indent(cfg.sections()))\n\n        if name:\n            lines.extend(['', 'Private \"%s\" sections' % name])\n            cfg = self._read_config(self.ctx.get_filename(local, name))\n            lines.extend(indent(cfg.sections()))\n\n        return lines\n\n    def list_options(self, sect, local=True, name=None):\n        lines = ['Current options']\n\n        cfg = self.ctx.cfg\n        if cfg.has_section(sect):\n            lines.extend([str_opt(*x) for x in cfg.items(sect)])\n\n        lines.extend(['', 'Global options'])\n        cfg = self._read_config(self.ctx.global_config)\n        if cfg.has_section(sect):\n            lines.extend([str_opt(*x) for x in cfg.items(sect)])\n\n        if local:\n            lines.extend(['', 'Local options'])\n            cfg = self._read_config(self.ctx.local_config)\n            if cfg.has_section(sect):\n                lines.extend([str_opt(*x) for x in cfg.items(sect)])\n\n        if name:\n            lines.extend(['', 'Private \"%s\" options' % name])\n\n            cfg = self._read_config(self.ctx.get_filename(local, name))\n            if cfg.has_section(sect):\n                lines.extend([str_opt(*x) for x in cfg.items(sect)])\n\n        return lines\n\n    def _list_value(self, sect, opt, local=True, name=None):\n        clines, glines, lines, plines = self.infos\n\n        def format_value(opt):\n            v = cfg[sect].get(opt)\n            n = 1 << 30\n            return 'no option \"%s\"' % opt if v is None else str_opt(opt, v, n)\n\n        cfg = self.ctx.cfg\n        if cfg.has_section(sect):\n            clines.append(format_value(opt))\n\n        cfg = self._read_config(self.ctx.global_config)\n        if cfg.has_section(sect) and cfg.has_option(sect, opt):\n            glines.append(format_value(opt))\n\n        if local:\n            cfg = self._read_config(self.ctx.local_config)\n            if cfg.has_section(sect) and cfg.has_option(sect, opt):\n                lines.append(format_value(opt))\n\n        if name:\n            cfg = self._read_config(self.ctx.get_filename(local, name))\n            if cfg.has_section(sect) and cfg.has_option(sect, opt):\n                plines.append(format_value(opt))\n\n        return clines, glines, lines, plines\n\n    def _set_option(self, sect, opt, value, local=True, name=None):\n        ctx = self.ctx\n        filename = ctx.get_filename(local=local, name=name)\n\n        cfg = self._read_config(filename)\n        if not cfg.has_section(sect):\n            cfg.add_section(sect)\n\n        # TBD: input multiple lines\n        optname, optvalue = opt, value\n        if optvalue and optvalue[:1] in ('+', '-', '=', '^'):\n            op = optvalue[:1]\n            optvalue = optvalue.strip(op)\n            if op == '=':\n                op = None\n        else:\n            op = None\n        if optvalue and optvalue[:1] in (\"'\", '\"'):\n            optvalue = optvalue.strip(optvalue[0])\n\n        if not optvalue:\n            if op is None:\n                self._clear(sect, optname, local, name)\n            return\n\n        ctxcfg = ctx.cfg\n        old = ctxcfg[sect].get(optname, '') if ctxcfg.has_section(sect) else ''\n\n        if op == '+':\n            if (optvalue + ' ').find(old + ' ') == -1:\n                optvalue = ('%s %s' % (old, optvalue)).strip()\n        elif op == '-':\n            optvalue = (old + ' ').replace(optvalue + ' ', '').strip()\n        elif op == '^':\n            optvalue = '\\n'.join((old.splitlines() + [optvalue]))\n\n        logger.info('change option \"%s\" to new value \"%s\"', optname, optvalue)\n        cfg.set(sect, optname, optvalue)\n\n        os.makedirs(os.path.dirname(filename), exist_ok=True)\n        with open(filename, 'w') as f:\n            cfg.write(f)\n\n        self._list_value(sect, optname, local=local, name=name)\n\n    def _remove(self, section=None, options=None, local=True, name=None):\n        ctx = self.ctx\n        filename = ctx.get_filename(local=local, name=name)\n\n        if section is None:\n            logger.info('remove config file \"%s\"', filename)\n            if os.path.exists(filename):\n                os.remove(filename)\n            return\n\n        cfg = self._read_config(filename)\n\n        if cfg.has_section(section):\n            if not options:\n                logger.info('remove section \"%s\"', section)\n                cfg.remove_section(section)\n            else:\n                for opt in [x for x in options if cfg.has_option(section, x)]:\n                    logger.info('remove option \"%s:%s\"', section, opt)\n                    cfg.remove_option(section, opt)\n\n                    if not cfg.options(section):\n                        logger.info('remove empty section \"%s\"', section)\n                        cfg.remove_section(section)\n\n            with open(filename, 'w') as f:\n                cfg.write(f)\n\n    def _clear(self, section=None, options=None, local=True, name=None):\n        ctx = self.ctx\n        scope = '%s%s config file' % (\n            'local' if local else 'global',\n            ' \"%s\"' % name if name else ''\n        )\n        filename = ctx.get_filename(local=local, name=name)\n\n        if not filename:\n            logger.info('no %s', scope)\n            return\n\n        logger.info('remove %s \"%s\"', scope, filename)\n        if os.path.exists(filename):\n            os.remove(filename)\n\n    def _parse_opt(self, opt):\n        i = opt.find(':')\n        if i == -1:\n            j = opt.find('=')\n            pat, v = (opt, '') if j == -1 else (opt[:j], opt[j:])\n            cfg = self.ctx.cfg\n            rlist = []\n            for sect in self.SECTIONS:\n                if cfg.has_section(sect):\n                    rlist.append((sect, [x+v for x in cfg.options(sect)\n                                         if fnmatch.fnmatch(x, pat)]))\n            return [x for x in rlist if x[1]]\n        else:\n            return [(opt[:i], [opt[i+1:]])]\n\n    def reset(self, options=None, local=True, name=None):\n        for pat in options:\n            for sect, opts in self._parse_opt(pat):\n                self._remove(sect, opts, local, name)\n\n    def run(self, options=None, local=True, name=None):\n        lines = []\n\n        if options and len(options) == 1 and options[0].find('=') == -1:\n            for sect, opts in self._parse_opt(options[0]):\n                title = 'Section: %s' % sect\n                lines.extend(['', '-' * 60, title])\n                self.infos = [], [], [], []\n\n                for opt in opts:\n                    self._list_value(sect, opt, local, name)\n\n                lines.extend(['', 'Current settings'])\n                lines.extend(self.infos[0])\n                lines.extend(['', 'Global settings'])\n                lines.extend(self.infos[1])\n                lines.extend(['', 'Local settings'])\n                lines.extend(self.infos[2])\n                if name:\n                    lines.extend(['', 'Private \"%s\" settings' % name])\n                    lines.extend(self.infos[3])\n\n        elif options:\n            pairs = []\n            prev, op = None, ''\n            for opt in options:\n                i = opt.find('=')\n                if i > 0:\n                    pairs.append([opt[:i], opt[i+1:]])\n                elif opt in ('+', '=', '-', '^'):\n                    op = opt\n                elif prev:\n                    pairs.append((prev, op + opt))\n                    prev, op = None, ''\n                else:\n                    prev = opt\n            if prev:\n                raise CliError('no value for option \"%s\"' % prev)\n\n            for pat, value in pairs:\n                sect_opts = self._parse_opt(pat)\n                if not sect_opts:\n                    logger.debug('new builder option \"%s\"', pat)\n                    sect_opts = [('builder', [pat])]\n                for sect, opts in sect_opts:\n                    title = 'Section: %s' % sect\n                    lines.extend(['', '-' * 60, title])\n                    self.infos = [], [], [], []\n\n                    for opt in opts:\n                        self._set_option(sect, opt, value, local, name)\n\n                    lines.extend(['', 'Current settings'])\n                    lines.extend(self.infos[0])\n                    lines.extend(['', 'Global settings'])\n                    lines.extend(self.infos[1])\n                    lines.extend(['', 'Local settings'])\n                    lines.extend(self.infos[2])\n                    if name:\n                        lines.extend(['', 'Private \"%s\" settings' % name])\n                        lines.extend(self.infos[3])\n\n        else:\n            for sect in self.SECTIONS:\n                title = 'Section: %s' % sect\n                lines.extend(['', '-' * 60, title, ''])\n                lines.extend(self.list_options(sect, local, name))\n\n        print('\\n'.join(lines))\n\n\nFile: pyarmor/cli/merge.py\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#############################################################\n#                                                           #\n#      Copyright @ 2023 -  Dashingsoft corp.                #\n#      All rights reserved.                                 #\n#                                                           #\n#      Pyarmor                                              #\n#                                                           #\n#      Version: 8.2.3 -                                     #\n#                                                           #\n#############################################################\n#\n#\n#  @File: cli/merge.py\n#\n#  @Author: Jondy Zhao (pyarmor@163.com)\n#\n#  @Create Date: Tue May 30 19:35:02 CST 2023\n#\nimport argparse\nimport logging\nimport os\nimport shutil\nimport struct\nimport sys\n\nlogger = logging.getLogger('merge')\n\n\ndef is_pyscript(filename):\n    return os.path.splitext(filename)[-1].lower() in ('.py', '.pyw')\n\n\ndef parse_script(filename):\n    with open(filename) as f:\n        for line in f:\n            if line.startswith('__pyarmor__('):\n                i = line.find('(')\n                args = line.strip()[i+1:-1].split(', ', 2)\n                co = compile(line, '<str>', 'exec')\n                return args, co.co_consts[0]\n\n\ndef parse_header(code):\n    left_size = len(code)\n    offset = 0\n    infos = []\n    valid = False\n\n    while left_size > 0:\n        pymajor, pyminor = struct.unpack(\"BB\", code[offset+9:offset+11])\n        size, = struct.unpack(\"i\", code[offset+56:offset+60])\n        if not size:\n            valid = True\n            size = left_size\n        left_size -= size\n        infos.append([offset, size, (pymajor, pyminor)])\n        offset += size\n\n    if not valid:\n        raise RuntimeError('invalid header in this script')\n\n    return infos\n\n\ndef merge_scripts(name, paths, dest):\n    scripts = [os.path.join(p, name) for p in paths]\n\n    refscript = scripts.pop(0)\n    result = parse_script(refscript)\n\n    if result is None:\n        logger.info('copy script, it is not obfuscated')\n        shutil.copy2(refscript, dest)\n        return\n\n    refmark = '--xxxxxx--'\n    refitem, refcode = result\n    with open(refscript) as f:\n        refdata = f.read().replace(refitem[-1], refmark)\n\n    pieces = []\n\n    for script in reversed(scripts):\n        result = parse_script(script)\n        if not result:\n            raise RuntimeError('\"%s\" is not an obfuscated script' % script)\n        item, code = result\n        infos = parse_header(code)\n        off, size, pyver = infos[-1]\n        logger.debug('merge py%s.%s at %d (%d)', *pyver, off, size)\n        pieces.extend([code[:off+56], struct.pack(\"i\", size), code[off+60:]])\n\n    for off, size, pyver in parse_header(refcode):\n        logger.debug('merge py%s.%s at %d (%d)', *pyver, off, size)\n        pieces.append(refcode[off:off+size])\n\n    logger.info('write \"%s\"', dest)\n    with open(dest, 'w') as f:\n        f.write(refdata.replace(refmark, repr(b''.join(pieces))))\n\n\ndef merge_paths(paths, rname, output):\n    refpath = os.path.normpath(paths[-1])\n    rpath = os.path.join(refpath, rname) if rname else None\n\n    n = len(refpath) + 1\n    for root, dirs, files in os.walk(refpath):\n        for x in files:\n            if rpath and root.startswith(rpath):\n                continue\n\n            name = root[n:]\n            destpath = os.path.join(output, name)\n            if not os.path.exists(destpath):\n                os.makedirs(destpath)\n\n            dest = os.path.join(destpath, x)\n            logger.info('handle \"%s\"', dest)\n            if is_pyscript(x):\n                merge_scripts(os.path.join(name, x), paths, dest)\n            else:\n                shutil.copy2(os.path.join(root, x), dest)\n\n\ndef merge_runtimes(paths, rname, output):\n    dest = os.path.join(output, rname)\n    if os.path.exists(dest):\n        shutil.rmtree(dest)\n    os.makedirs(dest)\n\n    shutil.copy2(os.path.join(paths[0], rname, '__init__.py'), dest)\n\n    for p in paths:\n        logger.info('handle runtime package at \"%s\"', p)\n        rpath = os.path.join(p, rname)\n        if not os.path.exists(rpath):\n            raise RuntimeError('no runtime package found')\n        for x in os.scandir(rpath):\n            if x.is_dir():\n                logger.info('copy runtime files \"%s\" to \"%s\"', x.name, dest)\n                shutil.copytree(x.path, os.path.join(dest, x.name))\n\n\ndef scan_runtime(paths, marker=None):\n    if marker is None:\n        marker = 'from sys import version_info as py_version'\n    refpath = os.path.normpath(paths[-1])\n    logger.info('scan runtime package in the path \"%s\"', refpath)\n\n    n = len(refpath) + 1\n\n    for root, dirs, files in os.walk(refpath):\n        for x in files:\n            if x == '__init__.py':\n                filename = os.path.join(root, x)\n                with open(filename) as f:\n                    for line in f:\n                        if line.startswith('#'):\n                            continue\n                        if line.startswith(marker):\n                            return filename[n:-12]\n                        break\n\n    raise RuntimeError('no runtime package found')\n\n\ndef excepthook(type, exc, traceback):\n    try:\n        msg = exc.args[0] % exc.args[1:]\n    except Exception:\n        msg = str(exc)\n    logging.error(msg)\n    sys.exit(1)\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        prog='pyarmor-merge',\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog='merge Pyarmor 8 obfuscated scripts')\n\n    parser.add_argument('-O', '--output',\n                        default='dist',\n                        help='Default output path: %(default)s)')\n    parser.add_argument('-d', '--debug',\n                        default=False,\n                        action='store_true',\n                        dest='debug',\n                        help='print debug log (default: %(default)s)')\n    group = parser.add_argument_group().add_mutually_exclusive_group()\n    group.add_argument('-n', '--no-runtime', action='store_true',\n                       help='Ignore runtime files')\n    group.add_argument('--runtime-name', help='Runtime package name')\n    parser.add_argument('path', nargs='+',\n                        help=\"Paths or obfuscated scripts\")\n\n    args = parser.parse_args(sys.argv[1:])\n    if args.debug:\n        logger.setLevel(logging.DEBUG)\n    else:\n        sys.excepthook = excepthook\n\n    logger.info('start to merge %s...', str(args.path)[1:-1])\n    output = args.output\n\n    runtime_name = args.runtime_name\n\n    if not args.no_runtime:\n        if not runtime_name:\n            runtime_name = scan_runtime(args.path)\n        logger.info('runtime package at \"%s\"', runtime_name)\n\n        logging.info('merging runtime files...')\n        merge_runtimes(args.path, runtime_name, output)\n        logging.info('merging runtime files OK')\n\n    logging.info('merging obfuscated scripts...')\n    merge_paths(args.path, runtime_name, output)\n    logging.info('merging obfuscated scripts OK')\n\n    logger.info('merge all the scripts to \"%s\" successfully', output)\n\n\nif __name__ == '__main__':\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(levelname)-8s %(message)s',\n    )\n    main()\n\n\nFile: pyarmor/cli/__main__.py\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#############################################################\n#                                                           #\n#      Copyright @ 2023 -  Dashingsoft corp.                #\n#      All rights reserved.                                 #\n#                                                           #\n#      Pyarmor                                              #\n#                                                           #\n#      Version: 8.0.1 -                                     #\n#                                                           #\n#############################################################\n#\n#\n#  @File: cli/main.py\n#\n#  @Author: Jondy Zhao (pyarmor@163.com)\n#\n#  @Create Date: Thu Jan 12 10:27:05 CST 2023\n#\nimport argparse\nimport logging\nimport os\nimport sys\n\nfrom . import logger, CliError\nfrom .context import Context\nfrom .register import Register, WebRegister\nfrom .config import Configer\nfrom .shell import PyarmorShell\nfrom .plugin import Plugin\nfrom .generate import Builder\nfrom .bootstrap import check_prebuilt_runtime_library\n\n\ndef _cmd_gen_key(builder, options):\n    n = len(options['inputs'])\n    if n > 1:\n        logger.error('please check online documentation to learn')\n        logger.error('how to use command \"pyarmor gen key\"')\n        raise CliError('invalid arguments: %s' % options['inputs'][1:])\n    keyname = builder.ctx.outer_keyname\n\n    logger.info('start to generate outer runtime key \"%s\"', keyname)\n    data = builder.generate_runtime_key(outer=True)\n    output = options.get('output', 'dist')\n    if output == 'pipe':\n        logger.info('return runtime key by pipe')\n        return data\n    os.makedirs(output, exist_ok=True)\n\n    target = os.path.join(output, keyname)\n    logger.info('write %s', target)\n    with open(target, 'wb') as f:\n        f.write(data)\n\n    Plugin.post_key(builder.ctx, target)\n    logger.info('generate outer runtime key OK')\n\n\ndef _cmd_gen_runtime(builder, options):\n    if len(options['inputs']) > 1:\n        logger.error('please check online documentation to learn')\n        logger.error('how to use command \"pyarmor gen runtime\"')\n        raise CliError('invalid arguments: %s' % options['inputs'][1:])\n\n    output = options.get('output', 'dist')\n\n    logger.info('start to generate runtime package')\n    builder.generate_runtime_package(output)\n\n    keyname = os.path.join(output, builder.ctx.runtime_keyfile)\n    logger.info('write \"%s\"', keyname)\n    with open(keyname, 'wb') as f:\n        f.write(builder.ctx.runtime_key)\n    logger.info('generate runtime package to \"%s\" OK', output)\n\n\ndef format_gen_args(ctx, args):\n    options = {}\n    for x in ('recursive', 'findall', 'output', 'no_runtime',\n              'enable_bcc', 'enable_jit', 'enable_rft', 'enable_themida',\n              'obf_module', 'obf_code', 'assert_import', 'assert_call',\n              'mix_str', 'import_prefix', 'restrict_module',\n              'platforms', 'outer', 'period', 'expired', 'devices'):\n        v = getattr(args, x)\n        if v is not None:\n            options[x] = v\n\n    if options.get('platforms'):\n        platforms = []\n        for item in options['platforms']:\n            platforms.extend([x.strip() for x in item.split(',')])\n        options['platforms'] = platforms\n    elif ctx.runtime_platforms:\n        options['platforms'] = ctx.runtime_platforms.split()\n        logger.info('get runtime platforms from configuration file')\n    if options.get('platforms'):\n        logger.info('use runtime platforms: %s', options['platforms'])\n\n    if args.inputs:\n        options['inputs'] = [os.path.normpath(x) for x in args.inputs]\n\n    if args.use_runtime:\n        options['no_runtime'] = True\n        options['use_runtime'] = args.use_runtime\n\n    if options.get('assert_call') or options.get('assert_import'):\n        if options.get('restrict_module', 0) < 2:\n            logger.debug('implicitly set restrict_module = 2')\n            options['restrict_module'] = 2\n\n    if args.enables:\n        for x in args.enables:\n            options['enable_' + x] = True\n\n    if args.prefix:\n        options['import_prefix'] = args.prefix\n\n    if args.no_wrap:\n        options['wrap_mode'] = 0\n\n    if args.includes:\n        options['includes'] = ' '.join(args.includes)\n    if args.excludes:\n        options['excludes'] = ' '.join(args.excludes)\n\n    if args.bind_data:\n        options['user_data'] = args.bind_data\n\n    if args.pack:\n        dist_path = os.path.join(ctx.repack_path, 'dist')\n        logger.info('implicitly set output to \"%s\"', dist_path)\n        options['output'] = dist_path\n\n    return options\n\n\n# Unused\ndef check_cross_platform(ctx, platforms):\n    rtver = ctx.cfg.get('pyarmor', 'cli.runtime')\n    cmd = 'pip install pyarmor.cli.runtime~=%s.0' % rtver\n    try:\n        from pyarmor.cli import runtime\n    except (ImportError, ModuleNotFoundError):\n        logger.error('cross platform need package \"pyarmor.cli.runtime\"')\n        logger.error('please run \"%s\" to fix it', cmd)\n        raise CliError('no package \"pyarmor.cli.runtime\" found')\n\n    if runtime.__VERSION__ != rtver:\n        logger.error('please run \"%s\" to fix it', cmd)\n        raise CliError('unexpected \"pyarmor.cli.runtime\" version')\n\n    platnames = []\n    for path in runtime.__path__:\n        logger.debug('search runtime platforms at: %s', path)\n        platnames.extend(os.listdir(os.path.join(path, 'libs')))\n\n    map_platform = runtime.map_platform\n    unknown = set([map_platform(x) for x in platforms]) - set(platnames)\n\n    if unknown:\n        logger.error('please check documentation \"References/Environments\"')\n        raise CliError('unsupported platforms \"%s\"' % ', '.join(unknown))\n\n\ndef check_gen_context(ctx, args):\n    platforms = ctx.runtime_platforms\n    if platforms and set(platforms) != set([ctx.pyarmor_platform]):\n        if ctx.enable_bcc:\n            raise CliError('bcc mode does not support cross platform')\n        rtver = ctx.cfg['pyarmor'].get('cli.runtime', '')\n        check_prebuilt_runtime_library(platforms, ctx.enable_themida, rtver)\n\n    elif ctx.enable_themida:\n        if not ctx.pyarmor_platform.startswith('windows'):\n            raise CliError('--enable-themida only works for Windows')\n        rtver = ctx.cfg['pyarmor'].get('cli.runtime', '')\n        check_prebuilt_runtime_library([], ['themida'], rtver)\n\n    if ctx.enable_bcc:\n        plat, arch = ctx.pyarmor_platform.split('.')\n        if arch not in ('x86_64', 'aarch64', 'x86', 'armv7'):\n            raise CliError('bcc mode still not support arch \"%s\"' % arch)\n\n    if ctx.cmd_options.get('no_runtime') and not ctx.runtime_outer:\n        raise CliError('--outer is required if using --no_runtime')\n\n    if ctx.use_runtime and not ctx.runtime_outer:\n        if os.path.exists(ctx.use_runtime):\n            keyname = os.path.join(ctx.use_runtime, ctx.runtime_keyfile)\n            if not os.path.exists(keyname):\n                raise CliError('no runtime key in \"%s\"', ctx.use_runtime)\n\n    if ctx.runtime_outer and any(\n            [ctx.runtime_devices, ctx.runtime_period, ctx.runtime_expired]):\n        raise CliError('--outer conflicts with any -e, --period, -b')\n\n    if args.pack:\n        if not os.path.isfile(args.pack):\n            raise CliError('--pack must be an executable file')\n        if args.no_runtime:\n            raise CliError('--pack conficts with --no-runtime, --use-runtime')\n        if ctx.import_prefix:\n            raise CliError('--pack conficts with -i, --prefix')\n\n\ndef cmd_gen(ctx, args):\n    options = format_gen_args(ctx, args)\n    logger.debug('command options: %s', options)\n    ctx.push(options)\n    check_gen_context(ctx, args)\n\n    builder = Builder(ctx)\n\n    Plugin.install(ctx)\n    if args.inputs[0].lower() in ('key', 'k'):\n        return _cmd_gen_key(builder, options)\n    elif args.inputs[0].lower() in ('runtime', 'run', 'r'):\n        _cmd_gen_runtime(builder, options)\n    elif args.pack:\n        from .repack import Repacker\n        codesign = ctx.cfg['pack'].get('codesign_identify', None)\n        packer = Repacker(args.pack, ctx.repack_path, codesign=codesign)\n        packer.check()\n        builder.process(options, packer=packer)\n        Plugin.post_build(ctx, pack=args.pack)\n    else:\n        builder.process(options)\n        Plugin.post_build(ctx)\n\n\ndef cmd_cfg(ctx, args):\n    scope = 'global' if args.scope else 'local'\n    cfg = Configer(ctx, encoding=args.encoding)\n    name = 'reset' if args.reset else 'run'\n    getattr(cfg, name)(args.options, scope == 'local', args.name)\n\n\ndef cmd_reg(ctx, args):\n    if args.buy:\n        from webbrowser import open_new_tab\n        open_new_tab(ctx.cfg['pyarmor']['buyurl'])\n        return\n\n    if args.device and not args.regfile:\n        reg = Register(ctx)\n        reg.generate_group_device(args.device)\n        logger.info('device file has been generated successfully')\n        return\n\n    regfile = args.regfile\n    if not regfile:\n        reg = Register(ctx)\n        logger.info('Current license information:\\n\\n%s', reg)\n        return\n\n    if regfile.endswith('.txt') and not args.product:\n        logger.error('please use -p to specify product name for this license')\n        raise CliError('missing product name')\n\n    if regfile.endswith('.zip') and args.product:\n        logger.error('please do not use -p for non initial registration')\n        raise CliError('unwanted product name')\n\n    upgrade = args.upgrade\n    if upgrade:\n        if not regfile.endswith('.txt'):\n            raise CliError('upgrade need text file \"pyarmor-keycode-xxxx.txt\"')\n        url = 'https://github.com/dashingsoft/pyarmor/issues/980'\n        msg = (\"\",\n               \"Pyarmor 8 changes EULA and uses new commands\",\n               \"It's different from previous Pyarmor totally\",\n               \"Please read this import notes first:\",\n               url,\n               \"Do not upgrade to Pyarmor 8 if don't know what are changed\",\n               \"\", \"\")\n        prompt = 'I have known the changes of Pyarmor 8? (yes/no/help) '\n        choice = input('\\n'.join(msg) + prompt).lower()[:1]\n        if choice == 'h':\n            import webbrowser\n            webbrowser.open(url)\n        if not choice == 'y':\n            logger.info('abort upgrade')\n            return\n\n    if args.device:\n        if not regfile.endswith('.zip'):\n            logger.error('invalid registeration file \"%s\"', regfile)\n            raise CliError('please use \".zip\" file to register group device')\n        regsvr = WebRegister(ctx)\n        regsvr.register_group_device(regfile, args.device)\n        logger.info('The device regfile has been generated successfully')\n\n    elif regfile.endswith('.zip'):\n        reg = Register(ctx)\n        logger.info('register \"%s\"', regfile)\n        reg.register_regfile(regfile)\n        logger.info('This license registration information:\\n\\n%s', str(reg))\n\n    else:\n        regsvr = WebRegister(ctx)\n        info, msg = regsvr.prepare(regfile, args.product, upgrade=upgrade)\n        prompt = 'Are you sure to continue? (yes/no) '\n        if args.confirm:\n            from time import sleep\n            sleep(1.0)\n        elif input(msg + prompt) not in ('y', 'yes'):\n            logger.info('abort registration')\n            return\n        # Free upgrade to Pyarmor Basic\n        if upgrade and not info['upgrade']:\n            return regsvr.register(regfile, args.product, upgrade=True)\n\n        if upgrade:\n            regsvr.upgrade_to_pro(regfile, args.product)\n        else:\n            group = info['lictype'] == 'GROUP'\n            regsvr.register(regfile, args.product, group=group)\n\n\ndef main_parser():\n    parser = argparse.ArgumentParser(\n        prog='pyarmor',\n        fromfile_prefix_chars='@',\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n    parser.add_argument(\n        '-v', '--version', action='store_true',\n        help='show version information and exit'\n    )\n    parser.add_argument(\n        '-q', '--silent', action='store_true',\n        help='suppress all normal output'\n    )\n    parser.add_argument(\n        '-d', '--debug', action='store_true',\n        help='print debug informations in the console'\n    )\n    parser.add_argument(\n        '-i', dest='interactive', action='store_true',\n        help=argparse.SUPPRESS,\n    )\n    parser.add_argument('--home', help=argparse.SUPPRESS)\n\n    subparsers = parser.add_subparsers(\n        title='The most commonly used pyarmor commands are',\n        metavar=''\n    )\n\n    gen_parser(subparsers)\n    reg_parser(subparsers)\n    cfg_parser(subparsers)\n\n    return parser\n\n\ndef gen_parser(subparsers):\n    '''generate obfuscated scripts and all required runtime files\n    pyarmor gen <options> <scripts>\n\ngenerate runtime key only\n    pyarmor gen key <options>\n\ngenerate runtime package only\n    pyarmor gen runtime <options>\n\nRefer to\nhttps://pyarmor.readthedocs.io/en/stable/reference/man.html#pyarmor-gen\n'''\n    cparser = subparsers.add_parser(\n        'gen',\n        aliases=['generate', 'g'],\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=gen_parser.__doc__,\n        help='generate obfuscated scripts and required runtime files'\n    )\n\n    cparser.add_argument('-O', '--output', metavar='PATH', help='output path')\n\n    group = cparser.add_argument_group(\n        'action arguments'\n    ).add_mutually_exclusive_group()\n    group.add_argument(\n        '--pack', metavar='BUNDLE',\n        help='repack bundle with obfuscated scripts'\n    )\n    group.add_argument(\n        '--no-runtime', action='store_true',\n        help='do not generate runtime package'\n    )\n    group.add_argument(\n        '--use-runtime', metavar='PATH',\n        help='use shared runtime package'\n    )\n\n    group = cparser.add_argument_group('obfuscation arguments')\n    group.add_argument(\n        '-r', '--recursive', action='store_true', default=None,\n        help='search scripts in recursive mode'\n    )\n    group.add_argument(\n        '-a', '--all', dest='findall', action='store_true', default=None,\n        help=argparse.SUPPRESS\n    )\n    group.add_argument(\n        '--include', dest='includes', metavar='PATTERN', action='append',\n        help=argparse.SUPPRESS\n    )\n    group.add_argument(\n        '--exclude', dest='excludes', metavar='PATTERN', action='append',\n        help='Exclude scripts and paths'\n    )\n\n    group.add_argument(\n        '--obf-module', type=int, default=None, choices=(0, 1),\n        help='obfuscate whole module (default is 1)'\n    )\n    group.add_argument(\n        '--obf-code', type=int, default=None, choices=(0, 1, 2),\n        help='obfuscate each function (default is 1)'\n    )\n    group.add_argument(\n        '--no-wrap', action='store_true', default=None,\n        help='disable wrap mode',\n    )\n\n    group.add_argument(\n        '--mix-str', action='store_true', default=None,\n        help='protect string constant',\n    )\n    group.add_argument(\n        '--enable-bcc', action='store_true', default=None,\n        help=argparse.SUPPRESS\n    )\n    group.add_argument(\n        '--enable-rft', action='store_true', default=None,\n        help=argparse.SUPPRESS\n    )\n    group.add_argument(\n        '--enable-jit', action='store_true', default=None,\n        help=argparse.SUPPRESS\n    )\n    group.add_argument(\n        '--enable-themida', action='store_true', default=None,\n        help=argparse.SUPPRESS\n    )\n    group.add_argument(\n        '--assert-call', action='store_true', default=None,\n        help='assert function is obfuscated'\n    )\n    group.add_argument(\n        '--assert-import', action='store_true', default=None,\n        help='assert module is obfuscated'\n    )\n    group.add_argument(\n        '--enable', action='append', dest='enables',\n        choices=('jit', 'bcc', 'rft', 'themida'),\n        help='enable different obfuscation features',\n    )\n\n    restrict = group.add_mutually_exclusive_group()\n    restrict.add_argument(\n        '--private', action=\"store_const\", default=None, const=2,\n        dest='restrict_module', help='enable private mode for script'\n    )\n    restrict.add_argument(\n        '--restrict', action=\"store_const\", default=None, const=3,\n        dest='restrict_module', help='enable restrict mode for package'\n    )\n\n    group = cparser.add_argument_group('runtime package arguments')\n    group.add_argument(\n        '-i', dest='import_prefix', action='store_const',\n        default=None, const=1,\n        help='store runtime files inside package'\n    )\n    group.add_argument(\n        '--prefix', metavar='PREFIX',\n        help='import runtime package with PREFIX'\n    )\n    group.add_argument(\n        '--platform', dest='platforms', metavar='NAME', action='append',\n        help='cross platform obfuscation'\n    )\n\n    group = cparser.add_argument_group('runtime key arguments')\n    group.add_argument(\n        '--outer', action='store_true', default=None,\n        help='enable outer runtime key'\n    )\n    group.add_argument(\n        '-e', '--expired', metavar='DATE',\n        help='set expired date'\n    )\n    group.add_argument(\n        '--period', metavar='N', dest='period',\n        help='check runtime key periodically'\n    )\n    group.add_argument(\n        '-b', '--bind-device', dest='devices', metavar='DEV', action='append',\n        help='bind obfuscated scripts to device'\n    )\n    group.add_argument(\n        '--bind-data', metavar='STRING or @FILENAME',\n        help='store user data to runtime key'\n    )\n\n    cparser.add_argument(\n        'inputs', metavar='ARG', nargs='+', help='scripts or packages'\n    )\n\n    cparser.set_defaults(func=cmd_gen)\n\n\ndef cfg_parser(subparsers):\n    '''show all options:\n    pyarmor cfg\n\nshow option `OPT` value:\n    pyarmor cfg OPT\n\nchange option value:\n    pyarmor cfg OPT=VALUE\n\nRefer to\nhttps://pyarmor.readthedocs.io/en/stable/reference/man.html#pyarmor-cfg\n    '''\n\n    cparser = subparsers.add_parser(\n        'cfg',\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=cfg_parser.__doc__,\n        help='show and config Pyarmor environments',\n    )\n\n    cparser.add_argument(\n        '-p', dest='name',\n        help='private settings for special module or package'\n    )\n    cparser.add_argument(\n        '-g', '--global', dest='scope', action='store_true',\n        help='do everything in global settings, otherwise local settings'\n    )\n    cparser.add_argument(\n        '-s', '--section', help=argparse.SUPPRESS\n    )\n    cparser.add_argument(\n        '-r', '--reset', action='store_true',\n        help='reset option to default value'\n    )\n    cparser.add_argument(\n        '--encoding',\n        help='specify encoding to read configuration file'\n    )\n\n    cparser.add_argument(\n        'options', nargs='*', metavar='option',\n        help='option name or \"name=value\"'\n    )\n\n    cparser.set_defaults(func=cmd_cfg)\n\n\ndef reg_parser(subparsers):\n    '''register Pyarmor or upgrade Pyarmor license\n\nAt the first time to register Pyarmor, `-p` (product name) should be\nset. For non-commercial use, set it to \"non-profits\". The product name\ncan't be changed after initial registration.\n\nRefer to\nhttps://pyarmor.readthedocs.io/en/stable/reference/man.html#pyarmor-reg\n    '''\n    cparser = subparsers.add_parser(\n        'reg',\n        aliases=['register', 'r'],\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description=reg_parser.__doc__,\n        help='register Pyarmor or upgrade old Pyarmor license'\n    )\n\n    cparser.add_argument(\n        '-r', '--regname', metavar='NAME',\n        help=argparse.SUPPRESS\n    )\n    cparser.add_argument(\n        '-p', '--product', metavar='NAME',\n        help='bind license to this product'\n    )\n    cparser.add_argument(\n        '-u', '--upgrade', action='store_true',\n        help='upgrade old Pyarmor license'\n    )\n    cparser.add_argument(\n        '-g', '--device', metavar='ID', type=int, choices=range(1, 101),\n        help='device id (1-100) in group license'\n    )\n    cparser.add_argument(\n        '--buy', action='store_true',\n        help='open buy link in default web browser'\n    )\n    cparser.add_argument(\n        '-y', '--confirm', action='store_true',\n        help=argparse.SUPPRESS\n    )\n\n    cparser.add_argument(\n        'regfile', nargs='?', metavar='FILE',\n        help='pyarmor-regcode-xxx.txt or pyarmor-regfile-xxxx.zip'\n    )\n    cparser.set_defaults(func=cmd_reg)\n\n\ndef log_settings(ctx, args):\n    if args.debug:\n        root = logging.getLogger()\n        root.setLevel(logging.DEBUG)\n        handler = logging.FileHandler(ctx.debug_logfile,\n                                      mode='w',\n                                      encoding='utf-8')\n        handler.setFormatter(logging.Formatter('%(asctime)s %(message)s'))\n        handler.setLevel(logging.DEBUG)\n        root.addHandler(handler)\n\n    tracelog = logging.getLogger('trace')\n    tracelog.propagate = False\n    tracelog.addHandler(logging.NullHandler())\n    if ctx.cfg.getboolean('builder', 'enable_trace'):\n        handler = logging.FileHandler(ctx.trace_logfile,\n                                      mode='w',\n                                      encoding='utf-8')\n        handler.setFormatter(logging.Formatter('%(name)-20s %(message)s'))\n        handler.setLevel(logging.DEBUG if args.debug else logging.INFO)\n        tracelog.addHandler(handler)\n\n    if args.silent:\n        logging.getLogger().setLevel(100)\n\n\ndef log_exception(e):\n    logger.debug('unknown error, please check pyarmor.error.log')\n    handler = logging.FileHandler('pyarmor.error.log',\n                                  mode='w',\n                                  encoding='utf-8')\n    fmt = '%(process)d %(processName)s %(asctime)s'\n    handler.setFormatter(logging.Formatter(fmt))\n    log = logging.getLogger('error')\n    log.propagate = False\n    log.addHandler(logging.NullHandler())\n    log.addHandler(handler)\n    log.exception(e)\n\n\ndef print_version(ctx):\n    reg = Register(ctx)\n    info = 'Pyarmor %s' % ctx.version_info(), '', str(reg)\n    print('\\n'.join(info))\n\n    reg.check_group_license()\n\n\ndef get_home_paths(args):\n    home = args.home if args.home else os.getenv('PYARMOR_HOME')\n    if not home:\n        home = os.path.join('~', '.pyarmor')\n    elif home.startswith(','):\n        home = os.path.join('~', '.pyarmor') + home\n    home = os.path.abspath(os.path.expandvars(os.path.expanduser(home)))\n    return (home + ',,,').split(',')[:4]\n\n\ndef main_entry(argv):\n    parser = main_parser()\n    args = parser.parse_args(argv)\n\n    if sys.version_info[0] == 2 or sys.version_info[1] < 7:\n        raise CliError('only Python 3.7+ is supported now')\n\n    ctx = Context(*get_home_paths(args))\n\n    log_settings(ctx, args)\n\n    if args.version:\n        print_version(ctx)\n        parser.exit()\n\n    if args.interactive:\n        return PyarmorShell(ctx).cmdloop()\n\n    logger.info('Python %d.%d.%d', *sys.version_info[:3])\n    logger.info('Pyarmor %s', ctx.version_info())\n    logger.info('Platform %s', ctx.pyarmor_platform)\n\n    logger.debug('native platform %s', ctx.native_platform)\n    logger.debug('home path: %s', ctx.home_path)\n\n    if hasattr(args, 'func'):\n        return args.func(ctx, args)\n    else:\n        parser.print_help()\n\n\ndef main():\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(levelname)-8s %(message)s',\n    )\n\n    try:\n        main_entry(sys.argv[1:])\n    except CliError as e:\n        logger.error(e)\n        sys.exit(1)\n    except Exception as e:\n        log_exception(e)\n        logger.error(e)\n        sys.exit(2)\n\n\nif __name__ == '__main__':\n    main()\n\n\nFile: pyarmor/cli/bootstrap.py\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#############################################################\n#                                                           #\n#      Copyright @ 2023 -  Dashingsoft corp.                #\n#      All rights reserved.                                 #\n#                                                           #\n#      Pyarmor                                              #\n#                                                           #\n#      Version: 8.2.1 -                                     #\n#                                                           #\n#############################################################\n#\n#\n#  @File: pyarmor/cli/bootstrap.py\n#\n#  @Author: Jondy Zhao (pyarmor@163.com)\n#\n#  @Create Date: Fri Apr 14 17:43:59 CST 2023\n#\nimport logging\nimport os\nimport shutil\nimport sys\n\nfrom subprocess import check_output, check_call, Popen, PIPE\n\n\ndef check_prebuilt_runtime_library(platnames, extra=None, rtver=''):\n    pkgpath = os.path.normpath(os.path.dirname(__file__))\n    corepath = os.path.join(pkgpath, 'core')\n    if not os.path.exists(corepath):\n        raise RuntimeError('no found \"{0}\", please run \"pip install {0}\" to '\n                           'install it'.format('pyarmor.cli.core'))\n\n    instcmd = [sys.executable, '-m', 'pip', 'install',\n               '--disable-pip-version-check']\n\n    # Before Pyarmor 8.3, prefer to \"pyarmor.cli.runtime\"\n    # It could be disabled by\n    #     pyarmor cfg pyarmor:cli.runtime = false\n    if rtver.find('.') > 0:\n        runtime_pkgpath = os.path.join(pkgpath, 'runtime')\n        if os.path.exists(runtime_pkgpath):\n            from pyarmor.cli.runtime import __VERSION__ as current_rtver\n            if current_rtver == rtver:\n                return\n\n        pkgver = 'pyarmor.cli.runtime==%s' % rtver\n        logging.info('install \"%s\" for cross platforms', pkgver)\n        try:\n            return check_call(instcmd + [pkgver])\n        except Exception:\n            logging.warning('failed to install \"%s\"' % pkgver)\n\n    # From Pyarmor 8.3, prefer to \"pyarmor.cli.core.PLATFORM\"\n    from pyarmor.cli.core import __VERSION__ as corever\n\n    pkgnames = set(extra if isinstance(extra, list) else\n                   [extra] if isinstance(extra, str) else\n                   ['themida'] if extra else [])\n    if platnames:\n        for plat in platnames:\n            pkgnames.add(plat.split('.')[0])\n\n    for entry in os.scandir(corepath):\n        if entry.name in pkgnames:\n            m = __import__('pyarmor.cli.core.' + entry.name,\n                           globals(), locals(),\n                           ['__VERSION__'], 0)\n            if getattr(m, '__VERSION__', None) == corever:\n                pkgnames.remove(entry.name)\n\n    if pkgnames:\n        pkgvers = ['pyarmor.cli.core.%s==%s' % (x, corever) for x in pkgnames]\n        logging.info('install packages %s for cross platforms', str(pkgvers))\n        try:\n            check_call(instcmd + pkgvers)\n        except Exception as e:\n            logging.error('%s', e)\n            raise RuntimeError('failed to install runtime packages')\n\n\ndef _shell_cmd(cmdlist):\n    logging.info('run: %s', ' '.join(cmdlist))\n    p = Popen(cmdlist, stdout=PIPE, stderr=PIPE, shell=True)\n    stdout, stderr = p.communicate()\n    return p.returncode, stderr\n\n\ndef _check_extension(fullpath):\n    if not os.path.exists(fullpath):\n        logging.error('please re-install pyarmor.cli.core to fix this problem')\n        raise RuntimeError('no found extension \"%s\"' % fullpath)\n\n\ndef _fixup_darwin_rpath(fullpath, pyver):\n    output = check_output(['otool', '-L', sys.executable])\n    for line in output.splitlines():\n        if line.find(b'Frameworks/Python.framework/Versions') > 0:\n            pydll = line.split()[0].decode()\n            logging.info('found CPython library \"%s\"', pydll)\n            break\n\n        if line.find(('libpython' + pyver).encode('utf-8')) > 0:\n            pydll = line.split()[0].decode()\n            logging.info('found CPython library \"%s\"', pydll)\n            break\n    else:\n        raise RuntimeError('no found CPython library')\n\n    # old = '@rpath/Frameworks/Python.framework/Versions/%s/Python' % pyver\n    old = '@rpath/lib/libpython%s.dylib' % pyver\n    cmdlist = ['install_name_tool', '-change', old, pydll, fullpath]\n    rc, err = _shell_cmd(cmdlist)\n    if rc:\n        raise RuntimeError('install_name_tool failed (%d): %s' % (rc, err))\n\n    identity = '-'\n    cmdlist = ['codesign', '-s', identity, '--force',\n               '--all-architectures', '--timestamp', fullpath]\n    rc, err = _shell_cmd(cmdlist)\n    if rc:\n        raise RuntimeError('codesign failed (%d): %s' % (rc, err))\n\n\ndef _fixup_darwin(path, filename, pyver):\n    fullpath = os.path.join(path, filename)\n    _check_extension(fullpath)\n\n    if not os.access(path, os.W_OK):\n        logging.error('please run Python with super user or anyone who has'\n                      'write permission on path \"%s\"', path)\n        raise RuntimeError('current user has no write permission')\n\n    backup = fullpath + '.bak'\n    if os.path.exists(backup):\n        logging.info('create backup file \"%s\"', backup)\n        shutil.copy2(fullpath, backup)\n\n    try:\n        logging.info('start to fixup extension \"%s\"', fullpath)\n        _fixup_darwin_rpath(fullpath, pyver)\n\n        logging.info('fixup extension \"pytransform3\" successfully')\n        logging.info('try command ``pyarmor gen foo.py`` to make sure '\n                     'it works')\n        logging.info('if something is wrong, please restore it from '\n                     'backup file')\n    except Exception:\n        logging.error('fixup extension \"pytransform3\" failed')\n        shutil.move(backup, fullpath)\n        raise\n\n\ndef _fixup_linux(path, filename, pyver):\n    fullpath = os.path.join(path, filename)\n    _check_extension(fullpath)\n\n    rc = _shell_cmd(['ldd', fullpath])\n    if rc:\n        logging.info('try to install package \"libpython%s\" to fix it' % pyver)\n    else:\n        logging.info('nothing to do in this platform')\n\n\ndef _fixup_windows(path, filename, pyver):\n    fullpath = os.path.join(path, filename)\n    _check_extension(fullpath)\n    logging.info('nothing to do in this platform')\n\n\ndef auto_fix(path):\n    '''Deprecated since Pyarmor 8.3.0'''\n    pyver = '%s.%s' % sys.version_info[:2]\n    plat = sys.platform.lower()\n\n    if plat.startswith('darwin'):\n        _fixup_darwin(path, 'pytransform3.so', pyver)\n\n    elif plat.startswith('win'):\n        _fixup_windows(path, 'pytransform3.pyd', pyver)\n\n    elif plat.startswith('linux'):\n        _fixup_windows(path, 'pytransform3.so', pyver)\n\n    else:\n        logging.info('nothing to fixup in this platform \"%s\"', plat)\n\n\ndef main():\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(levelname)-8s %(message)s',\n    )\n\n    logging.info('Python: %d.%d', *sys.version_info[:2])\n    corepath = os.path.join(os.path.dirname(__file__), 'core')\n    logging.info('pyarmor.cli.core: %s', corepath)\n    # auto_fix(corepath)\n    logging.warning('this feature has been deprecated since Pyarmor 8.3.0')\n    logging.info('nothing to do')\n\n\nif __name__ == '__main__':\n    main()\n\n\nFile: pyarmor/cli/register.py\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#############################################################\n#                                                           #\n#      Copyright @ 2023 -  Dashingsoft corp.                #\n#      All rights reserved.                                 #\n#                                                           #\n#      Pyarmor                                              #\n#                                                           #\n#      Version: 8.0.1 -                                     #\n#                                                           #\n#############################################################\n#\n#\n#  @File: cli/register.py\n#\n#  @Author: Jondy Zhao (pyarmor@163.com)\n#\n#  @Create Date: Mon Jan  2 15:39:08 CST 2023\n#\nimport os\n\nfrom base64 import b64decode, urlsafe_b64encode\nfrom json import loads as json_loads\nfrom string import Template\n\nfrom . import logger, CliError\n\n\n# All supported machine flags for group license: [11, 26)\nMACHFLAGS = 22, 21, 18, 20, 16, 11\n\n\ndef parse_token(data):\n    from struct import unpack\n\n    if not data or data.find(b' ') == -1:\n        return {\n            'token': 0,\n            'rev': 0,\n            'features': 0,\n            'licno': 'pyarmor-vax-000000',\n            'regname': '',\n            'product': 'non-profits',\n            'note': 'This is trial license'\n        }\n\n    buf = b64decode(data.split()[0])\n\n    token, value = unpack('II', buf[:8])\n    rev, features = value & 0xff, value >> 8\n    licno = buf[16:34].decode('utf-8')\n\n    pstr = []\n    i = 64\n    for k in range(4):\n        n = buf[i]\n        i += 1\n        pstr.append(buf[i:i+n].decode('utf-8') if n else '')\n        i += n\n\n    product = 'non-profits(TBD)' if pstr[2] in ('', 'TBD') else pstr[2]\n    return {\n        'token': token,\n        'rev': rev,\n        'features': features,\n        'licno': licno,\n        'machine': pstr[0],\n        'regname': pstr[1],\n        'product': product,\n        'note': pstr[3],\n    }\n\n\nclass Register(object):\n\n    def __init__(self, ctx):\n        self.ctx = ctx\n        self.notes = []\n\n    def check_args(self, args):\n        if args.upgrade and args.keyfile.endswith('.zip'):\n            raise CliError('use .txt file to upgrade, not .zip file')\n\n    def _get_old_rcode(self):\n        old_license = self.ctx.read_license()\n        if not old_license:\n            logger.debug('no license file found')\n            return\n        if len(old_license) == 256:\n            logger.debug('no old purchased license')\n            return\n\n        data = b64decode(old_license)\n        i = data.find(b'pyarmor-vax-')\n        if i == -1:\n            raise CliError('no valid old license')\n        return data[i:i+18].decode()\n\n    def regurl(self, ucode, product=None, rcode=None, prepare=False):\n        url = self.ctx.cfg['pyarmor']['regurl'] % ucode\n        if product:\n            url += '&product=' + \\\n                urlsafe_b64encode(product.encode('utf-8')).decode()\n        if rcode:\n            url += '&rcode=' + rcode\n        if prepare:\n            url += '&prepare=1'\n        return url\n\n    def update_token(self):\n        from .core import Pytransform3\n        with open(self.ctx.license_token, 'wb') as f:\n            f.close()\n        Pytransform3._update_token(self.ctx)\n\n    @property\n    def license_info(self):\n        return parse_token(self.ctx.read_token())\n\n    def _license_type(self, info):\n        return 'basic' if info['features'] == 1 else \\\n            'pro' if info['features'] == 7 else \\\n            'group' if info['features'] == 15 else \\\n            'trial' if info['token'] == 0 else 'unknown'\n\n    def _license_to(self, info):\n        name = info['regname']\n        product = info['product']\n        return '%s (%s)' % (product, name) if name and product else \\\n            'non-profits' if not name else 'non-profits (%s)' % name\n\n    def parse_keyfile(self, filename):\n        with open(filename, 'r', encoding='utf-8') as f:\n            for line in f:\n                line = line.strip()\n                marker = 'Dear '\n                if line.startswith(marker):\n                    regname = line[len(marker):].strip(' ,')\n                    break\n\n            for line in f:\n                line = line.strip()\n                if len(line) == 192 and line.find(' ') == -1:\n                    return regname, line\n\n        raise CliError('no registration code found in %s' % filename)\n\n    def register_regfile(self, regfile, clean=True):\n        from zipfile import ZipFile\n\n        path = self.ctx.reg_path\n        with ZipFile(regfile, 'r') as f:\n            for item in ('license.lic', '.pyarmor_capsule.zip'):\n                logger.debug('extracting %s', item)\n                f.extract(item, path=path)\n            namelist = f.namelist()\n            if 'group.tokens' in namelist:\n                logger.info('machine id in group license: %s', ', '.join([\n                    x[7:] for x in namelist if x.startswith('tokens')\n                ]))\n                for idver in MACHFLAGS:\n                    machid = self._get_machine_id(idver).decode('utf-8')\n                    logger.info('got machine id: %s', machid)\n                    name = '/'.join(['tokens', machid])\n                    if name in namelist:\n                        logger.info('this machine id matchs group license')\n                        break\n                else:\n                    logger.info('no machine id matchs this group license')\n                    logger.info('take this machine as docker container, and '\n                                'connect to docker host for authentication...')\n                    mlist = self._get_docker_hostname()\n                    if not mlist:\n                        logger.info(\n                            'could not get docker host machine id\\n%s',\n                            '\\n'.join([\n                                '',\n                                'if this machine is docker container, please '\n                                'run command `pyarmor-auth` in docker host, '\n                                'and try it again', '',\n                                'otherwise please generate new group '\n                                'device license for this machine', '',\n                                'more information please check section '\n                                '\"using group license\" in documentation '\n                                '\"how-to register\" guide', ''\n                            ]))\n                        raise CliError('this group device license is not for '\n                                       'this machine')\n                    for machid in mlist:\n                        hostname = '/'.join(['tokens', machid])\n                        if hostname in namelist:\n                            name = hostname\n                            break\n                    else:\n                        logger.debug('docker host machine ids: %s', mlist)\n                        raise CliError('this group device license is not for '\n                                       'this docker host')\n                logger.debug('extracting %s', name)\n                self.ctx.save_token(f.read(name))\n                return\n            if 'group.info' in namelist:\n                logger.info('refer to http://pyarmor.readthedocs.io/en/stable/how-to/register.html'\n                            '#using-group-license')\n                raise CliError('wrong usage for group license')\n\n        logger.info('update license token')\n        self.update_token()\n\n    def _get_docker_hostname(self):\n        try:\n            from socket import socket, AF_INET, SOCK_STREAM\n            host = os.getenv('PYARMOR_DOCKER_HOST', 'host.docker.internal')\n            port = 29092\n            rlist = []\n            with socket(AF_INET, SOCK_STREAM) as s:\n                s.connect((host, port))\n                s.sendall(b'PADH' + b'x' * 60)\n                while True:\n                    flag = s.recv(1)\n                    if ord(flag) - 87 in MACHFLAGS:\n                        data = s.recv(32)\n                    machid = (flag + data).decode('utf-8')\n                    logger.info('got docker host machine id: %s', machid)\n                    rlist.append(machid)\n                    if s.recv(1) == b'\\x00':\n                        break\n            return rlist\n        except Exception as e:\n            logger.debug('%s:%d:%s', host, port, str(e))\n\n    def _get_machine_id(self, devflag=11):\n        from .core import Pytransform3\n        return Pytransform3.get_hd_info(devflag)\n\n    def generate_group_device(self, devid):\n        from datetime import datetime\n        from platform import uname\n        path = self.ctx.group_device_file(devid)\n        logger.info('generating device file \"%s\"', path)\n        os.makedirs(os.path.dirname(path), exist_ok=True)\n        uinfo = uname()\n        devflag = self.ctx.cfg['builder'].getint('group_device_flag', 21)\n        machid = self._get_machine_id(devflag).decode('utf-8')\n        logger.info('current machine id is \"%s\"', machid)\n        tpl = Template('\\n'.join([\n            '# Generated by Pyarmor $rev, $timestamp',\n            'host: $node',\n            'system: $host ($version)',\n            'machine: $machine'\n        ])).substitute(\n            rev='.'.join(self.ctx.version),\n            node=uinfo.node,\n            host=uinfo.system,\n            version=uinfo.version,\n            timestamp=datetime.now().isoformat(),\n            machine=machid,\n        )\n        with open(path, \"wb\") as f:\n            f.write(tpl.encode('utf-8'))\n        return path\n\n    def check_group_license(self, silent=False):\n        licinfo = self.ctx.license_info\n        if licinfo['features'] & 8:\n            licmach = licinfo.get('machine', '')\n            if not licmach:\n                raise RuntimeError('no token machine')\n\n            idver = ord(licmach[0]) - 87\n            # This can't be called in \"cmd_gen\", otherwise crash\n            machid = self._get_machine_id(idver).decode('utf-8')\n            if machid == licmach:\n                return\n\n            mlist = self._get_docker_hostname()\n            if mlist and licmach in mlist:\n                return\n\n            logger.info('this license is for machine: %s', licmach)\n\n            if mlist:\n                logger.info('but docker host machine ids: %s',\n                            ', '.join(mlist))\n                raise RuntimeError(\n                    'this group license is not for this docker host')\n            else:\n                logger.info('but this machine id: %s', machid)\n                raise RuntimeError(\n                    'this group license is not for this machine')\n\n    def __str__(self):\n        '''$advanced\n\nNotes\n$notes\n'''\n\n        info = self.license_info\n        lictype = self._license_type(info)\n\n        fmt = '%-16s: %s'\n        lines = [\n            fmt % ('License Type', 'pyarmor-' + lictype),\n            fmt % ('License No.', info['licno']),\n            fmt % ('License To', info['regname']),\n            fmt % ('License Product', info['product']),\n            '',\n        ]\n\n        bccmode = info['features'] & 2\n        rftmode = info['features'] & 4\n        advanced = [\n            fmt % ('BCC Mode', 'Yes' if bccmode else 'No'),\n            fmt % ('RFT Mode', 'Yes' if rftmode else 'No'),\n        ]\n        if lictype == 'trial':\n            self.notes.append('* Can\\'t obfuscate big script and mix str')\n        elif lictype in ('bacic', 'pro'):\n            self.notes.append('* Each obfuscation need verify license online')\n        elif lictype == 'group':\n            self.notes.append('* Offline obfuscation')\n\n        lines.append(Template(self.__str__.__doc__).substitute(\n            advanced='\\n'.join(advanced),\n            notes='\\n'.join(self.notes),\n        ))\n\n        return '\\n'.join(lines)\n\n\nupgrade_to_basic_info = Template('''\nYou are about to upgrade old Pyarmor license to Pyarmor Basic License\n\nThe upgraded license information will be''')\n\nupgrade_to_pro_info = Template('''\nYou are about to upgrade old Pyarmor license to Pyarmor Pro License\n\nThe original license no: $rcode\n\nThe upgraded license information will be''')\n\n\nclass WebRegister(Register):\n\n    def _request(self, url):\n        from http.client import HTTPSConnection\n        n = len('https://')\n        k = url.find('/', n)\n        conn = HTTPSConnection(url[n:k])\n        conn.request(\"GET\", url[k:])\n        return conn.getresponse()\n\n    def _send_request(self, url, timeout=6.0):\n        try:\n            return self._request(url)\n        except Exception as e:\n            logger.debug('direct request failed \"%s\"', str(e))\n\n        from urllib.request import urlopen\n        from ssl import _create_unverified_context\n        context = _create_unverified_context()\n        return urlopen(url, None, timeout, context=context)\n\n    def _remove_token(self):\n        if os.path.exists(self.ctx.license_token):\n            logger.debug('remove old token')\n            os.remove(self.ctx.license_token)\n\n    def prepare(self, keyfile, product, upgrade=False):\n        reginfo = self.parse_keyfile(keyfile)\n        logger.info('prepare \"%s\"', keyfile)\n\n        rcode = self._get_old_rcode() if upgrade else None\n        if upgrade and not rcode and keyfile.endswith('regcode-to-pro.txt'):\n            logger.error('please use `pyarmor-7 -v` to check old license')\n            logger.error('this code is used to upgrade old license')\n            raise CliError('no found old license in this machine')\n        url = self.regurl(reginfo[1], rcode=rcode, prepare=True)\n        logger.debug('url: %s', url)\n\n        logger.info('query key file from server')\n        with self._send_request(url) as res:\n            if not res:\n                logger.error('please try it later')\n                raise CliError('no response from license server')\n            if res.code != 200:\n                logger.error('HTTP Error %s', res.code)\n                raise CliError(res.read().decode('utf-8'))\n            info = json_loads(res.read())\n\n        pname = info['product']\n        if pname in ('', 'TBD'):\n            info['product'] = product\n        elif pname != product:\n            logger.warning('this license is bind to product \"%s\"', pname)\n            logger.warning('it can not be changed to \"%s\"', product)\n\n        lines = []\n        if upgrade:\n            if rcode and not rcode.startswith('pyarmor-vax-'):\n                logger.error('please check Pyarmor 8 EULA')\n                raise CliError('old license \"%s\" can not be upgraded' % rcode)\n            if info['upgrade']:\n                lines.append(upgrade_to_pro_info.substitute(rcode=rcode))\n            else:\n                lines.append(upgrade_to_basic_info.substitute())\n        else:\n            if info['lictype'] not in ('BASIC', 'PRO', 'GROUP'):\n                logger.error('this license does not work in Pyarmor 8')\n                logger.error('please check Pyarmor 8.0 EULA')\n                raise CliError('unknown license type %s' % info['lictype'])\n            lines.append('This license registration information will be')\n\n        if info['product'] in ('', 'TBD') and info['lictype'] == 'GROUP':\n            raise CliError('\"TBD\" is invalid product name for group license')\n\n        fmt = '%-16s: %s'\n        lines.extend([\n            '',\n            fmt % ('License Type', 'pyarmor-' + info['lictype'].lower()),\n            fmt % ('License To', info['regname']),\n            fmt % ('License Product', info['product']),\n            '',\n        ])\n        if info['product'] == 'non-profits':\n            lines.append('This license is about to be used for non-profits')\n        elif info['product'] in ('', 'TBD'):\n            lines.append('This license is bind to non-profits(TBD) '\n                         'for the time being')\n            lines.append('If not change \"TBD\" to product name in 6 months, '\n                         'it will be set to \"non-profits\" automatically')\n        else:\n            lines.append('This license is about to be used for product \"%s\"'\n                         % info['product'])\n\n        lines.extend(['', ''])\n        return info, '\\n'.join(lines)\n\n    def upgrade_to_pro(self, keyfile, product):\n        logger.info('process upgrading file \"%s\"', keyfile)\n        reginfo = self.parse_keyfile(keyfile)\n\n        rcode = self._get_old_rcode()\n        logger.info('old license no: %s', rcode)\n\n        url = self.regurl(reginfo[1], product=product, rcode=rcode)\n        logger.debug('url: %s', url)\n\n        logger.info('send upgrade request to server')\n        res = self._send_request(url)\n        regfile = self._handle_response(res)\n\n        logger.info('update license token')\n        self.update_token()\n        logger.info('This license has been upgraded successfully')\n\n        notes = '* Please backup regfile \"%s\" carefully, and ' \\\n            'use this file for subsequent registration' % regfile,\n        logger.info('Import Notes:\\n\\n%s\\n', notes)\n\n    def register(self, keyfile, product, upgrade=False, group=False):\n        if keyfile.endswith('.zip'):\n            logger.info('register \"%s\"', keyfile)\n            self.register_regfile(keyfile)\n            return\n\n        logger.info('process activation file \"%s\"', keyfile)\n        reginfo = self.parse_keyfile(keyfile)\n\n        url = self.regurl(reginfo[1], product=product)\n        if upgrade:\n            url += '&upgrade_to_basic=1'\n        logger.debug('url: %s', url)\n\n        logger.info('send request to server')\n        res = self._send_request(url)\n        regfile = self._handle_response(res)\n\n        notes = [\n            '* Please backup regfile \"%s\" carefully, and '\n            'use this file for subsequent registration' % regfile,\n            '* Do not use \"%s\" again' % os.path.basename(keyfile),\n        ]\n\n        if group:\n            logger.info('This group license has been activated sucessfully')\n            notes.append('* Please check `pyarmor reg` in Man page for '\n                         'how to register Pyarmor on offline device')\n        else:\n            logger.info('register \"%s\"', regfile)\n            self.register_regfile(regfile)\n            logger.info('This license code has been %s successfully',\n                        'upgraded' if upgrade else 'activated')\n\n        logger.info('Import Notes:\\n\\n%s\\n', '\\n'.join(notes))\n\n    def _handle_response(self, res):\n        if res and res.code == 200:\n            dis = res.headers.get('Content-Disposition')\n            filename = dis.split('\"')[1] if dis else 'pyarmor-regfile.zip'\n            logger.info('write registration file \"%s\"', filename)\n            data = res.read()\n            if data.startswith(b'{\"group\":'):\n                n = data.find(b'}') + 1\n                with open(filename, 'wb') as f:\n                    f.write(data[n:])\n                self._write_group_info(filename, data[:n])\n            else:\n                with open(filename, 'wb') as f:\n                    f.write(data)\n            return filename\n\n        elif res:\n            raise CliError(res.read().decode('utf-8'))\n\n        raise CliError('no response from license server')\n\n    def _write_group_info(self, filename, data):\n        from zipfile import ZipFile\n        logger.info('write group information')\n        with ZipFile(filename, 'a') as f:\n            f.writestr('group.info', data)\n\n    def register_group_device(self, regfile, devid, rev=1):\n        from zipfile import ZipFile\n        devfile = self.ctx.group_device_file(devid)\n        logger.info('register device file \"%s\"', devfile)\n        logger.info('use group license \"%s\"', regfile)\n        if not os.path.exists(devfile):\n            logger.error('please generate device file in offline device by')\n            logger.error('    pyarmor reg -g %s', devid)\n            logger.error('and copy generated device file to this machine')\n            raise CliError('no group device file \"%s\"' % devfile)\n\n        with open(devfile) as f:\n            prefix = 'machine:'\n            for line in f:\n                if line.startswith(prefix):\n                    machid = line[len(prefix):].strip()\n                    break\n            else:\n                logger.error('no machid information in device file')\n                raise CliError('invalid device file \"%s\"' % devfile)\n\n        with ZipFile(regfile, 'r') as f:\n            if 'group.info' not in f.namelist():\n                logger.error('no group information in group license file')\n                raise CliError('invalid group license file \"%s\"' % regfile)\n            group = json_loads(f.read('group.info'))\n            licdata = f.read('license.lic')\n            capsule = f.read('.pyarmor_capsule.zip')\n\n        # Ignore token cache\n        tokencache = os.path.join(os.path.dirname(devfile), 'tokens', machid)\n        if False and os.path.exists(tokencache):\n            logger.info('read cached \"%s\"', tokencache)\n            with open(tokencache, 'rb') as f:\n                data = f.read()\n            filename = regfile.replace('pyarmor-', 'pyarmor-device-').replace(\n                '.zip', '.%s.zip' % devid)\n            logger.info('write registeration file \"%s\"', filename)\n        else:\n            logger.info('send request to server')\n            url = self.regurl('/'.join(['group', group['ucode']]))\n            paras = ('rev', str(rev)), ('group', str(group['group'])), \\\n                ('source', machid), ('devid', str(devid))\n            url += '&'.join(['='.join(x) for x in paras])\n            logger.debug('url: %s', url)\n\n            res = self._send_request(url)\n            filename = self._handle_response(res)\n            with open(filename, 'rb') as f:\n                data = f.read()\n            os.makedirs(os.path.dirname(tokencache), exist_ok=True)\n            with open(tokencache, 'wb') as f:\n                f.write(data)\n\n        with ZipFile(filename, 'w') as f:\n            f.writestr('license.lic', licdata)\n            f.writestr('.pyarmor_capsule.zip', capsule)\n            f.writestr('group.tokens', b'')\n            f.writestr('tokens/' + machid, data)\n\n        logger.info('please copy deivce regfile to offline device and run')\n        logger.info('    pyarmor reg %s', filename)\n\n\nFile: pyarmor/cli/repack.py\nimport logging\nimport marshal\nimport os\nimport shutil\nimport struct\nimport tempfile\n\nfrom importlib._bootstrap_external import _code_to_timestamp_pyc\nfrom subprocess import check_call, check_output, DEVNULL\n\nfrom PyInstaller.archive.writers import ZlibArchiveWriter, CArchiveWriter\nfrom PyInstaller.archive.readers import CArchiveReader\ntry:\n    from PyInstaller.loader.pyimod02_archive import ZlibArchiveReader\nexcept ModuleNotFoundError:\n    # Since 5.3\n    from PyInstaller.loader.pyimod01_archive import ZlibArchiveReader\nfrom PyInstaller.compat import is_darwin, is_linux, is_win\n\n\n# Type codes for PYZ PYZ entries\nPYZ_ITEM_MODULE = 0\nPYZ_ITEM_PKG = 1\nPYZ_ITEM_DATA = 2\nPYZ_ITEM_NSPKG = 3  # PEP-420 namespace package\n\n# Type codes for CArchive TOC entries\nPKG_ITEM_BINARY = 'b'  # binary\nPKG_ITEM_DEPENDENCY = 'd'  # runtime option\nPKG_ITEM_PYZ = 'z'  # zlib (pyz) - frozen Python code\nPKG_ITEM_ZIPFILE = 'Z'  # zlib (pyz) - frozen Python code\nPKG_ITEM_PYPACKAGE = 'M'  # Python package (__init__.py)\nPKG_ITEM_PYMODULE = 'm'  # Python module\nPKG_ITEM_PYSOURCE = 's'  # Python script (v3)\nPKG_ITEM_DATA = 'x'  # data\nPKG_ITEM_RUNTIME_OPTION = 'o'  # runtime option\nPKG_ITEM_SPLASH = 'l'  # splash resources\n\n# Path suffix for extracted contents\nEXTRACT_SUFFIX = '_extracted'\n\n\nlogger = logging.getLogger('repack')\n\n\nclass CArchiveReader2(CArchiveReader):\n\n    def find_magic_pattern(self, fp, magic_pattern):\n        # Start at the end of file, and scan back-to-start\n        fp.seek(0, os.SEEK_END)\n        end_pos = fp.tell()\n\n        # Scan from back\n        SEARCH_CHUNK_SIZE = 8192\n        magic_offset = -1\n        while end_pos >= len(magic_pattern):\n            start_pos = max(end_pos - SEARCH_CHUNK_SIZE, 0)\n            chunk_size = end_pos - start_pos\n            # Is the remaining chunk large enough to hold the pattern?\n            if chunk_size < len(magic_pattern):\n                break\n            # Read and scan the chunk\n            fp.seek(start_pos, os.SEEK_SET)\n            buf = fp.read(chunk_size)\n            pos = buf.rfind(magic_pattern)\n            if pos != -1:\n                magic_offset = start_pos + pos\n                break\n            # Adjust search location for next chunk; ensure proper overlap\n            end_pos = start_pos + len(magic_pattern) - 1\n\n        return magic_offset\n\n    def get_cookie_info(self, fp):\n        magic = getattr(self, '_COOKIE_MAGIC_PATTERN',\n                        getattr(self, 'MAGIC', b'MEI\\014\\013\\012\\013\\016'))\n        cookie_pos = self.find_magic_pattern(fp, magic)\n\n        cookie_format = getattr(self, '_COOKIE_FORMAT',\n                                getattr(self, '_cookie_format', '!8sIIii64s'))\n        cookie_size = struct.calcsize(cookie_format)\n\n        fp.seek(cookie_pos, os.SEEK_SET)\n        return struct.unpack(cookie_format, fp.read(cookie_size))\n\n    def get_toc(self):\n        if isinstance(self.toc, dict):\n            return self.toc\n        return {entry[-1]: entry[:-1] for entry in self.toc}\n\n    def open_pyzarchive(self, name):\n        if hasattr(self, 'open_embedded_archive'):\n            return self.open_embedded_archive(name)\n\n        ndx = self.toc.find(name)\n        (dpos, dlen, ulen, flag, typcd, nm) = self.toc.get(ndx)\n        return ZlibArchiveReader(self.path, self.pkg_start + dpos)\n\n    def get_logical_toc(self, buildpath, obfpath):\n        logical_toc = []\n\n        for name, entry in self.get_toc().items():\n            *_, flag, typecode = entry\n            if typecode == PKG_ITEM_PYMODULE:\n                source = os.path.join(obfpath, name + '.py')\n            elif typecode == PKG_ITEM_PYSOURCE:\n                source = os.path.join(obfpath, name + '.py')\n            elif typecode == PKG_ITEM_PYPACKAGE:\n                source = os.path.join(obfpath, name, '__init__.py')\n            elif typecode == PKG_ITEM_PYZ:\n                source = os.path.join(buildpath, name)\n            elif typecode in (PKG_ITEM_DEPENDENCY, PKG_ITEM_RUNTIME_OPTION):\n                source = ''\n            else:\n                source = None\n            if source and not os.path.exists(source):\n                source = None\n            logical_toc.append((name, source, flag, typecode))\n\n        return logical_toc\n\n\nclass CArchiveWriter2(CArchiveWriter):\n\n    def __init__(self, pkg_arch, archive_path, logical_toc, pylib_name):\n        self._orgarch = pkg_arch\n        super().__init__(archive_path, logical_toc, pylib_name)\n\n    def _write_rawdata(self, name, typecode, compress):\n        rawdata = fix_extract(self._orgarch.extract(name))\n        if hasattr(self, '_write_blob'):\n            # Since 5.0\n            self._write_blob(rawdata, name, typecode, compress)\n            return\n\n        with tempfile.TemporaryDirectory() as tmpdir:\n            pathname = os.path.join(tmpdir,\n                                    name.replace('/', '_').replace('\\\\', '_'))\n            with open(pathname, 'wb') as f:\n                f.write(rawdata)\n            if typecode in (PKG_ITEM_PYSOURCE, PKG_ITEM_PYMODULE,\n                            PKG_ITEM_PYPACKAGE):\n                super().add((name, pathname, compress, PKG_ITEM_DATA))\n                tc = self.toc.data[-1]\n                self.toc.data[-1] = tc[:-2] + (typecode, tc[-1])\n            else:\n                super().add((name, pathname, compress, typecode))\n\n    def add(self, entry):\n        name, source, compress, typecode = entry[:4]\n        if source is None:\n            self._write_rawdata(name, typecode, compress)\n        else:\n            logger.info('replace entry \"%s\"', name)\n            super().add(entry)\n\n    def _write_entry(self, fp, entry):\n        '''For PyInstaller 5.10+'''\n        name, source, compress, typecode = entry[:4]\n        if source is None:\n            rawdata = self._orgarch.extract(name)\n            return self._write_blob(fp, rawdata, name, typecode, compress)\n        return super()._write_entry(fp, entry)\n\n\ndef fix_extract(data):\n    return data[1] if isinstance(data, tuple) else data\n\n\ndef extract_pyzarchive(name, pyzarch, output):\n    dirname = os.path.join(output, name + EXTRACT_SUFFIX)\n    os.makedirs(dirname, exist_ok=True)\n\n    for name, (typecode, offset, length) in pyzarch.toc.items():\n        # Prevent writing outside dirName\n        filename = name.replace('..', '__').replace('.', os.path.sep)\n        if typecode == PYZ_ITEM_PKG:\n            filepath = os.path.join(dirname, filename, '__init__.pyc')\n        elif typecode == PYZ_ITEM_MODULE:\n            filepath = os.path.join(dirname, filename + '.pyc')\n        elif typecode == PYZ_ITEM_DATA:\n            filepath = os.path.join(dirname, filename)\n        elif typecode == PYZ_ITEM_NSPKG:\n            filepath = os.path.join(dirname, filename, '__init__.pyc')\n        else:\n            continue\n        os.makedirs(os.path.dirname(filepath), exist_ok=True)\n        with open(filepath, 'wb') as f:\n            f.write(_code_to_timestamp_pyc(fix_extract(pyzarch.extract(name))))\n\n    return dirname\n\n\ndef repack_pyzarchive(pyzpath, pyztoc, obfpath, rtname, cipher=None):\n    # logic_toc tuples: (name, src_path, typecode)\n    #   `name` is the name without suffix)\n    #   `src_path` is name of the file from which the resource is read\n    #   `typecode` is the Analysis-level TOC typecode (`PYMODULE` or `DATA`)\n    logical_toc = []\n    code_dict = {}\n    extract_path = pyzpath + EXTRACT_SUFFIX\n\n    def compile_item(name, filename):\n        fullpath = os.path.join(obfpath, filename)\n        if not os.path.exists(fullpath):\n            fullpath = fullpath + 'c'\n        if os.path.exists(fullpath):\n            logger.info('replace item \"%s\"', name)\n            with open(fullpath, 'r') as f:\n                co = compile(f.read(), '<frozen %s>' % name, 'exec')\n                code_dict[name] = co\n        else:\n            fullpath = os.path.join(extract_path, filename + 'c')\n            with open(fullpath, 'rb') as f:\n                f.seek(16)\n                code_dict[name] = marshal.load(f)\n        return fullpath\n\n    fullpath = os.path.join(obfpath, rtname, '__init__.py')\n    logical_toc.append((rtname, fullpath, 'PYMODULE'))\n    compile_item(rtname, os.path.join(rtname, '__init__.py'))\n\n    for name, (typecode, offset, length) in pyztoc.items():\n        ptname = name.replace('..', '__').replace('.', os.path.sep)\n        pytype = 'PYMODULE'\n        if typecode == PYZ_ITEM_PKG:\n            fullpath = compile_item(name, os.path.join(ptname, '__init__.py'))\n        elif typecode == PYZ_ITEM_MODULE:\n            fullpath = compile_item(name, ptname + '.py')\n        elif typecode == PYZ_ITEM_DATA:\n            fullpath = os.path.join(extract_path, ptname)\n            pytype = 'DATA'\n        elif typecode == PYZ_ITEM_NSPKG:\n            fullpath = compile_item(name, os.path.join(ptname, '__init__.py'))\n            fullpath = '-'\n        else:\n            raise ValueError('unknown PYZ item type \"%s\"' % typecode)\n        logical_toc.append((name, fullpath, pytype))\n\n    # It seems PyInstaller 6.0+ no keyword parameter: cipher\n    ZlibArchiveWriter(pyzpath, logical_toc, code_dict, cipher=cipher)\n\n\ndef repack_carchive(executable, pkgfile, buildpath, obfpath, rtentry):\n    pkgarch = CArchiveReader2(executable)\n    with open(executable, 'rb') as fp:\n        *_, pylib_name = pkgarch.get_cookie_info(fp)\n    logical_toc = pkgarch.get_logical_toc(buildpath)\n    if rtentry is not None:\n        logical_toc.append(rtentry)\n    pylib_name = pylib_name.strip(b'\\x00').decode('utf-8')\n    CArchiveWriter2(pkgarch, pkgfile, logical_toc, pylib_name)\n\n\ndef repack_executable(executable, buildpath, obfpath, rtentry, codesign=None):\n    pkgname = 'PKG-patched'\n\n    logger.info('repacking PKG \"%s\"', pkgname)\n    pkgfile = os.path.join(buildpath, pkgname)\n    repack_carchive(executable, pkgfile, buildpath, obfpath, rtentry)\n\n    logger.info('repacking EXE \"%s\"', executable)\n\n    if is_darwin:\n        import PyInstaller.utils.osx as osxutils\n        if hasattr(osxutils, 'remove_signature_from_binary'):\n            logger.info(\"remove signature(s) from EXE\")\n            osxutils.remove_signature_from_binary(executable)\n\n    if is_linux:\n        logger.info('replace section \"pydata\" with \"%s\"', pkgname)\n        check_call(['objcopy', '--update-section', 'pydata=%s' % pkgfile,\n                    executable])\n    else:\n        reader = CArchiveReader2(executable)\n        logger.info('replace PKG with \"%s\"', pkgname)\n        with open(executable, 'r+b') as outf:\n            info = reader.get_cookie_info(outf)\n            offset = os.fstat(outf.fileno()).st_size - info[1]\n            # Keep bootloader\n            outf.seek(offset, os.SEEK_SET)\n\n            # Write the patched archive\n            with open(pkgfile, 'rb') as infh:\n                shutil.copyfileobj(infh, outf, length=64*1024)\n\n            outf.truncate()\n\n        if is_darwin:\n            # Fix Mach-O header for codesigning on OS X.\n            logger.info('fixing EXE for code signing')\n            import PyInstaller.utils.osx as osxutils\n            osxutils.fix_exe_for_code_signing(executable)\n            # Since PyInstaller 4.4\n            if hasattr(osxutils, 'sign_binary'):\n                logger.info(\"re-signing the EXE\")\n                osxutils.sign_binary(executable, identity=codesign)\n\n        elif is_win:\n            # Set checksum to appease antiviral software.\n            from PyInstaller.utils.win32 import winutils\n            if hasattr(winutils, 'set_exe_checksum'):\n                winutils.set_exe_checksum(executable)\n\n    logger.info('generate patched bundle \"%s\" successfully', executable)\n\n\nclass Repacker:\n\n    def __init__(self, executable, buildpath, codesign=None):\n        self.executable = executable\n        self.buildpath = buildpath\n        self.codesign = codesign\n        self.extract_carchive(executable, buildpath)\n\n    def check(self):\n        try:\n            from PyInstaller import __version__ as pyi_version\n            major = int(pyi_version.split('.')[0])\n        except Exception as e:\n            logger.warning(\"can't get PyInstaller version: %s\", str(e))\n            pyi_version = 'unknown'\n            major = 6\n\n        if major > 5:\n            logger.info(\n                'Please check documentation `insight into pack command`'\n                'to find solutions or downgrade PyInstaller to version 5')\n            raise NotImplementedError(\n                \"PyInstaller %s isn't supported\" % pyi_version)\n\n    def extract_carchive(self, executable, buildpath, clean=True):\n        logger.info('extracting bundle \"%s\"', executable)\n        if os.path.exists(self.buildpath):\n            shutil.rmtree(self.buildpath)\n        os.makedirs(self.buildpath)\n\n        contents = []\n        pkgarch = CArchiveReader2(executable)\n        pkgtoc = pkgarch.get_toc()\n\n        with open(executable, 'rb') as fp:\n            *_, pylib_name = pkgarch.get_cookie_info(fp)\n        self.pylib_name = pylib_name.strip(b'\\x00').decode('utf-8')\n        logger.debug('pylib_name is \"%s\"', self.pylib_name)\n\n        for name, toc_entry in pkgtoc.items():\n            logger.debug('extract %s', name)\n            *_, typecode = toc_entry\n\n            if typecode == PKG_ITEM_PYZ:\n                pyzarch = pkgarch.open_pyzarchive(name)\n                self.pyztoc = pyzarch.toc\n                contents.append(extract_pyzarchive(name, pyzarch, buildpath))\n\n        self.contents = contents\n        self.one_file_mode = len(pkgtoc) > 10 and not any([\n            x.name == 'base_library.zip'\n            for x in os.scandir(os.path.dirname(executable))])\n        logger.debug('one file mode is %s', bool(self.one_file_mode))\n\n    def repack(self, obfpath, rtname, entry=None):\n        buildpath = self.buildpath\n        executable = self.executable\n        codesign = self.codesign\n        logger.info('repacking bundle \"%s\"', executable)\n\n        obfpath = os.path.normpath(obfpath)\n        logger.info('obfuscated scripts at \"%s\"', obfpath)\n\n        name, ext = os.path.splitext(os.path.basename(executable))\n        entry = name if entry is None else entry\n        logger.info('entry script name is \"%s.py\"', entry)\n\n        rtpath = os.path.join(obfpath, rtname)\n        logger.debug('runtime package at %s', rtpath)\n        for item in self.contents:\n            if item.endswith(EXTRACT_SUFFIX):\n                pyzpath = item[:-len(EXTRACT_SUFFIX)]\n                logger.info('repacking \"%s\"', os.path.basename(pyzpath))\n                repack_pyzarchive(pyzpath, self.pyztoc, obfpath, rtname)\n\n        for x in os.listdir(rtpath):\n            ext = os.path.splitext(x)[-1]\n            if x.startswith('pyarmor_runtime') and ext in ('.so', '.pyd'):\n                rtbinary = os.path.join(rtpath, x)\n                rtbinname = os.path.join(rtname, x)\n                break\n        else:\n            raise RuntimeError('no pyarmor runtime files found')\n\n        if is_darwin:\n            # Not required since 8.3.0\n            # from PyInstaller.depend import dylib\n            # self._fixup_darwin_rtbinary(rtbinary, self.pylib_name)\n            # logger.debug('mac_set_relative_dylib_deps \"%s\"', rtbinname)\n            # dylib.mac_set_relative_dylib_deps(rtbinary, rtbinname)\n\n            import PyInstaller.utils.osx as osxutils\n            # Since PyInstaller 4.4\n            if hasattr(osxutils, 'sign_binary'):\n                logger.info('re-signing \"%s\"', os.path.basename(rtbinary))\n                osxutils.sign_binary(rtbinary, identity=codesign)\n\n        rtentry = (rtbinname, rtbinary, 1, 'b') if self.one_file_mode else None\n        if not self.one_file_mode:\n            dest = os.path.join(os.path.dirname(executable), rtname)\n            os.makedirs(dest, exist_ok=True)\n            shutil.copy2(rtbinary, dest)\n\n        repack_executable(executable, buildpath, obfpath, rtentry, codesign)\n\n    def _fixup_darwin_rtbinary(self, rtbinary, pylib_name):\n        '''Unused since Pyarmor 8.3.0'''\n        from sys import version_info as pyver\n        pylib = os.path.normpath(os.path.join('@rpath', pylib_name))\n        output = check_output(['otool', '-L', rtbinary])\n        for line in output.splitlines():\n            if line.find(b'libpython%d.%d.dylib' % pyver[:2]) > 0:\n                reflib = line.split()[0].decode()\n                if reflib.endswith(pylib_name):\n                    return\n                break\n            elif line.find(pylib.encode()) > 0:\n                return\n            # Only for debug\n            elif line.find(b'/Python ') > 0:\n                return\n        else:\n            logger.warning('fixup dylib failed, no CPython library found')\n\n        cmdlist = ['install_name_tool', '-change', reflib, pylib, rtbinary]\n        try:\n            logger.info('%s', ' '.join(cmdlist))\n            check_call(cmdlist, stdout=DEVNULL, stderr=DEVNULL)\n        except Exception as e:\n            logger.warning('%s', e)\n\n\nFile: pyarmor/cli/docker.py\nimport argparse\nimport logging\nimport os\nimport socketserver\nimport struct\nimport sys\n\nfrom .context import Context\nfrom .generate import Pytransform3\nfrom .register import Register, MACHFLAGS\n\n\nCONFIG = {\n    'port': 29092,\n    'home': os.path.expanduser(os.path.join('~', '.pyarmor', 'docker')),\n    'machid': None,\n    'ctx': None,\n}\n\n\nclass DockerAuthHandler(socketserver.BaseRequestHandler):\n\n    def handle(self):\n        data = self.request.recv(64)\n        logging.info('receive request from %s', self.client_address)\n        try:\n            logging.debug('request data (%d): %s', len(data), data)\n            response = self.process(data)\n            logging.info('send auth result to %s', self.client_address)\n            logging.debug('response data (%d): %s', len(response), response)\n        except Exception as e:\n            logging.error('%s', str(e))\n            msg = 'verification failed, please check host console'.encode()\n            msg += b'\\00'\n            self.request.send(struct.pack('!HH', 1, len(msg)) + msg)\n\n    def process(self, packet):\n        if packet[:4] == b'PADH':\n            response = b'\\n'.join(CONFIG['machid']) + b'\\x00'\n            self.request.send(response)\n        else:\n            userdata = self.parse_packet(packet)\n            keydata = self.generate_runtime_key(userdata.decode('utf-8'))\n            response = struct.pack('!HH', 0, len(keydata)) + keydata\n            self.request.send(response)\n        return response\n\n    def parse_packet(self, packet):\n        if len(packet) == 32 and packet[:4] == b'PADK':\n            return packet[12:]\n        raise RuntimeError('invalid auth request')\n\n    def generate_runtime_key(self, userdata):\n        ctx = CONFIG['ctx']\n        ctx.cmd_options['user_data'] = userdata\n        Pytransform3._pytransform3.init_ctx(ctx)\n        return Pytransform3.generate_runtime_key(ctx)\n\n\ndef register_pyarmor(ctx, regfile):\n    reg = Register(ctx)\n    logging.info('register \"%s\"', regfile)\n    reg.register_regfile(regfile)\n    if reg.license_info['features'] < 15:\n        raise RuntimeError('this feature is only for group license')\n    Pytransform3.init(ctx)\n\n\ndef main_entry():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-d', '--debug', action='store_true',\n                        help='Enable debug mode')\n    parser.add_argument('-p', '--port', type=int, default=CONFIG['port'],\n                        help=argparse.SUPPRESS)\n    parser.add_argument('-s', '--sock', default='/var/run/docker.sock',\n                        help=argparse.SUPPRESS)\n    parser.add_argument('--home', help=argparse.SUPPRESS)\n    parser.add_argument('regfile', nargs=1,\n                        help='group device registration file for this machine')\n    args = parser.parse_args(sys.argv[1:])\n\n    if args.debug:\n        logging.getLogger().setLevel(logging.DEBUG)\n\n    if args.home:\n        CONFIG['home'] = os.path.expandvars(os.path.expanduser(args.home))\n    home = CONFIG['home']\n    logging.info('work path: %s', home)\n\n    ctx = Context(home=home)\n    register_pyarmor(ctx, args.regfile[0])\n    CONFIG['ctx'] = ctx\n\n    CONFIG['machid'] = [Pytransform3.get_hd_info(x) for x in MACHFLAGS]\n    logging.debug('machine id: %s', CONFIG['machid'])\n\n    host, port = '0.0.0.0', args.port\n    with socketserver.TCPServer((host, port), DockerAuthHandler) as server:\n        logging.info('listen container auth request on %s:%s', host, args.port)\n        server.serve_forever()\n\n\ndef main():\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(asctime)s: %(message)s',\n    )\n    main_entry()\n\n\n#\n# Deprecrated functions\n#\ndef get_docker_gateway(client):\n    filters = {\n        'driver': 'bridge',\n        'type': 'builtin'\n    }\n    networks = client.networks.list(filters=filters)\n    return networks[0].attrs['IPAM']['Config'][0]['Gateway']\n\n\ndef get_container(client, ipaddr):\n    filters = {\n        'driver': 'bridge',\n        'type': 'builtin'\n    }\n    networks = client.networks.list(filters=filters, greedy=True)\n    containers = networks[0].attrs.get('Containers')\n    if containers:\n        marker = ipaddr + '/'\n        for dockid, netattr in containers.items():\n            if netattr.get('IPv4Address').startswith(marker):\n                return client.containers.get(dockid)\n    raise RuntimeError('no found countainer with IPv4 %s' % ipaddr)\n\n\ndef copy_file_into_docker(containerid, filename):\n    from subprocess import check_call\n    check_call(['docker', 'cp', filename, '%s:/' % containerid])\n\n\ndef get_container_info(client, shortid):\n    container = client.container.get(shortid)\n    return container.attrs\n\n\nif __name__ == '__main__':\n    main()\n\n\nFile: pyarmor/cli/generate.py\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#############################################################\n#                                                           #\n#      Copyright @ 2023 -  Dashingsoft corp.                #\n#      All rights reserved.                                 #\n#                                                           #\n#      Pyarmor                                              #\n#                                                           #\n#      Version: 8.0.1 -                                     #\n#                                                           #\n#############################################################\n#\n#\n#  @File: cli/generate.py\n#\n#  @Author: Jondy Zhao (pyarmor@163.com)\n#\n#  @Create Date: 2022-12-06\n#\nimport os\nimport shutil\n\nfrom . import logger, CliError\nfrom .core import Pytransform3\nfrom .resource import FileResource, PathResource\n\n\nclass Finder(object):\n\n    def __init__(self, ctx):\n        self.ctx = ctx\n\n    def _build_resource(self, pathlist):\n        resources = []\n        for path in pathlist:\n            if not os.path.exists(path):\n                raise CliError('argument \"%s\" doesn\\'t exists' % path)\n            if os.path.isfile(path):\n                logger.info('find script %s', path)\n                res = FileResource(path)\n                resources.append(res)\n            else:\n                logger.info('find package at %s', path)\n                res = PathResource(path)\n                resources.append(res)\n                options = self.ctx.get_res_options(res.fullname)\n                res.rebuild(**options)\n        return resources\n\n    def prepare(self, input_paths):\n        self.ctx.resources = self._build_resource(input_paths)\n\n    def process_extra(self, contents):\n        extra_paths = [x for x in contents if x.endswith('.pyc')]\n        for pyz in [x for x in contents if x.endswith('.pyz_extracted')]:\n            extra_paths.extend([os.path.join(pyz, x) for x in os.listdir(pyz)])\n        resnames = [x.pkgname for x in self.ctx.resources]\n        for res in self._build_resource(extra_paths):\n            if res.pkgname not in resnames:\n                self.ctx.obfuscated_modules.add(res.pkgname)\n                self.ctx.extra_resources.append(res)\n\n    def process(self):\n        logger.info('search inputs ...')\n        self.prepare(self.ctx.input_paths)\n        logger.info('find %d top resources', len(self.ctx.resources))\n\n        modules = [x.fullname for res in self.ctx.resources for x in res\n                   if x.is_script()]\n        self.ctx.obfuscated_modules.update(modules)\n\n\nclass Builder(object):\n\n    def __init__(self, ctx):\n        self.ctx = ctx\n\n    def format_output(self, outputs, count=0):\n        try:\n            output = outputs[count]\n        except IndexError:\n            output = self.ctx.alias_suffix.format(outputs[0], count)\n        return output\n\n    def generate_runtime_key(self, outer=None):\n        return Pytransform3.generate_runtime_key(self.ctx, outer)\n\n    def generate_runtime_package(self, output):\n        if self.ctx.runtime_key is None:\n            self.ctx.runtime_key = self.generate_runtime_key()\n        Pytransform3.generate_runtime_package(self.ctx, output)\n\n    def _obfuscate_scripts(self):\n        rev = self.ctx.version_info()\n        template = self.ctx.bootstrap_template\n        relative = self.ctx.import_prefix\n        pkgname = self.ctx.runtime_package_name\n        bootpath = self.ctx.cfg.get('builder', 'bootstrap_file')\n\n        namelist = []\n        for res in self.ctx.resources + self.ctx.extra_resources:\n            logger.info('process resource \"%s\"', res.fullname)\n            name = res.name\n            path = self.format_output(self.ctx.outputs, namelist.count(name))\n            namelist.append(name)\n            os.makedirs(path, exist_ok=True)\n\n            for r in res:\n                if not r.is_script():\n                    logger.info('copy data file %s', r.fullpath)\n                    data_path = os.path.join(path, r.output_path)\n                    os.makedirs(data_path, exist_ok=True)\n                    shutil.copy2(r.fullpath, data_path)\n                    continue\n\n                logger.info('obfuscating %s', r)\n                code = Pytransform3.generate_obfuscated_script(self.ctx, r)\n                source = r.generate_output(\n                    template, code, relative=relative, pkgname=pkgname,\n                    bootpath=bootpath, rev=rev\n                )\n\n                fullpath = os.path.join(path, r.output_filename)\n                os.makedirs(os.path.dirname(fullpath), exist_ok=True)\n\n                logger.info('write %s', fullpath)\n                with open(fullpath, 'w') as f:\n                    f.write(source)\n\n    def process(self, options, packer=None):\n        for opt in options['inputs']:\n            if not os.path.exists(opt):\n                raise CliError('no found input \"%s\"' % opt)\n        self.ctx.input_paths = options['inputs']\n\n        output = options.get('output', 'dist')\n        self.ctx.outputs = output.split(',')\n\n        finder = Finder(self.ctx)\n        finder.process()\n\n        if packer and options.get('self_contained'):\n            finder.process_extra(packer.contents)\n\n        Pytransform3.pre_build(self.ctx)\n\n        self.ctx.runtime_key = self.generate_runtime_key()\n        if not options.get('no_runtime'):\n            logger.info('start to generate runtime files')\n            self.generate_runtime_package(self.ctx.outputs[0])\n            logger.info('generate runtime files OK')\n\n        logger.info('start to obfuscate scripts')\n        self._obfuscate_scripts()\n        logger.info('obfuscate scripts OK')\n\n        Pytransform3.post_build(self.ctx)\n\n        if packer:\n            packer.repack(output, self.ctx.runtime_package_name)\n\n\nFile: pyarmor/cli/default.cfg\n[pyarmor]\n\n;; Pyarmor version\nmajor = 8\nminor = 4\npatch = 2\n\n;; Compatible core version\ncli.core = 5.4.0\n\n;; Deprecated since Pyarmor 8.2.5\n; cli.runtime = 3.2.5\n\n;; Default timeout when send request to remote server for\n;;     check Pyarmor license\n;;     register Pyarmor license\ntimeout = 6\n\nregurl = https://api.dashingsoft.com/product/key/enter/%s/?\nbuyurl = https://order.mycommerce.com/product?vendorid=200089125&productid=301044051\n\n[logging]\n\ndebug_logfile = .pyarmor/pyarmor.debug.log\ntrace_logfile = .pyarmor/pyarmor.trace.log\n\n[finder]\nrecursive = 0\n;; includes =\nexcludes = */__pycache__\npyexts = .py .pyw\n\n;; Data files need to copy to output path\n;;   *.txt only copy .txt file\n;;   * means all data files\n;;   0 means nothing to copy\ndata_files = 0\n\n;;\n;; How to find dependent packages\n;;\nfindall = 0\n\n[builder]\n;;\n;; Part 1: only global/local settings, not in module level\n;;\n\n;; File encoding to read scripts\nencoding = utf-8\n\n;; Trace obfuscation\nenable_trace = 0\n\n;; Use Themida to protect runtime package in windows\nenable_themida = 0\n\n;; Import prefix to import runtime package\nimport_prefix = 0\n\n;; Sometimes __file__ is not defined, replace it with __name__ to fix this issue\nbootstrap_file = __file__\n\n;; Exclude co objects by co_name\nexclude_co_names = <lambda> <listcomp> <setcomp> <dictcomp> <genexpr>\n\n;; Common modules which are no restrict\nexclude_restrict_modules = __init__\n\n;; Outer key name\nouter_keyname = pyarmor.rkey\n\n;; The final marker is \"# %s: \" % VALUE\n;; If VALUE == \"false\", then disable inline plugin\ninline_plugin_marker = pyarmor\n\n;; Default plugins\nplugins = CodesignPlugin DarwinUniversalPlugin\n\n;; Using shared runtime package\n; use_runtime = /path/to/runtime\n\n;; How many loops for jit iv\njit_iv_threshold = 100\n\n;; Now \"argument\" is not available\nrft_enables = builtin import function class method global local\n\n;; Exclude unknown attrs automically\n;    0     disable auto exclude, use auto include\n;    1     auto exclude and load .pyarmor/rft/exclude_table\n;    2     auto exclude but not load exclude_table\nrft_auto_exclude = 1\n\n;; Export all the names in module attribute __all__\nrft_auto_export = 1\n\n;; Enable dev mode for rft\nrft_dev_mode = 0\n\n;; Export module and classes\n; rft_export_names = pkg.mod pkg.mod.cls pkg.mod.attr\n\n;; Extra paths to find dependent package\n; pypaths =\n\n;; List module names couldn't be found automically\n; hidden_imports =\n\n;; If it's enabled, disable some features to make scripts work with nuitka\n;; convenient settings for nuitka, but now it's TBD\n; support_nuitka = 0\n\n;; Group device flag for machine id\ngroup_device_flag = 22\n\n;;\n;; Part 2: global/local/module level options\n;;\n\n;; The argument optimize specifies the optimization level of the\n;; compiler; the default value of -1 selects the optimization level of\n;; the interpreter as given by -O options. Explicit levels are 0 (no\n;; optimization; __debug__ is true), 1 (asserts are removed, __debug__\n;; is false) or 2 (docstrings are removed too).\noptimize = -1\n\n;; It's not used now\ntype_comments = false\n\n;; Write refactor result scripts\ntrace_rft = 0\n\nenable_jit = 0\nenable_bcc = 0\nenable_rft = 0\n\n;; assert: call import\nassert_call = 0\nassert_import = 0\n\n;; mix string constant\nmix_str = 0\n\n;; hide function name in traceback\n;;   1: hide function.__name__\n;;   2: also hide function.__qualname__ (not implemented)\nmix_coname = 0\n\n;; mix local variables\nmix_localnames = 1\n\n;; mix argument names, it also clears annotations\nmix_argnames = 0\n\nobf_module = 1\nobf_code = 1\n\n;; 0: no wrap mode\n;; 1: simple wrap mode\n;; 2: full wrap mode\n;; Since Python 3.12, \"2\" is same as \"1\", both of them use full wrap mode\nwrap_mode = 1\n\nrestrict_module = 1\n\n;;\n;; Advanced features\n;;\n\n;; check license when importing each module\nimport_check_license = 0\n\n;; clear module co after importing\nclear_module_co = 1\n\n;; clear frame.f_locals for wrap mode, it's meanless for non-wrap mode\nclear_frame_locals = 0\n\n;; Model level to rename attributes ruler\n;;\n;;    x.y.z:?.%.z\n;;\n;;    ?  auto map\n;;    %  force rename\n;;\n; rft_rulers =\n\n;; Model level to exclude names\n; rft_excludes =\n\n;; Whether encrypt name in statement import\nrft_mix_import_name = 0\n\n[runtime]\n\n;; Generate extension for all Python3.7+\nuniversal = 0\n\n;; Default runtime package name\npackage_name_format = pyarmor_runtime_{suffix}\n\n;; The file ext only keep .so/.pyd, for example\n;;     pyarmor_runtime.cpython-37m-darwin.so\n;;     if simple_extension_name == 1 then\n;;     pyarmor_runtime.so\nsimple_extension_name = 1\n\n;; Enable outer runtime key\nouter = 0\n\n;; Pyarmor raises PyExc_RuntimeError by default\n;;     0    raise PyExc_RuntimeError\n;;     1    raise PyExc_SystemExit\n;;     2    call libc exit to quit directly\non_error = 0\n\n;; Check runtime key periodically, support formats:\n;;   3600s\n;;   60m\n;;   1h\n;;   1\n; period = 1\n\n;; Expired runtime key. Check local time if there is leading '.',\n;; otherwise check ntp time\n;;\n;;     30\n;;     2025-12-31\n;;\n;;     .30\n;;     .2025-12-30\n;;\n; expired =\n\n;; Check ntp time by this server\nnts = pool.ntp.org\nnts_timeout = 3\n\n;; Bind runtime key to multiple devices, one line one machine\n; devices =\n\n;; Bind runtime key to Python interperter. Each line defines a rule,\n;; match all the rules. The rule formats\n;;\n;;      D\n;;      S: symbol start end xxxxxx(md5)\n;;\n; interps =\n\n;; Insert runtime hooks\n; hooks = hooks.py\n\n;; Enable timer\ntimer = 0\n\n;; Target platforms\n; platforms =\n\n;; If there are customized runtime messages\nmessages = messages.cfg:utf-8\n\n[assert.call]\n;; and: function is in obfuscated script and match ruler\n;;  or: function is in obfuscated script or match ruler\nauto_mode = and\n\n; includes =\n; excludes =\n\n[assert.import]\n;; and: module is obfuscated and match ruler\n;;  or: module is obfuscated or match ruler\nauto_mode = and\n\n; includes =\n; excludes =\n\n[mix.str]\n;; do not mix short string len(s) < this value\nthreshold = 8\n\n; includes =\n; excludes =\n\n[pack]\n;; For Darwin to code sign binary file\n; codesign_identify =\n\n;; Strip output path to match archive info\nstrip = 0\n\n;; How to do when the obfuscated module has no matched .pyc in bundle\n;;    error, issue a error and exit\n;;    warning, issue a warning and continue\n;;    ignore, do nothing\n;;    append, append it to archive\nno_matched_pyc = error\n\n[bcc]\nunsupported_functions = exec eval super locals __assert_armored__\nunsupported_nodes = AsyncFunctionDef AsyncFor AsyncWith Await Yield YieldFrom GeneratorExp NamedExpr MatchValue MatchSingleton MatchSequence MatchMapping MatchClass MatchStar MatchAs MatchOr\n\n;; Include and exclude function/method names\n; includes =\n; excludes =\n\n;; Use opcode CALL_FUNCTION_EX to patch call\n;; Global option, all scripts must be same\ncall_function_ex = 0\n\n;; Generate bcc function to show right lineno in traceback\n;; If disable, lineno is always function definition lineno\ntrace_lineno = 0\n\nkeep_nest_name = 0\n\n;; Do not convert lambda to bcc\nignore_lambda = 0\n\n;; Use op_mkfunc2 to build unsupported functions\nenable_pure_function = 1\n\n;; Convert comprehensions to bcc code\nenable_comprehension = 1\n\n[windows.x86_64.bcc]\ncc = clang.exe\ncflags = -O3 -Wno-unsequenced -fno-asynchronous-unwind-tables -fno-unwind-tables --target=x86_64-elf-windows -c\n\n[windows.x86.bcc]\ncc = clang.exe\ncflags = --target=i686-elf-linux -O3 -Wno-unsequenced -fno-asynchronous-unwind-tables -fno-unwind-tables -fno-stack-protector -fPIC -mno-sse -std=c99 -c\n\n[linux.x86_64.bcc]\ncflags = -O3 -Wno-unsequenced -fno-asynchronous-unwind-tables -fno-unwind-tables -fPIC -fno-stack-protector -c\n\n[linux.aarch64.bcc]\ncflags = -O3 -Wno-unsequenced -fno-asynchronous-unwind-tables -fno-unwind-tables -fPIC -fno-stack-protector -shared -nostdlib -DENABLE_BCC_MEMSET -Tlinux.aarch64.ldscript\n\n[linux.x86.bcc]\ncflags = -O3 -Wno-unsequenced -fno-asynchronous-unwind-tables -fno-unwind-tables -fno-stack-protector -fPIC -c\n\n[linux.armv7.bcc]\ncflags = -O3 -Wno-unsequenced -fno-asynchronous-unwind-tables -fno-unwind-tables -fno-stack-protector -shared -nostdlib -Tlinux.armv7.ldscript\n\n[darwin.x86_64.bcc]\ncflags = -O3 -Wno-unsequenced -fno-asynchronous-unwind-tables -fno-unwind-tables --target=x86_64-elf-gnu_linux -fPIC -c\n\n[darwin.aarch64.bcc]\ncflags = -O3 -Wno-unsequenced -fno-asynchronous-unwind-tables -fno-unwind-tables --target=arm64-macho-darwin -fPIC -fno-addrsig -fno-stack-protector -shared -nostdlib -lsystem\n\n[android.x86_64.bcc]\ncflags = -O3 -Wno-unsequenced -fno-asynchronous-unwind-tables -fno-unwind-tables -fPIC -fno-stack-protector -c\n\n[android.aarch64.bcc]\ncflags = -O3 -Wno-unsequenced -fno-asynchronous-unwind-tables -fno-unwind-tables -fPIC -fno-stack-protector -shared -nostdlib -DENABLE_BCC_MEMSET -Tlinux.aarch64.ldscript\n\n[android.x86.bcc]\ncflags = -O3 -Wno-unsequenced -fno-asynchronous-unwind-tables -fno-unwind-tables -fno-stack-protector -fPIC -c\n\n[android.armv7.bcc]\ncflags = -O3 -Wno-unsequenced -fno-asynchronous-unwind-tables -fno-unwind-tables -fno-stack-protector -shared -nostdlib -Tlinux.armv7.ldscript\n\n[alpine.x86_64.bcc]\ncflags = -O3 -Wno-unsequenced -fno-asynchronous-unwind-tables -fno-unwind-tables -fPIC -fno-stack-protector -c\n\n[alpine.aarch64.bcc]\ncflags = -O3 -Wno-unsequenced -fno-asynchronous-unwind-tables -fno-unwind-tables -fPIC -fno-stack-protector -shared -nostdlib -DENABLE_BCC_MEMSET -Tlinux.aarch64.ldscript\n\n[freebsd.x86_64.bcc]\ncflags = -O3 -Wno-unsequenced -fno-asynchronous-unwind-tables -fno-unwind-tables -fPIC -fno-stack-protector -c\n\n\nFile: pyarmor/cli/plugin.py\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#############################################################\n#                                                           #\n#      Copyright @ 2023 -  Dashingsoft corp.                #\n#      All rights reserved.                                 #\n#                                                           #\n#      Pyarmor                                              #\n#                                                           #\n#      Version: 8.0.1 -                                     #\n#                                                           #\n#############################################################\n#\n#\n#  @File: cli/plugin.py\n#\n#  @Author: Jondy Zhao (pyarmor@163.com)\n#\n#  @Create Date: Fri Apr 21 18:42:14 CST 2023\n#\nimport os\n\nfrom importlib.util import spec_from_file_location, module_from_spec\n\nfrom . import logger\n\n\n__all__ = ['CodesignPlugin', 'MultiPythonPlugin', 'PlatformTagPlugin',\n           'PycPlugin', 'DarwinUniversalPlugin']\n\n\nclass Plugin(object):\n\n    def __init__(self, ctx=None):\n        self.ctx = ctx\n\n    @staticmethod\n    def install(ctx, pkg='pyarmor.cli.plugin'):\n        ctx.Plugin = Plugin\n\n        for pname in ctx.cfg['builder'].get('plugins', '').split():\n            if pname in __all__:\n                logger.debug('install plugin: %s', pname)\n                ctx.plugins.append(globals().get(pname))\n                continue\n\n            for x in '', ctx.local_path, ctx.global_path:\n                path = os.path.join(x, pname + '.py')\n                if os.path.exists(path):\n                    logger.debug('plugin script \"%s\"', path)\n                    break\n            else:\n                logger.warning('no plugin \"%s\" found', pname)\n                continue\n\n            spec = spec_from_file_location(pkg + '.' + pname, path)\n            module = module_from_spec(spec)\n            spec.loader.exec_module(module)\n\n            names = getattr(module, '__all__', [])\n            logger.debug('install plugins: %s', ' '.join(names))\n            ctx.plugins.extend([getattr(module, x, None) for x in names])\n\n    @staticmethod\n    def post_build(ctx, pack=None):\n        inputs = ctx.input_paths\n        outputs = ctx.outputs\n        for plugin in [x for x in ctx.plugins if hasattr(x, 'post_build')]:\n            logger.debug('call post build plugin %s', plugin)\n            plugin.post_build(ctx, inputs, outputs, pack=pack)\n\n    @staticmethod\n    def post_key(ctx, keyfile):\n        kwargs = {\n            'expired': ctx.runtime_expired,\n            'devices': ctx.runtime_devices,\n            'period': ctx.runtime_period,\n            'data': ctx.cmd_options.get('user_data')\n        }\n        for plugin in [x for x in ctx.plugins if hasattr(x, 'post_key')]:\n            logger.debug('call post key plugin %s', plugin)\n            plugin.post_key(ctx, keyfile, **kwargs)\n\n    @staticmethod\n    def post_runtime(ctx, source, dest, platform):\n        for plugin in [x for x in ctx.plugins if hasattr(x, 'post_runtime')]:\n            logger.debug('call post runtime plugin %s', plugin)\n            plugin.post_runtime(ctx, source, dest, platform)\n\n    @staticmethod\n    def post_bcc(ctx, res, csource):\n        for plugin in [x for x in ctx.plugins if hasattr(x, 'post_bcc')]:\n            patched_csource = plugin.post_bcc(ctx, res, csource)\n            if patched_csource:\n                csource = patched_csource\n        return csource\n\n\nclass PycPlugin:\n    '''Change all obfuscated scripts name entension from \".pyc\" to \".py\"'''\n\n    @staticmethod\n    def post_build(ctx, inputs, outputs, pack):\n        for path, dirnames, filenames in os.walk(outputs[0]):\n            for x in filenames:\n                if x.endswith('.pyc'):\n                    pycname = os.path.join(path, x)\n                    os.replace(pycname, pycname[:-1])\n\n\ndef osx_sign_binary(dest, identity=None):\n    from subprocess import check_call, CalledProcessError, DEVNULL\n    cmdlist = ['codesign', '-f', '-s', identity,\n               '--all-architectures', '--timestamp', dest]\n    logger.debug('%s', ' '.join(cmdlist))\n    try:\n        check_call(cmdlist, stdout=DEVNULL, stderr=DEVNULL)\n    except CalledProcessError as e:\n        logger.warning('codesign command failed with error code %d',\n                       e.returncode)\n    except Exception as e:\n        logger.warning('codesign command failed with:\\n%s', e)\n\n\nclass CodesignPlugin:\n    '''codesign darwin runtime extension \"pyarmor_runtime\"'''\n\n    @staticmethod\n    def post_runtime(ctx, source, dest, platform):\n        if platform.startswith('darwin'):\n            identity = ctx.cfg['pack'].get('codesign_identify', '-')\n            osx_sign_binary(dest, identity)\n\n\nclass PlatformTagPlugin:\n    '''Rename runtime extension \"pyarmor_runtime\" with platform tag.'''\n\n    @staticmethod\n    def post_runtime(ctx, source, dest, platform):\n        pyver = '%s%s' % ctx.python_version[:2]\n        if platform.startswith('windows.'):\n            tag = 'cp%s' % pyver\n            tagname = '.'.join(['pyarmor_runtime', tag, 'pyd'])\n            logger.info('rename \"%s\" to \"%s\"', dest, tagname)\n            os.rename(dest, dest.replace('pyarmor_runtime.pyd', tagname))\n        elif platform.startswith('darwin.'):\n            tag = 'cpython-%s-darwin' % pyver\n            tagname = '.'.join(['pyarmor_runtime', tag, 'so'])\n            logger.info('rename \"%s\" to \"%s\"', dest, tagname)\n            os.rename(dest, dest.replace('pyarmor_runtime.so', tagname))\n        elif platform.startswith('linux.'):\n            arch = platform.split('.')[1]\n            tag = 'cpython-%s-%s-linux-gnu' % (pyver, arch)\n            tagname = '.'.join(['pyarmor_runtime', tag, 'so'])\n            logger.info('rename \"%s\" to \"%s\"', dest, tagname)\n            os.rename(dest, dest.replace('pyarmor_runtime.so', tagname))\n        else:\n            raise RuntimeError('PlatformTagPlugin unknown \"%s\"' % platform)\n\n\nclass MultiPythonPlugin:\n    '''Refine runtime package to support multiple python versions'''\n\n    RUNTIME_PATH = None\n    RUNTIME_FILES = []\n\n    @staticmethod\n    def post_runtime(ctx, source, dest, platform):\n        MultiPythonPlugin.RUNTIME_PATH = os.path.dirname(dest)\n        MultiPythonPlugin.RUNTIME_FILES.append(dest)\n\n    @staticmethod\n    def post_build(ctx, inputs, outputs, pack):\n        '''Rewrite runtime package __init__.py'''\n        from shutil import move, rmtree\n        pyver = 'py%s%s' % ctx.python_version[:2]\n        platforms = ctx.target_platforms\n\n        oneplat = len(platforms) == 1\n        pkgpath = MultiPythonPlugin.RUNTIME_PATH if oneplat else \\\n            os.path.dirname(MultiPythonPlugin.RUNTIME_PATH)\n        verpath = os.path.join(pkgpath, pyver)\n        if os.path.exists(verpath):\n            rmtree(verpath)\n        os.makedirs(verpath)\n\n        pkgscript = os.path.join(pkgpath, '__init__.py')\n        with open(pkgscript) as f:\n            lines = f.readlines()\n        start = 1 if lines[0].startswith('#') else 0\n\n        if oneplat:\n            lines[start:] = '\\n'.join([\n                'from sys import version_info as py_version',\n                '{0} = __import__(\"py%d%d.pyarmor_runtime\" % py_version[:2],'\n                ' globals(), locals(), [\"{0}\"], 1).{0}'.format('__pyarmor__')\n            ])\n            with open(pkgscript, 'w') as f:\n                f.write(''.join(lines))\n            for x in MultiPythonPlugin.RUNTIME_FILES:\n                move(x, verpath)\n        else:\n            lines[start:start] = 'from sys import version_info as py_version\\n'\n            with open(pkgscript, 'w') as f:\n                f.write(''.join(lines).replace(\n                    \"join(['_'\", \"join(['py%d%d' % py_version[:2], '_'\"))\n            for x in MultiPythonPlugin.RUNTIME_FILES:\n                move(os.path.dirname(x), verpath)\n\n        MultiPythonPlugin.RUNTIME_FILES.clear()\n\n\ndef osx_merge_binary(target, rtpath, plats):\n    from subprocess import check_call, CalledProcessError, DEVNULL\n    cmdlist = ['lipo', '-create', '-output', target]\n    for plat in plats:\n        filename = os.path.join(rtpath, plat, 'pyarmor_runtime.so')\n        arch = 'x86_64' if plat == 'darwin_x86_64' else 'arm64'\n        cmdlist.extend(['-arch', arch, filename])\n    try:\n        check_call(cmdlist, stdout=DEVNULL, stderr=DEVNULL)\n        return True\n    except CalledProcessError as e:\n        logger.warning('lipo command \"%s\" failed with error code %d',\n                       ' '.join(cmdlist), e.returncode)\n    except Exception as e:\n        logger.warning('lipo command \"%s\" failed with:\\n%s',\n                       ' '.join(cmdlist), e)\n\n\ndef find_runtime_package(ctx, output):\n    prefix = ctx.import_prefix\n    rtname = ctx.runtime_package_name\n    if not prefix:\n        return os.path.join(output, rtname)\n    if isinstance(prefix, str):\n        return os.path.join(output, prefix.replace('.', os.path.sep), rtname)\n    for entry in os.scandir(output):\n        if entry.is_dir():\n            if rtname in os.listdir(entry.path):\n                return os.path.join(entry.path, rtname)\n\n\nclass DarwinUniversalPlugin:\n\n    @staticmethod\n    def post_build(ctx, inputs, outputs, pack):\n        from shutil import rmtree\n\n        def rebuild_init(oneplat, init_script):\n            with open(init_script, 'r') as f:\n                lines = f.readlines()\n            if oneplat:\n                lines[1:] = ['from .pyarmor_runtime import __pyarmor__']\n            else:\n                for i in range(1, len(lines)):\n                    if lines[i].strip().startswith(\"# mach = 'universal'\"):\n                        lines[i] = lines[i].replace('# ', '')\n                        break\n            with open(init_script, 'w') as f:\n                f.write(''.join(lines))\n\n        rtpath = find_runtime_package(ctx, outputs[0])\n        if rtpath is None or not os.path.exists(rtpath):\n            logger.debug('no found runtime package \"%s\"', rtpath)\n            return\n        dirs = [x.name for x in os.scandir(rtpath) if x.is_dir()]\n        plats = set(['darwin_x86_64', 'darwin_arm64', 'darwin_aarch64'])\n        plats = plats.intersection(set(dirs))\n        if len(plats) > 1:\n            oneplat = all([x.startswith('darwin_') for x in dirs])\n            if oneplat:\n                target = rtpath\n            else:\n                target = os.path.join(rtpath, 'darwin_universal')\n                os.makedirs(target, exist_ok=True)\n            target = os.path.join(target, 'pyarmor_runtime.so')\n\n            if not osx_merge_binary(target, rtpath, plats):\n                return\n\n            rebuild_init(oneplat, os.path.join(rtpath, '__init__.py'))\n            identity = ctx.cfg['pack'].get('codesign_identify', '-')\n            osx_sign_binary(target, identity)\n\n            # Clean old files\n            [rmtree(os.path.join(rtpath, x)) for x in plats]\n\n\nFile: pyarmor/cli/context.py\n#! /usr/bin/env python\n# -*- coding: utf-8 -*-\n#\n#############################################################\n#                                                           #\n#      Copyright @ 2023 -  Dashingsoft corp.                #\n#      All rights reserved.                                 #\n#                                                           #\n#      Pyarmor                                              #\n#                                                           #\n#      Version: 8.0.1 -                                     #\n#                                                           #\n#############################################################\n#\n#\n#  @File: cli/context.py\n#\n#  @Author: Jondy Zhao (pyarmor@163.com)\n#\n#  @Create Date: 2022-12-06\n#\nimport configparser\nimport os\nimport sys\n\nbootstrap_template = '''# Pyarmor $rev, $timestamp\nfrom $package import __pyarmor__\n__pyarmor__(__name__, $path, $code)\n'''\n\nruntime_package_template = '''# Pyarmor $rev, $timestamp\nfrom .pyarmor_runtime import __pyarmor__\n'''\n\nmulti_runtime_package_template = '''# Pyarmor $rev, $timestamp\ndef __pyarmor__():\n    import platform\n    import sys\n    from struct import calcsize\n\n    def format_system():\n        plat = platform.system().lower()\n        plat = ('windows' if plat.startswith('cygwin') else\n                'linux' if plat.startswith('linux') else\n                'freebsd' if plat.startswith(\n                    ('freebsd', 'openbsd', 'isilon onefs')) else plat)\n        if plat == 'linux':\n            if hasattr(sys, 'getandroidapilevel'):\n                plat = 'android'\n            else:\n                cname, cver = platform.libc_ver()\n                if cname == 'musl':\n                    plat = 'alpine'\n                elif cname == 'libc':\n                    plat = 'android'\n        return plat\n\n    def format_machine():\n        mach = platform.machine().lower()\n        arch_table = (\n            ('x86', ('i386', 'i486', 'i586', 'i686')),\n            ('x86_64', ('x64', 'x86_64', 'amd64', 'intel')),\n            ('arm', ('armv5',)),\n            ('armv6', ('armv6l',)),\n            ('armv7', ('armv7l',)),\n            ('aarch32', ('aarch32',)),\n            ('aarch64', ('aarch64', 'arm64'))\n        )\n        for alias, archlist in arch_table:\n            if mach in archlist:\n                mach = alias\n                break\n        return mach\n\n    plat, mach = format_system(), format_machine()\n    if plat == 'windows' and mach == 'x86_64':\n        bitness = calcsize('P'.encode()) * 8\n        if bitness == 32:\n            mach = 'x86'\n    # mach = 'universal' if plat == 'darwin' else mach\n    name = '.'.join(['_'.join([plat, mach]), 'pyarmor_runtime'])\n    return __import__(name, globals(), locals(), ['__pyarmor__'], level=1)\n__pyarmor__ = __pyarmor__().__pyarmor__\n'''\n\nruntime_package_template3 = '''# Pyarmor $rev, $timestamp\nfrom importlib.machinery import ExtensionFileLoader\nfrom sysconfig import get_platform\n__pyarmor__ = ExtensionFileLoader(\n    '.pyarmor_runtime', __file__.replace('__init__.py', 'pyarmor_runtime.so')\n).load_module().__pyarmor__\n'''\n\n\ndef format_platform(plat, arch):\n    from struct import calcsize\n    from fnmatch import fnmatchcase\n\n    plat_table = (\n        ('windows', ('windows', 'cygwin*')),\n        ('darwin', ('darwin',)),\n        ('linux', ('linux*',)),\n    )\n\n    arch_table = (\n        ('x86', ('i?86', )),\n        ('x86_64', ('x64', 'x86_64', 'amd64', 'intel')),\n        ('arm', ('armv5',)),\n        ('armv6', ('armv6l',)),\n        ('armv7', ('armv7l',)),\n        ('aarch32', ('aarch32',)),\n        ('aarch64', ('aarch64', 'arm64'))\n    )\n\n    for alias, platlist in plat_table:\n        if any([fnmatchcase(plat, x) for x in platlist]):\n            plat = alias\n            break\n\n    for alias, archlist in arch_table:\n        if any([fnmatchcase(arch, x) for x in archlist]):\n            mach = alias\n            break\n    else:\n        raise RuntimeError('unsupported arch \"%s\"' % arch)\n\n    if plat == 'windows' and mach == 'x86_64':\n        bitness = calcsize('P'.encode()) * 8\n        if bitness == 32:\n            mach = 'x86'\n\n    return '.'.join([plat, mach])\n\n\nclass Context(object):\n\n    def __init__(self, home, gpath='', lpath='', rpath='', encoding=None):\n        self.home_path = os.path.normpath(home)\n        self.global_path = os.path.join(home, gpath if gpath else 'config')\n        self.local_path = lpath if lpath else '.pyarmor'\n        self.reg_path = self.home_path if not rpath else \\\n            rpath if os.path.isabs(rpath) else \\\n            os.path.join(self.home_path, rpath)\n\n        # self.encoding is just for reading config file\n        self.encoding = encoding\n        cfglist = self.default_config, self.global_config, self.local_config\n        self.cfg = self._read_config(cfglist, encoding=encoding)\n\n        # self.runtime_package = 'pyarmor_runtime'\n        # self.runtime_suffix = '_000000'\n        # default inner key filename within runtime package\n        self.runtime_keyfile = '.pyarmor.ikey'\n\n        self.bootstrap_template = bootstrap_template\n\n        # Alias format for duplicated input names\n        self.alias_suffix = '{0}-{1}'\n\n        self.input_paths = []\n        self.outputs = []\n        self.resources = []\n        self.extra_resources = []\n\n        self.module_relations = {}\n        self.module_types = {}\n        self.variable_types = {}\n        self.module_builtins = set()\n\n        self.obfuscated_modules = set()\n        self.extra_libs = {}\n\n        self.rft_auto_excludes = set(['super'])\n        self.rft_export_names = set()\n        self.rft_transform_op = '?'\n\n        self.runtime_key = None\n\n        self.cmd_options = {}\n        self.plugins = []\n\n    def _read_config(self, filelist, encoding=None):\n        cfg = configparser.ConfigParser(\n            empty_lines_in_values=False,\n            interpolation=configparser.ExtendedInterpolation(),\n        )\n        cfg.read(filelist, encoding=encoding)\n        return cfg\n\n    def _named_config(self, name, encoding=None):\n        flist = [os.path.join(x, name)\n                 for x in (self.global_path, self.local_path)]\n        return self._read_config(flist, encoding=encoding)\n\n    def read_token(self):\n        if os.path.exists(self.license_token):\n            with open(self.license_token, 'rb') as f:\n                return f.read()\n\n    def save_token(self, data):\n        with open(self.license_token, 'wb') as f:\n            f.write(data)\n\n    def clear_token(self):\n        if os.path.exists(self.license_token):\n            with open(self.license_token, 'wb') as f:\n                f.close()\n\n    def group_device_file(self, devid):\n        filename = 'pyarmor-group-device.%s' % devid\n        return os.path.join(self.local_path, 'group', filename)\n\n    def read_license(self):\n        if os.path.exists(self.license_file):\n            with open(self.license_file, 'rb') as f:\n                return f.read()\n\n    def push(self, options):\n        finder = {}\n        for opt in ('recursive', 'findall', 'includes', 'excludes'):\n            if opt in options:\n                finder[opt] = options[opt]\n        if finder:\n            self.cmd_options['finder'] = finder\n        self.cmd_options.update(options)\n\n    def pop(self):\n        return self.cmd_options.clear()\n\n    def get_res_options(self, name, sect='finder'):\n        options = {}\n        if self.cfg.has_section(sect):\n            options.update(self.cfg.items(sect))\n        if sect == 'finder':\n            options.update(self.cmd_options.get('finder', {}))\n        elif sect == 'builder':\n            options.update(self.cmd_options)\n        extra_sect = ':'.join([name, sect])\n        if self.cfg.has_section(extra_sect):\n            options.update(self.cfg.items(extra_sect))\n        if name:\n            cfg = self._named_config(name + '.ruler')\n            if cfg.has_section(sect):\n                options.update(cfg.items(sect))\n        return options\n\n    def get_path(self, local=True):\n        return self.local_path if local else self.global_path\n\n    def get_filename(self, local=True, name=None):\n        return os.path.join(self.get_path(local), name + '.ruler') if name \\\n            else self.local_config if local else self.global_config\n\n    def version_info(self, verbose=3):\n        #    8.0.1\n        #    8.0.1 (trial)\n        #    8.0.1 (basic), 002000\n        #    8.0.1 (group), 002002, Product\n        #    8.0.1 (group), 002002, Product, Company\n        rev = '.'.join(self.version)\n        if not verbose:\n            return rev\n\n        licinfo = self.license_info\n        lictype = 'basic' if licinfo['features'] == 1 else \\\n            'pro' if licinfo['features'] == 7 else \\\n            'group' if licinfo['features'] == 15 else \\\n            'trial' if licinfo['token'] == 0 else 'unknown'\n        verinfo = ['%s (%s)' % (rev, lictype)]\n\n        if verbose > 1:\n            verinfo.append(licinfo['licno'][-6:])\n\n        if verbose > 2:\n            pname = licinfo['product']\n            verinfo.append(pname)\n\n        if verbose > 3:\n            regname = licinfo['regname']\n            if regname:\n                verinfo.append(regname)\n\n        return ', '.join(verinfo)\n\n    @property\n    def version(self):\n        return [self.cfg.get('pyarmor', x) for x in ('major', 'minor', 'patch')]\n\n    @property\n    def python_version(self):\n        return sys.version_info[:2]\n\n    @property\n    def default_config(self):\n        return os.path.join(os.path.dirname(__file__), 'default.cfg')\n\n    @property\n    def global_config(self):\n        return os.path.join(self.global_path, 'global')\n\n    @property\n    def local_config(self):\n        return os.path.join(self.local_path, 'config')\n\n    def _make_public_capsule(self, filename):\n        from shutil import copy\n        os.makedirs(os.path.dirname(filename), exist_ok=True)\n        path = os.path.dirname(__file__)\n        public_capsule = os.path.join(path, 'public_capsule.zip')\n        copy(public_capsule, filename)\n\n    @property\n    def private_capsule(self):\n        filename = os.path.join(self.reg_path, '.pyarmor_capsule.zip')\n        if not os.path.exists(filename):\n            self._make_public_capsule(filename)\n        return filename\n\n    @property\n    def license_file(self):\n        return os.path.join(self.reg_path, 'license.lic')\n\n    @property\n    def license_token(self):\n        return os.path.join(self.reg_path, '.license.token')\n\n    @property\n    def license_info(self):\n        from .register import parse_token\n        return parse_token(self.read_token())\n\n    @property\n    def native_platform(self):\n        from platform import system, machine\n        return '.'.join([system().lower(), machine().lower()])\n\n    @property\n    def pyarmor_platform(self):\n        platname = os.getenv('PYARMOR_PLATFORM', self.native_platform)\n        return format_platform(*platname.split('.'))\n\n    @property\n    def target_platforms(self):\n        platforms = self.cmd_options.get('platforms')\n        return platforms if platforms else [self.native_platform]\n\n    def _check_logpath(self, logfile):\n        path = os.path.dirname(logfile)\n        if path not in ('', '.') and not os.path.exists(path):\n            os.makedirs(path)\n        return logfile\n\n    @property\n    def debug_logfile(self):\n        return self._check_logpath(\n            self.cfg['logging'].get('debug_logfile', 'pyarmor.debug.log'))\n\n    @property\n    def trace_logfile(self):\n        return self._check_logpath(\n            self.cfg['logging'].get('trace_logfile', 'pyarmor.trace.log'))\n\n    @property\n    def repack_path(self):\n        return os.path.join(self.local_path, 'pack')\n\n    def _optb(self, section, name):\n        return self.cfg.getboolean(section, name, vars=self.cmd_options)\n\n    def _opts(self, section, name):\n        return self.cfg.get(section, name, vars=self.cmd_options)\n\n    def _opti(self, section, name):\n        return self.cfg.getint(section, name, vars=self.cmd_options)\n\n    @property\n    def recursive(self):\n        return self._optb('finder', 'recursive')\n\n    @property\n    def findall(self):\n        return self._optb('finder', 'findall')\n\n    @property\n    def pyexts(self):\n        return self._opts('finder', 'pyexts').split()\n\n    @property\n    def enable_themida(self):\n        return self._optb('builder', 'enable_themida')\n\n    @property\n    def enable_jit(self):\n        return self._optb('builder', 'enable_jit')\n\n    @property\n    def enable_bcc(self):\n        return self._optb('builder', 'enable_bcc')\n\n    @property\n    def enable_rft(self):\n        return self._optb('builder', 'enable_rft')\n\n    @property\n    def assert_call(self):\n        return self._optb('builder', 'assert_call')\n\n    @property\n    def assert_import(self):\n        return self._optb('builder', 'assert_import')\n\n    @property\n    def mix_coname(self):\n        return self._optb('builder', 'mix_coname')\n\n    @property\n    def mix_localnames(self):\n        return self._optb('builder', 'mix_localnames')\n\n    @property\n    def mix_argnames(self):\n        return self._optb('builder', 'mix_argnames')\n\n    @property\n    def mix_str(self):\n        return self._optb('builder', 'mix_str')\n\n    @property\n    def obf_module(self):\n        return self._opti('builder', 'obf_module')\n\n    @property\n    def obf_code(self):\n        return self._opti('builder', 'obf_code')\n\n    @property\n    def wrap_mode(self):\n        return self._optb('builder', 'wrap_mode')\n\n    @property\n    def restrict_module(self):\n        return self._opti('builder', 'restrict_module')\n\n    @property\n    def import_check_license(self):\n        return self._optb('builder', 'import_check_license')\n\n    @property\n    def clear_module_co(self):\n        return self._optb('builder', 'clear_module_co')\n\n    @property\n    def clear_frame_locals(self):\n        return self._optb('builder', 'clear_frame_locals')\n\n    @property\n    def import_prefix(self):\n        v = self._opts('builder', 'import_prefix')\n        return int(v) if v.isdecimal() else v\n\n    @property\n    def exclude_restrict_modules(self):\n        return self._opts('builder', 'exclude_restrict_modules')\n\n    @property\n    def co_threshold(self):\n        return self._opti('builder', 'co_threshold')\n\n    @property\n    def jit_iv_threshold(self):\n        return self._opti('builder', 'jit_iv_threshold')\n\n    @property\n    def exclude_co_names(self):\n        return self.cfg['builder'].get('exclude_co_names', '').split()\n\n    @property\n    def outer_keyname(self):\n        return self.cfg['builder'].get('outer_keyname', 'pyarmor.rkey')\n\n    @property\n    def use_runtime(self):\n        return self.cmd_options.get('use_runtime',\n                                    self.cfg['builder'].get('use_runtime'))\n\n    @property\n    def inline_plugin_marker(self):\n        marker = self.cfg['builder'].get('inline_plugin_marker', 'false')\n        if marker.lower() not in ('', 'false', '0'):\n            return '# %s: ' % marker\n\n    #\n    # runtime configuration\n    #\n    def _rt_opt(self, opt):\n        return self.cmd_options.get(opt, self.cfg['runtime'].get(opt))\n\n    @property\n    def runtime_suffix(self):\n        return self.license_info['licno'][-6:]\n\n    @property\n    def runtime_package_name(self):\n        fmt = self.cfg.get('runtime', 'package_name_format')\n        return fmt.format(suffix=self.runtime_suffix)\n\n    @property\n    def runtime_platforms(self):\n        return self._rt_opt('platforms')\n\n    @property\n    def runtime_on_error(self):\n        return self._opti('runtime', 'on_error')\n\n    @property\n    def runtime_outer(self):\n        return self._optb('runtime', 'outer')\n\n    @property\n    def runtime_period(self):\n        period = self._rt_opt('period')\n        if period:\n            c = period[-1].lower()\n            if c.isdecimal():\n                return int(period) * 3600\n\n            if c in ('m', 'h', 's'):\n                unit = {\n                    's': 1,\n                    'm': 60,\n                    'h': 3600,\n                }\n                return int(period[:-1]) * unit[c]\n\n            return -1\n\n    @property\n    def runtime_expired(self):\n        return self._rt_opt('expired')\n\n    @property\n    def runtime_nts(self):\n        return self._opts('runtime', 'nts')\n\n    @property\n    def runtime_nts_timeout(self):\n        return self._opti('runtime', 'nts_timeout')\n\n    @property\n    def runtime_devices(self):\n        value = self._rt_opt('devices')\n        return value.splitlines() if isinstance(value, str) else value\n\n    @property\n    def runtime_interps(self):\n        interps = self._rt_opt('interps')\n        rules = interps.splitlines() if interps else []\n        cfg = self.cfg['builder']\n        if cfg.getboolean('check_debugger', False):\n            rules.append('check-debugger')\n        if cfg.getboolean('check_interp', False):\n            rules.append('check-interp')\n        if self.runtime_hook('pyarmor_runtime'):\n            rules.append('py:bootstrap')\n        return '\\n'.join(rules)\n\n    @property\n    def runtime_timer(self):\n        return self._opti('runtime', 'timer')\n\n    @property\n    def runtime_simple_extension_name(self):\n        return self._optb('runtime', 'simple_extension_name')\n\n    @property\n    def runtime_user_data(self):\n        data = b''\n        filename = self.cmd_options.get('user_data')\n        if filename:\n            if filename[0] == '@':\n                with open(filename[1:], 'rb') as f:\n                    data = f.read()\n            else:\n                data = filename.encode()\n\n        return data\n\n    @property\n    def runtime_messages(self):\n        value = self.cfg['runtime'].get('messages', '')\n        if value:\n            name, encoding = (value + ':utf-8').split(':')[:2]\n            cfg = self._named_config(name, encoding=encoding)\n            if cfg.has_section('runtime.message'):\n                return cfg\n\n    def runtime_package_template(self, platforms):\n        return runtime_package_template if len(platforms) < 2 else \\\n            multi_runtime_package_template\n\n    #\n    # RFT settings\n    #\n\n    def rft_output_script(self, name):\n        return self._check_logpath(os.path.join(self.local_path, 'rft', name))\n\n    def rft_set_exclude_table(self, encoding=None):\n        filename = os.path.join(self.local_path, 'rft_exclude_table')\n        os.makedirs(os.path.dirname(filename), exist_ok=True)\n        with open(filename, 'w', encoding=encoding) as f:\n            f.write(' '.join(self.rft_auto_excludes))\n\n    def rft_get_exclude_table(self, encoding=None):\n        filename = os.path.join(self.local_path, 'rft_exclude_table')\n        if os.path.exists(filename):\n            with open(filename, encoding=encoding) as f:\n                return f.read().split()\n        return []\n\n    #\n    # BCC settings\n    #\n\n    @property\n    def bcc_build_path(self):\n        path = os.path.join(self.local_path, 'bcc')\n        os.makedirs(path, exist_ok=True)\n        return path\n\n    @property\n    def bcc_encoding(self):\n        return self.cfg['builder'].get('encoding', 'utf-8')\n\n    #\n    # Plugin and hook\n    #\n    def runtime_hook(self, modname):\n        for path in self.local_path, self.global_path:\n            filename = os.path.join(path, 'hooks', modname + '.py')\n            if os.path.exists(filename):\n                encoding = self.cfg['builder'].get('encoding', 'utf-8')\n                with open(filename, encoding=encoding) as f:\n                    return f.read()\n\n    def runtime_plugin(self, source, target, platforms):\n        from .plugin import Plugin\n        Plugin.post_runtime(self, source, target, platforms)\n\n    #\n    # Core data, new in 8.3\n    #\n    def _core_data(self, name):\n        n = __file__.find('context.py')\n        with open(__file__[:n] + name, 'rb') as f:\n            return f.read()\n\n    @property\n    def core_data_1(self):\n        return self._core_data('core.data.1')\n\n    @property\n    def core_data_2(self):\n        return self._core_data('core.data.2')\n\n    @property\n    def core_data_3(self):\n        return self._core_data('core.data.3')\n\n    #\n    # Get http proxy of token server\n    #\n    @property\n    def token_http_proxy(self):\n        http_proxy = os.environb.get(b'http_proxy', b'')\n        if not http_proxy:\n            return b''\n        i = http_proxy.find(b'@')\n        if i > 0:\n            from base64 import b64encode\n            header = b'Authorization: Basic %s\\r\\n' % b64encode(http_proxy[:i])\n        else:\n            header = b''\n        i += 1\n        j = http_proxy.find(b':', i)\n        if j == -1:\n            host = http_proxy[i:]\n            port = b'80'\n        else:\n            host = http_proxy[i:j]\n            port = http_proxy[j+1:]\n        url = b'http://pyarmor.dashingsoft.com'\n        return b'\\x00'.join([host, port, url, header, b'\\x00'])\n\n\nFile: pyarmor/helper/get_license_info.py\n#! /usr/bin/env python\n'''This script is used to get the license information of one package\nobfuscated by PyArmor.\n\nCopy it to the obfuscated package, generally it should be in the same\npath of runtime module or package 'pytransform', and run it:\n\n    cd /path/to/obfuscated-package\n    python get_license_info.py\n\nIt also could be run by this way\n\n    cd /path/to/obfuscated-package\n    python -m pyarmor.helper.get_license_info\n\n'''\nimport pytransform\n\nif hasattr(pytransform, 'pyarmor_init'):\n    pytransform.pyarmor_init(is_runtime=1)\n\nprint('Check obfuscated package in the current path')\nprint('Get license information from pytransform at %s:' % pytransform.__file__)\nfor k, v in pytransform.get_license_info().items():\n    print('%10s: %s' % (k, '' if v is None else v))\n\n\nFile: pyarmor/helper/__init__.py\n\n\n\nFile: pyarmor/helper/get_bind_key.py\n'''\nGet bind key for CPython Library\n\n   python get_bind_key.py\n\n'''\nfrom sys import platform\nfrom ctypes import CFUNCTYPE, cdll, pythonapi, string_at, c_void_p, c_char_p\n\n\ndef get_bind_key():\n    if platform.startswith('win'):\n        from ctypes import windll\n        dlsym = windll.kernel32.GetProcAddressA\n    else:\n        prototype = CFUNCTYPE(c_void_p, c_void_p, c_char_p)\n        dlsym = prototype(('dlsym', cdll.LoadLibrary(None)))\n\n    refunc1 = dlsym(pythonapi._handle, b'PyEval_EvalCode')\n    refunc2 = dlsym(pythonapi._handle, b'PyEval_GetFrame')\n\n    size = refunc2 - refunc1\n    code = string_at(refunc1, size)\n\n    print('Get bind key: %s' % sum(bytearray(code)))\n\n\nif __name__ == '__main__':\n    get_bind_key()\n\n\nFile: pyarmor/helper/superuntime.py\nimport platform\nimport sys\nimport struct\n\n\ndef import_names():\n    plat_table = (\n        ('windows', ('windows')),\n        ('darwin', ('darwin', 'ios')),\n        ('linux', ('linux*',)),\n        ('freebsd', ('freebsd*', 'openbsd*')),\n        ('poky', ('poky',)),\n    )\n\n    arch_table = (\n        ('x86', ('i386', 'i486', 'i586', 'i686')),\n        ('x86_64', ('x64', 'x86_64', 'amd64', 'intel')),\n        ('arm', ('armv5',)),\n        ('armv6', ('armv6l',)),\n        ('armv7', ('armv7l',)),\n        ('ppc64', ('ppc64le',)),\n        ('mips32', ('mips',)),\n        ('aarch32', ('aarch32',)),\n        ('aarch64', ('aarch64', 'arm64'))\n    )\n\n    plat = platform.system().lower()\n    mach = platform.machine().lower()\n\n    for alias, platlist in plat_table:\n        for s in platlist:\n            if s.startswith(plat):\n                plat = alias\n                break\n\n    if plat == 'linux':\n        cname, cver = platform.libc_ver()\n        if cname == 'musl':\n            plat = 'musl'\n        elif cname == 'libc':\n            plat = 'android'\n\n    for alias, archlist in arch_table:\n        if mach in archlist:\n            mach = alias\n            break\n\n    if plat == 'windows' and mach == 'x86_64':\n        bitness = struct.calcsize('P'.encode()) * 8\n        if bitness == 32:\n            mach = 'x86'\n\n    name = '.'.join([__name__, '%s_%s' % (plat, mach), 'pytransform'])\n    m = __import__(name, globals(), locals(), ['*'])\n    sys.modules[__name__].__dict__.update(m.__dict__)\n\n\nimport_names()\n\n\nFile: pyarmor/helper/merge.py\n'''This tool is used to merge the scripts obfuscated by different\nPython versions into one obfuscated script.\n\nFor example,\n\n1. First obfuscate the scripts by Python 2.7\n\n    python2.7 pyarmor.py obfuscate -O py27 foo.py\n\n2. Then obfuscate the scripts by Python 3.8\n\n    python3.8 pyarmor.py obfuscate -O py38 foo.py\n\n3. Run this tool to merge all of them to path `merged_dist`\n\n    python merge.py py38/ py27/\n\nIf also possible to merge one script, for example:\n\n    python merge.py py27/foo.py py36/foo.py py35/foo.py\n\n'''\nimport argparse\nimport logging\nimport os\nimport shutil\nimport struct\nimport sys\n\nlogger = logging.getLogger('merge')\n\n\ndef is_pyscript(filename):\n    return os.path.splitext(filename)[-1].lower() in ('.py', '.pyw')\n\n\ndef makedirs(path, exist_ok=False):\n    if not (exist_ok and os.path.exists(path)):\n        if path:\n            os.makedirs(path)\n\n\ndef parse_script(filename):\n    n = 0\n    with open(filename) as f:\n        for s in f.readlines():\n            if s.startswith('__pyarmor') or s.startswith('pyarmor('):\n                fs = s[s.find('__file__'):s.rfind(')')].split(', ')\n                code = eval(fs[-2])\n                flag = int(fs[-1])\n                break\n            n += 1\n        else:\n            return None, None, None, None\n\n    left_size = len(code)\n    offset = 0\n    infos = []\n    valid = False\n\n    while left_size > 0:\n        pymajor, pyminor = struct.unpack(\"BB\", code[offset+9:offset+11])\n        size, = struct.unpack(\"i\", code[offset+56:offset+60])\n        if not size:\n            valid = True\n            size = left_size\n        left_size -= size\n        infos.append([offset, size, (pymajor, pyminor)])\n        offset += size\n\n    if not valid:\n        raise RuntimeError('Invalid header in this script')\n\n    return n, flag, code, infos\n\n\ndef merge_scripts(scripts, output):\n    refscript = scripts.pop(0)\n    logger.info('Parse reference script %s', refscript)\n    refn, reflag, refcode, refinfos = parse_script(refscript)\n\n    if refcode is None:\n        logger.info('Ignore this script, it is not obfuscated')\n        return\n\n    merged_vers = []\n    pieces = []\n\n    for script in reversed(scripts):\n        logger.info('Parse script %s', script)\n        n, flag, code, pyinfos = parse_script(script)\n        if code is None:\n            raise RuntimeError('This script is not an obfuscated script')\n        if reflag != flag:\n            raise RuntimeError('The script \"%s\" is obfuscated with '\n                               'different way' % script)\n        if len(pyinfos) > 1:\n            raise RuntimeError('The script \"%s\" is merged script' % script)\n\n        ver = pyinfos[0][-1]\n        logger.debug('\\tFound Python %d.%d', *ver)\n\n        if ver in merged_vers:\n            logging.warning('\\tIngore this Python %d.%d', *ver)\n            continue\n\n        logger.debug('\\tMerge this Python %d.%d', *ver)\n        merged_vers.append(ver)\n        pieces.extend([code[:56], struct.pack(\"i\", len(code)), code[60:]])\n\n    logger.debug('Handle reference script %s', refscript)\n    for offset, size, ver in refinfos:\n        logger.debug('\\tFound Python %d.%d', *ver)\n        if ver in merged_vers:\n            logger.debug('\\tIgnore this Python %d.%d', *ver)\n            continue\n        logger.debug('\\tMerge this Python %d.%d', *ver)\n        merged_vers.append(ver)\n        pieces.append(refcode[offset:offset+size])\n\n    scode = '\\\\x' + '\\\\x'.join(['%02x' % c\n                                for c in bytearray(b''.join(pieces))])\n\n    with open(scripts[0]) as f:\n        lines = f.readlines()\n\n    s = lines[refn]\n    i = s.find(', b')\n    j = s.rfind(',')\n    lines[refn] = s[:i+4] + scode + s[j-1:]\n\n    logger.info('Write merged script: %s', output)\n    for ver in merged_vers:\n        logger.info('\\t* Python %d.%d', *ver)\n\n    makedirs(os.path.dirname(output), exist_ok=True)\n    with open(output, 'w') as f:\n        f.write(''.join(lines))\n\n\ndef merge_runtimes(paths, output):\n    runtimes = []\n    pyvers = []\n    refpath = os.path.normpath(paths[-1])\n\n    n = len(refpath) + 1\n    for root, dirs, files in os.walk(refpath):\n        if os.path.basename(root).startswith('pytransform'):\n            runtimes.append(root[n:])\n\n        for x in files:\n            if x in ('pytransform_bootstrap.py', 'pytransform_protection.py'):\n                continue\n            if x.startswith('pytransform'):\n                runtimes.append(os.path.join(root, x)[n:])\n            elif is_pyscript(x) and not pyvers:\n                name = os.path.join(root, x)[n:]\n                for p in paths:\n                    pyinfos = parse_script(os.path.join(p, name))[-1]\n                    if pyinfos is None:\n                        pyvers = []\n                        break\n                    if len(pyinfos) > 1:\n                        raise RuntimeError('The runtime file in %s is merged'\n                                           % p)\n                    pyvers.append(pyinfos[0][-1])\n\n    logger.debug('Found runtimes: %s', runtimes)\n    if not runtimes:\n        raise RuntimeError('No runtime files found')\n    elif len(runtimes) > 1:\n        raise RuntimeError('Too many runtime files')\n\n    logger.debug('Found python versions: %s', pyvers)\n    if not pyvers:\n        raise RuntimeError('Could not get python version of runtime files')\n\n    r = os.path.join(refpath, runtimes[0])\n    if os.path.isdir(r):\n        logger.info('Copy non-super mode runtime package %s', r)\n        dst = os.path.join(output, runtimes[0])\n        logger.info('To %s', dst)\n        makedirs(os.path.dirname(dst), exist_ok=True)\n        shutil.copytree(r, dst)\n        return\n\n    pkgname = os.path.basename(r).rsplit('.', 1)[0]\n    pkgpath = os.path.join(output, pkgname)\n    makedirs(pkgpath, exist_ok=True)\n\n    src = os.path.join(pkgpath, '__init__.py')\n    logger.info('Create super runtime package: %s', src)\n    with open(src, 'w') as f:\n        f.write(\n            \"import sys\\n\"\n            \"sys.modules[__name__].__dict__.update(\"\n            \"__import__('.'.join(\"\n            \"[__name__, 'py%s%s' % sys.version_info[:2], __name__]),\"\n            \" globals(), locals(), ['*']).__dict__)\"\n        )\n\n    for p, (major, minor) in zip(paths, pyvers):\n        src = os.path.join(p, runtimes[0])\n        dst = os.path.join(pkgpath,  'py%s%s' % (major, minor))\n        logger.info('Copy %s to %s', src, dst)\n        makedirs(dst, exist_ok=True)\n        shutil.copy2(src, dst)\n\n        logger.debug('Create package file \"%s/__init__.py\"', dst)\n        with open(os.path.join(dst, '__init__.py'), 'w') as f:\n            f.write('')\n\n\ndef find_scripts(paths):\n    names = []\n\n    refpath = os.path.normpath(paths[-1])\n    logger.info('Find scripts in the path %s', refpath)\n\n    n = len(refpath) + 1\n    for root, dirs, files in os.walk(refpath):\n        for x in files:\n            if not is_pyscript(x):\n                continue\n\n            scripts = [os.path.join(root, x)]\n            names.append(scripts[0][n:])\n\n    return names\n\n\ndef excepthook(type, exc, traceback):\n    try:\n        msg = exc.args[0] % exc.args[1:]\n    except Exception:\n        msg = str(exc)\n    logging.error(msg)\n    sys.exit(1)\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        prog='pyarmor merge',\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=__doc__)\n\n    parser.add_argument('-O', '--output',\n                        default='merged_dist',\n                        help='Default output path: %(default)s)')\n    parser.add_argument('-d', '--debug',\n                        default=False,\n                        action='store_true',\n                        dest='debug',\n                        help='print debug log (default: %(default)s)')\n    parser.add_argument('-n', '--no-runtime', action='store_true',\n                        help='Ignore runtime files')\n    parser.add_argument('path', nargs='+',\n                        help=\"Path or obfuscated script\")\n\n    args = parser.parse_args(sys.argv[1:])\n    if args.debug:\n        logger.setLevel(logging.DEBUG)\n    else:\n        sys.excepthook = excepthook\n\n    logger.info('Merge %s...', str(args.path)[1:-1])\n    output = args.output\n\n    if os.path.isfile(args.path[0]):\n        output = output if is_pyscript(output) \\\n            else os.path.join(output, os.path.basename(args.path[0]))\n\n        merge_scripts(args.path, output)\n\n    else:\n        if output and is_pyscript(output):\n            raise RuntimeError('--output must be a path when mergeing path')\n\n        logging.info('Merging obfuscated scripts...')\n        for name in find_scripts(args.path):\n            merge_scripts([os.path.join(p, name) for p in args.path],\n                          os.path.join(output, name))\n        logging.info('Merging obfuscated scripts OK')\n\n        if not args.no_runtime:\n            logging.info('Merging runtime files...')\n            merge_runtimes(args.path, output)\n            logging.info('Merging runtime files OK')\n\n    logger.info('Merge all the scripts to %s successfully', output)\n\n\nif __name__ == '__main__':\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(levelname)-8s %(message)s',\n    )\n    main()\n\n\nFile: pyarmor/helper/get_platform_name.py\nimport platform\nimport struct\nimport sys\n\nfrom ctypes import cdll, c_char_p, CFUNCTYPE\nfrom fnmatch import fnmatch\n\nplat_table = (\n    ('windows', ('windows', 'cygwin-*')),\n    ('darwin', ('darwin',)),\n    ('ios', ('ios',)),\n    ('linux', ('linux*',)),\n    ('freebsd', ('freebsd*', 'openbsd*', 'isilon onefs')),\n    ('poky', ('poky',)),\n)\n\narch_table = (\n    ('x86', ('i?86', )),\n    ('x86_64', ('x64', 'x86_64', 'amd64', 'intel')),\n    ('arm', ('armv5',)),\n    ('armv6', ('armv6l',)),\n    ('armv7', ('armv7l',)),\n    ('ppc64', ('ppc64le',)),\n    ('mips32', ('mips',)),\n    ('aarch32', ('aarch32',)),\n    ('aarch64', ('aarch64', 'arm64'))\n)\n\n\ndef _match_features(patterns, s):\n    for pat in patterns:\n        if fnmatch(s, pat):\n            return True\n\n\ndef _gnu_get_libc_version():\n    try:\n        prototype = CFUNCTYPE(c_char_p)\n        ver = prototype(('gnu_get_libc_version', cdll.LoadLibrary('')))()\n        return ver.decode().split('.')\n    except Exception:\n        pass\n\n\ndef format_platform():\n    plat = platform.system().lower()\n    mach = platform.machine().lower()\n\n    for alias, platlist in plat_table:\n        if _match_features(platlist, plat):\n            plat = alias\n            break\n\n    if plat == 'linux':\n        cname, cver = platform.libc_ver()\n        if cname == 'musl':\n            plat = 'musl'\n        elif cname == 'libc':\n            plat = 'android'\n        elif cname == 'glibc':\n            v = _gnu_get_libc_version()\n            if v and len(v) >= 2 and (int(v[0]) * 100 + int(v[1])) < 214:\n                plat = 'centos6'\n\n    for alias, archlist in arch_table:\n        if _match_features(archlist, mach):\n            mach = alias\n            break\n\n    if plat == 'windows' and mach == 'x86_64':\n        bitness = struct.calcsize('P'.encode()) * 8\n        if bitness == 32:\n            mach = 'x86'\n\n    return '.'.join([plat, mach])\n\n\nif __name__ == '__main__':\n    print('platform.system is \"%s\"' % platform.system())\n    print('platform.machine is \"%s\"' % platform.machine())\n    print('sys.byteorder is \"%s\"' % sys.byteorder)\n    print('The standard platform name is \"%s\"' % format_platform())\n\n\nFile: pyarmor/helper/repack.py\n'''\nThis script is used to repack PyInstaller bundle with obfuscated scripts\n\nFirst pack the script by PyInstaller, next obfuscate the scripts by PyArmor,\nfinally run this script to repack the bundle with obfuscated scripts.\n\n* Pack the script with PyInstaller, make sure the final bundle works\n\n    # One folder mode\n    pyinstaller foo.py\n\n    # Check it works\n    dist/foo/foo\n\n    # One file mode\n    pyinstaller --onefile foo.py\n\n    # Check it works\n    dist/foo\n\n* Obfuscate the scripts to \"obfdist\", make sure the obfuscated scripts\n  work\n\n    # Option --package-runtime should be set to 0\n    pyarmor obfuscate -O obfdist --package-runtime 0 foo.py\n\n    # For super mode\n    pyarmor obfuscate -O obfdist --advanced 2 foo.py\n\n    # Check it works\n    python dist/foo.py\n\n* Repack the final executable, use the same Python interpreter as PyInstaller using\n\n    # One folder mode\n    python repack.py -p obfdist dist/foo/foo\n\n    # Overwrite the old one\n    cp foo-obf dist/foo/foo\n\n    # One file mode\n    python repack.py -p obfdist dist/foo\n\n    # Overwrite the old one\n    cp foo-obf dist/foo\n\nHere \"foo-obf\" is the patched bundle.\n\n'''\nimport argparse\nimport logging\nimport marshal\nimport os\nimport shutil\nimport struct\nimport sys\nimport zlib\n\nfrom subprocess import check_call\n\nfrom PyInstaller.archive.writers import ZlibArchiveWriter, CArchiveWriter\nfrom PyInstaller.archive.readers import CArchiveReader\ntry:\n    from PyInstaller.loader.pyimod02_archive import ZlibArchiveReader\n    from PyInstaller.loader.pyimod02_archive import PYZ_TYPE_PKG\nexcept ModuleNotFoundError:\n    from PyInstaller.loader.pyimod01_archive import ZlibArchiveReader\n    from PyInstaller.loader.pyimod01_archive import PYZ_TYPE_PKG\nfrom PyInstaller.compat import is_darwin, is_linux, is_win\n\n\nlogger = logging.getLogger('repack')\n\n\nclass ZlibArchive(ZlibArchiveReader):\n\n    def checkmagic(self):\n        \"\"\" Overridable.\n            Check to see if the file object self.lib actually has a file\n            we understand.\n        \"\"\"\n        self.lib.seek(self.start)  # default - magic is at start of file.\n        if self.lib.read(len(self.MAGIC)) != self.MAGIC:\n            raise RuntimeError(\"%s is not a valid %s archive file\"\n                               % (self.path, self.__class__.__name__))\n        if self.lib.read(len(self.pymagic)) != self.pymagic:\n            print(\"Warning: pyz is from a different Python version\")\n        self.lib.read(4)\n\n\nclass CArchiveWriter2(CArchiveWriter):\n\n    def add(self, entry):\n        patched, dlen, ulen, flag, typcd, nm, pathnm = entry\n        where = self.lib.tell()\n\n        logger.debug('Add item \"%s\"', nm)\n\n        if is_darwin and patched and typcd == 'b':\n            from PyInstaller.depend import dylib\n            dylib.mac_set_relative_dylib_deps(pathnm, os.path.basename(pathnm))\n\n        fh = open(pathnm, 'rb')\n        filedata = fh.read()\n        fh.close()\n\n        if patched:\n            logger.info('Replace item \"%s\" with \"%s\"', nm, pathnm)\n            if typcd in ('s', 'M'):\n                code = compile(filedata, '<%s>' % nm, 'exec')\n                filedata = marshal.dumps(code)\n                ulen = len(filedata)\n            else:\n                ulen = len(filedata)\n\n        if flag == 1 and patched:\n            comprobj = zlib.compressobj(self.LEVEL)\n            self.lib.write(comprobj.compress(filedata))\n            self.lib.write(comprobj.flush())\n        else:\n            self.lib.write(filedata)\n\n        dlen = self.lib.tell() - where\n        self.toc.add(where, dlen, ulen, flag, typcd, nm)\n\n\ndef makedirs(path, exist_ok=False):\n    if not (exist_ok and os.path.exists(path)):\n        os.makedirs(path)\n\n\ndef get_cookie_pos(fp, filesize):\n    MAGIC = b'MEI\\014\\013\\012\\013\\016'\n    blocksize = 8192\n    end_pos = filesize\n    result = -1\n\n    if end_pos < len(MAGIC):\n        raise RuntimeError('invalid PyInstaller bundle')\n\n    while True:\n        start_pos = end_pos - blocksize if end_pos >= blocksize else 0\n        chunksize = end_pos - start_pos\n\n        if chunksize < len(MAGIC):\n            break\n\n        fp.seek(start_pos, os.SEEK_SET)\n        data = fp.read(chunksize)\n\n        offs = data.rfind(MAGIC)\n        if offs != -1:\n            result = start_pos + offs\n            break\n\n        end_pos = start_pos + len(MAGIC) - 1\n\n        if start_pos == 0:\n            break\n\n    if result == -1:\n        raise RuntimeError('invalid PyInstaller bundle')\n\n    return result\n\n\ndef get_carchive_info(filepath):\n    PYINST_COOKIE_SIZE = 24 + 64        # For pyinstaller 2.1+\n    fp = open(filepath, 'rb')\n    filesize = os.stat(filepath).st_size\n    pos = get_cookie_pos(fp, filesize)\n    fp.seek(pos, os.SEEK_SET)\n\n    # Read CArchive cookie\n    magic, lengthofPackage, toc, tocLen, pyver, pylibname = \\\n        struct.unpack('!8sIIii64s', fp.read(PYINST_COOKIE_SIZE))\n    fp.close()\n\n    # Overlay is the data appended at the end of the PE\n    pos = filesize - lengthofPackage\n    return pos, pylibname.decode()\n\n\ndef append_runtime_files(logic_toc, obfpath):\n    logger.info('Appending runtime files to archive')\n\n    n = 0\n\n    def add_toc(typcd, name, pathnm):\n        logger.info('Add \"%s\"', pathnm)\n        if os.path.isdir(pathnm):\n            raise RuntimeError('It is not allowed to write path \"%s\" to '\n                               'bundle. When obfuscating the scripts, '\n                               'make sure \"--package-runtime 0\" is used',\n                               pathnm)\n        if n > 1:\n            raise RuntimeError('In the path \"%s\", there are too many '\n                               'files start with \"pytransform\" or '\n                               '\"_pytransform\", there shuold be only one',\n                               obfpath)\n        logic_toc.append((1, 0, 0, 1, typcd, name, pathnm))\n\n    for name in os.listdir(obfpath):\n        pathnm = os.path.join(obfpath, name)\n        if (name.startswith('pytransform') and name[-3:] != '.py') \\\n           or name.startswith('_pytransform'):\n            n += 1\n            add_toc('b', name, pathnm)\n        elif name == 'license.lic':\n            add_toc('x', name, pathnm)\n\n    logger.info('Append runtime files OK')\n\n\ndef repack_pyz(pyz, obfpath, cipher=None, clean=False):\n    code_dict = {}\n    obflist = []\n\n    n = len(obfpath) + 1\n    for dirpath, dirnames, filenames in os.walk(obfpath):\n        for pyfile in [x for x in filenames if x.endswith('.py')]:\n            pyfile = os.path.join(dirpath, pyfile)\n            logger.info('Compile %s', pyfile)\n            name = pyfile[n:].replace('\\\\', '.').replace('/', '.')[:-3]\n            if name.endswith('__init__.py'):\n                name = name[:-len('__init__.py')].strip('.')\n            with open(pyfile, 'r') as f:\n                source = f.read()\n            logger.debug('Got obfuscated item: %s', name)\n            code_dict[name] = compile(source, '<%s>' % name, 'exec')\n            obflist.append(name)\n    logger.info('Got %d obfuscated items', len(obflist))\n\n    logger.info('Patching PYZ file \"%s\"', pyz)\n    arch = ZlibArchive(pyz)\n\n    logic_toc = []\n    for name in arch.toc:\n        logger.debug('Extract %s', name)\n        typ, obj = arch.extract(name)\n        if name in obflist:\n            logger.info('Replace item \"%s\" with obfsucated one', name)\n            obflist.remove(name)\n        else:\n            code_dict[name] = obj\n        pathname = '__init__.py' if typ == PYZ_TYPE_PKG else name\n        logic_toc.append((name, pathname, 'PYMODULE'))\n    logger.debug('unhandled obfuscated items are %s', obflist)\n\n    ZlibArchiveWriter(pyz, logic_toc, code_dict=code_dict, cipher=cipher)\n    logger.info('Patch PYZ done')\n\n\ndef repack_exe(path, obfname, logic_toc, obfentry, codesign=None):\n    logger.info('Repacking EXE \"%s\"', obfname)\n\n    if is_darwin:\n        import PyInstaller.utils.osx as osxutils\n        if hasattr(osxutils, 'remove_signature_from_binary'):\n            logger.info(\"Removing signature(s) from EXE\")\n            osxutils.remove_signature_from_binary(obfname)\n\n    offset, pylib_name = get_carchive_info(obfname)\n    logger.info('Get archive info (%d, \"%s\")', offset, pylib_name)\n\n    pkgname = os.path.join(path, 'PKG-pyarmor-patched')\n    logging.info('Patching PKG file \"%s\"', pkgname)\n    CArchiveWriter2(pkgname, logic_toc, pylib_name=pylib_name)\n    logging.info('Patch PKG done')\n\n    if is_linux:\n        logger.info('Replace section \"pydata\" with \"%s\" in EXE', pkgname)\n        check_call(['objcopy', '--update-section', 'pydata=%s' % pkgname,\n                    obfname])\n    else:\n        logger.info('Replace PKG with \"%s\" in EXE', pkgname)\n        with open(obfname, 'r+b') as outf:\n            # Keep bootloader\n            outf.seek(offset, os.SEEK_SET)\n\n            # Write the patched archive\n            with open(pkgname, 'rb') as infh:\n                shutil.copyfileobj(infh, outf, length=64*1024)\n\n            outf.truncate()\n\n    if is_darwin:\n        # Fix Mach-O header for codesigning on OS X.\n        logger.info('Fixing EXE for code signing \"%s\"', obfname)\n        import PyInstaller.utils.osx as osxutils\n        osxutils.fix_exe_for_code_signing(obfname)\n\n        if hasattr(osxutils, 'sign_binary'):\n            logger.info(\"Re-signing the EXE\")\n            osxutils.sign_binary(obfname, identity=codesign)\n\n    if is_win:\n        # Set checksum to appease antiviral software.\n        from PyInstaller.utils.win32 import winutils\n        if hasattr(winutils, 'set_exe_checksum'):\n            winutils.set_exe_checksum(obfname)\n\n    logger.info('Generate patched bundle \"%s\" successfully', obfname)\n\n\ndef repacker(executable, obfpath, entry=None, codesign=None):\n    logger.info('Repack PyInstaller bundle \"%s\"', executable)\n\n    obfpath = os.path.normpath(obfpath)\n    logger.info('Obfuscated scripts in the path \"%s\"', obfpath)\n\n    name, ext = os.path.splitext(os.path.basename(executable))\n    entry = name if entry is None else entry\n    logger.info('Entry script name is \"%s.py\"', entry)\n\n    arch = CArchiveReader(executable)\n    logic_toc = []\n\n    obfentry = os.path.join(obfpath, entry + '.py')\n    if not os.path.exists(obfentry):\n        raise RuntimeError('No obfuscated script \"%s\" found', obfentry)\n\n    path = os.path.join(name + '_extracted')\n    logger.info('Extracted bundle files to \"%s\"', path)\n    makedirs(path, exist_ok=True)\n\n    for item in arch.toc:\n        logger.debug('toc: %s', item)\n        dpos, dlen, ulen, flag, typcd, nm = item\n        pathnm = os.path.join(path, nm)\n        makedirs(os.path.dirname(pathnm), exist_ok=True)\n        with arch.lib:\n            arch.lib.seek(arch.pkg_start + dpos)\n            with open(pathnm, 'wb') as f:\n                f.write(arch.lib.read(dlen))\n\n            if nm.endswith('.pyz') and typcd in ('z', 'Z'):\n                logger.info('Extract pyz file \"%s\"', pathnm)\n                repack_pyz(pathnm, obfpath)\n                patched = 1\n            elif name == nm:\n                patched = 1\n                pathnm = obfentry\n            else:\n                patched = 0\n            logic_toc.append((patched, dlen, ulen, flag, typcd, nm, pathnm))\n\n    append_runtime_files(logic_toc, obfpath)\n\n    obfname = os.path.join(name + '_obf' + ext)\n    shutil.copy2(executable, obfname)\n    repack_exe(path, obfname, logic_toc, obfentry, codesign=codesign)\n\n\ndef excepthook(type, exc, traceback):\n    try:\n        msg = exc.args[0] % exc.args[1:]\n    except Exception:\n        msg = str(exc)\n    logging.error(msg)\n    sys.exit(1)\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('-d', '--debug',\n                        default=False,\n                        action='store_true',\n                        dest='debug',\n                        help='print debug log (default: %(default)s)')\n    parser.add_argument('-p', '--path',\n                        default='obfdist',\n                        dest='obfpath',\n                        help='obfuscated scripts path (default: %(default)s)')\n    parser.add_argument('-e', '--entry',\n                        help=\"Entry script if it's different from bundle name\")\n    parser.add_argument('--codesign-identity',\n                        help=\"Code signing identity (macOS only).\")\n    parser.add_argument('executable', metavar='executable',\n                        help=\"PyInstaller archive\")\n\n    args = parser.parse_args(sys.argv[1:])\n    if args.debug:\n        logger.setLevel(logging.DEBUG)\n    else:\n        sys.excepthook = excepthook\n    repacker(args.executable, args.obfpath, args.entry, args.codesign_identity)\n\n\nif __name__ == '__main__':\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(message)s',\n    )\n    main()\n\n\nFile: pyarmor/helper/buildext.py\n'''\nThis script is used to build obfuscated scripts to extensions\n\n1. Obfuscate the script with --no-cross-protection and --restrict 0\n\n    pyarmor obfuscate --no-cross-protection --restrict 0 foo.py\n\n2. Build obfuscated script to extension\n\n    python buildext.py dist/foo.py\n\nOr convert the obfuscated script \"dist/foo.py\" to .c file first, then\nbuild it by any c compiler, for example\n\n    python buildext.py -c dist/foo.py\n    gcc $(python-config --cflags) $(python-config --ldflags) \\\\\n        -shared -o dist/foo$(python-config --extension-suffix) \\\\\n        dist/foo.c\n'''\nimport argparse\nimport glob\nimport logging\nimport os\nimport random\nimport sys\n\nfrom distutils.core import setup, Extension\nfrom distutils.ccompiler import new_compiler\nfrom distutils.sysconfig import customize_compiler\nfrom sysconfig import get_config_var, get_path\n\n\nlogger = logging.getLogger('buildext')\n\nc_extension_template = '''\n#define PYARMOR_RUNTIME \"pyarmor_runtime\"\n\n#if !defined(CUSTOMIZE_BYTECODES)\n# define CUSTOMIZE_BYTECODES(x)\n#endif\n\n#define PY_SSIZE_T_CLEAN\n\n#include \"Python.h\"\n\n#ifndef Py_PYTHON_H\n# error Python headers needed to compile C extensions\n#endif\n\n#if (PY_MAJOR_VERSION >= 3)\n# define BUILD_FILENAME(name) PyUnicode_FromFormat(\"<frozen %U>\", name)\n# define PYARMOR_ARGUMENTS \"OOy#i\"\n#else\n# define BUILD_FILENAME(name) PyString_FromFormat(\"<frozen %s>\", PyString_AsString(name))\n# define PYARMOR_ARGUMENTS \"OOz#i\"\n#endif\n\nstatic unsigned char cipher_code[] = { CIPHER_CODE };\n\n#if defined(PYARMOR_SUPER_MODE)\n\nstatic PyObject *\nimport_pyarmor()\n{\n  PyObject *t = PyImport_ImportModule(PYTRANSFORM_NAME);\n  if (!t)\n    return NULL;\n\n  PyObject *f = PyDict_GetItemString(PyModule_GetDict(t), PYARMOR_NAME);\n  Py_DECREF(t);\n\n  if (!f)\n    PyErr_Format(PyExc_ImportError, \"No '%s.%s' found\", PYTRANSFORM_NAME, PYARMOR_NAME);\n\n  return f;\n}\n\n#else\n\nstatic PyObject *\nimport_pyarmor()\n{\n  PyObject *t = NULL;\n  PyObject *b = PyEval_GetBuiltins();\n  PyObject *f = PyDict_GetItemString(b, PYARMOR_NAME);\n\n  if (!f) {\n    t = PyImport_ImportModule(PYTRANSFORM_NAME);\n    if (!t)\n      return NULL;\n\n    PyObject *runtime = PyDict_GetItemString(PyModule_GetDict(t), PYARMOR_RUNTIME);\n    if (!runtime) {\n      PyErr_Format(PyExc_ImportError, \"No '%s.%s' found\", PYTRANSFORM_NAME, PYARMOR_RUNTIME);\n      goto fail;\n    }\n\n    if (!PyObject_CallFunctionObjArgs(runtime, NULL)) {\n      goto fail;\n    }\n\n    f = PyDict_GetItemString(b, PYARMOR_NAME);\n    if (!f) {\n      PyErr_Format(PyExc_ImportError, \"No builtin function '%s' found\", PYARMOR_NAME);\n      goto fail;\n    }\n\n  fail:\n    Py_DECREF(t);\n  }\n\n  return f;\n}\n\n#endif\n\nstatic PyObject *\nrun_pyarmor(PyObject *m, PyObject *f)\n{\n  PyObject *d = PyModule_GetDict(m);\n  PyObject *name = PyDict_GetItemString(d, \"__name__\");\n  if (!name) {\n    PyErr_SetString(PyExc_ImportError, \"No module attribute '__name__' found\");\n    return NULL;\n  }\n\n  PyObject *file = PyDict_GetItemString(d, \"__file__\");\n  if (file)\n    Py_INCREF(file);\n  else {\n    file = BUILD_FILENAME(name);\n    if (!file)\n      return NULL;\n  }\n\n  CUSTOMIZE_BYTECODES(cipher_code);\n\n  PyObject *ret = PyObject_CallFunction(f, PYARMOR_ARGUMENTS, name, file,\n                                        cipher_code, sizeof(cipher_code), CIPHER_MODE);\n  Py_DECREF(file);\n  return ret;\n}\n\n#if (PY_MAJOR_VERSION >= 3)\n\nstatic struct PyModuleDef module = {\n    PyModuleDef_HEAD_INIT,\n    \"XYZXYZ\",\n    NULL,\n    -1,\n    NULL\n};\n\nPyMODINIT_FUNC\nPyInit_XYZXYZ(void)\n{\n  PyObject *f = import_pyarmor();\n  if (!f)\n    return NULL;\n\n  PyObject *m = PyModule_Create(&module);\n  if (!m)\n    return NULL;\n\n  PyObject *r = run_pyarmor(m, f);\n  if (!r) {\n    Py_DECREF(m);\n    m = NULL;\n  }\n  Py_XDECREF(r);\n\n  return m;\n}\n\n#else\n\nPyMODINIT_FUNC\ninitXYZXYZ(void)\n{\n  PyObject *f = import_pyarmor();\n  if (!f)\n    return;\n\n  PyObject *m = Py_InitModule(\"XYZXYZ\", NULL);\n  if (!m)\n    return;\n\n  PyObject *r = run_pyarmor(m, f);\n  if (!r)\n    Py_DECREF(m);\n  Py_XDECREF(r);\n}\n\n#endif\n\n'''\n\nc_extra_template = r'''\n#if (PY_MAJOR_VERSION >= 3)\n\n# if PY_MINOR_VERSION < 5\n#  error \"No support for Python3.0-3.4\"\n# endif\n\n# define PYSYS_SETARGV(argc, argv)                      \\\n  wchar_t *wargv[255] = { 0 };                          \\\n  do {                                                  \\\n    int i;                                              \\\n    for (i = 0; i < argc; i ++)                         \\\n      wargv[i] = Py_DecodeLocale(argv[i], NULL);        \\\n  } while (0);                                          \\\n  PySys_SetArgv(argc, wargv);\n\n# define PYSYS_FREEARGV()   do {                \\\n    wchar_t **p = wargv;                        \\\n    while (*p ++)                               \\\n      PyMem_RawFree(*p);                        \\\n  } while (0)\n\n#else\n\n# define PYSYS_SETARGV(argc, argv) PySys_SetArgv(argc, argv)\n# define PYSYS_FREEARGV()\n\n#endif\n\nint\nmain(int argc, char *argv[])\n{\n  int ret = -1;\n  PyObject *f, *m, *r;\n\n  Py_Initialize();\n  PYSYS_SETARGV(argc, argv);\n\n  m = PyImport_AddModule(\"__main__\");\n  if (m) {\n    f = import_pyarmor();\n    if (f) {\n      r = run_pyarmor(m, f);\n      ret = r ? 0 : 1;\n      Py_XDECREF(r);\n    }\n  }\n\n  Py_Finalize();\n  PYSYS_FREEARGV();\n\n  return ret;\n}\n'''\n\n\ndef make_macro_for_customized_bytecodes(bytecodes):\n    n = len(bytecodes)\n    i = random.randrange(0, n)\n    j = random.randrange(0, n)\n    k = random.randrange(0, 256)\n    bytecodes[i] -= 1\n    bytecodes[j] ^= k\n    return r'''\n#define CUSTOMIZE_BYTECODES(bytecodes) do { \\\n        bytecodes[%s] ++;                  \\\n        bytecodes[%s] ^= %s;               \\\n    } while (0)\n''' % (i, j, k)\n\n\ndef makedirs(path, exist_ok=False):\n    if not (exist_ok and os.path.exists(path)):\n        os.makedirs(path)\n\n\ndef make_c_source(filename, output=None, extra=None):\n    logger.info('Analysis \"%s\"', filename)\n\n    name = os.path.basename(filename).rsplit('.', 1)[0]\n    pytransform_name = 'pytransform'\n    pyarmor_name = ''\n\n    with open(filename) as f:\n        for line in f:\n            if line.startswith('from'):\n                pytransform_name = line.strip().split()[1]\n            elif line.find('__file__') > 0:\n                pyarmor_name, parastr = line.strip().split('(', 1)\n                paras = parastr.strip()[:-1].split(',')\n                cipher_mode = paras[-1]\n                cipher_code = list(bytearray(eval(paras[-2])))\n                break\n\n    if pyarmor_name.find('pyarmor') == -1:\n        logger.warning('%s is not obfuscated script' % filename)\n        return\n\n    super_mode = pyarmor_name.startswith('pyarmor')\n\n    logger.info('extension name is \"%s\"', name)\n    logger.info('pyarmor name is \"%s\"', pyarmor_name)\n    logger.info('pytransform name is \"%s\"', pytransform_name)\n    logger.info('super mode is %s', super_mode)\n    logger.info('cipher mode is %s', cipher_mode)\n\n    customized_macro = make_macro_for_customized_bytecodes(cipher_code)\n\n    macros = [\n        '/* Generated by PyArmor Helper 0.1 */',\n        '#define PYARMOR_SUPER_MODE' if super_mode else '',\n        '#define PYARMOR_NAME \"%s\"' % pyarmor_name,\n        '#define PYTRANSFORM_NAME \"%s\"' % pytransform_name,\n        '#define CIPHER_MODE %s' % cipher_mode,\n        '#define CIPHER_CODE %s' % repr(cipher_code)[1:-1],\n        customized_macro,\n        ''\n    ]\n\n    if output is None:\n        output = filename[:-3] + '.c'\n    logger.info('Write \"%s\"', output)\n    with open(output, 'w') as f:\n        f.write('\\n'.join(macros))\n        f.write(c_extension_template.replace('XYZXYZ', name))\n        if extra:\n            f.write(c_extra_template)\n\n    return output\n\n\ndef build_extensions(sources):\n    modules = [(os.path.basename(src)[:-2], src) for src in sources]\n    setup(name='builder',\n          script_args=['build_ext'],\n          ext_modules=[Extension(k, sources=[v]) for k, v in modules])\n\n\ndef make_extensions(sources, executable=False):\n    cc = new_compiler()\n    customize_compiler(cc)\n\n    include_dirs = [get_path(x) for x in ('include', 'platinclude')]\n    cc.set_include_dirs(include_dirs)\n\n    if not get_config_var('Py_ENABLE_SHARED'):\n        cc.add_library_dir(get_config_var('LIBPL'))\n    abiflags = sys.abiflags if hasattr(sys, 'abiflags') else ''\n    cc.add_library('python' + get_config_var('VERSION') + abiflags)\n\n    cflags = get_config_var('CFLAGS').split()\n    ldflags = get_config_var('LIBS').split()\n    ldflags += get_config_var('SYSLIBS').split()\n\n    logger.debug('CFLAGS %s', cflags)\n    logger.debug('LDFLAGS %s', ldflags)\n\n    objects = cc.object_filenames(sources)\n    cc.compile(sources, extra_preargs=cflags)\n\n    if executable:\n        def cc_link(src, obj):\n            output = cc.executable_filename(src[:-2])\n            logger.info('Generate executable \"%s\"', output)\n            cc.link_executable([obj], output, extra_postargs=ldflags)\n    else:\n        def cc_link(src, obj):\n            output = cc.shared_object_filename(src[:-2])\n            logger.info('Generate extension \"%s\"', output)\n            cc.link_shared_object([obj], output, extra_postargs=ldflags)\n\n    for src, obj in zip(sources, objects):\n        cc_link(src, obj)\n\n    logger.debug('Clean all .o files')\n    [os.remove(x) for x in objects]\n\n\ndef excepthook(type, exc, traceback):\n    if hasattr(exc, 'args'):\n        logging.error(exc.args[0], *exc.args[1:])\n    else:\n        logging.error('%s', exc)\n    sys.exit(1)\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description='build obfuscated scripts to extensions',\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=__doc__)\n    parser.add_argument('-d', '--debug',\n                        default=False,\n                        action='store_true',\n                        dest='debug',\n                        help='print debug log (default: %(default)s)')\n    parser.add_argument('-c',\n                        default=True,\n                        action='store_false',\n                        dest='build',\n                        help='generate .c file only (default: False)')\n    parser.add_argument('-e',\n                        default=False,\n                        action='store_true',\n                        dest='executable',\n                        help='generate executable (default: %(default)s)')\n    parser.add_argument('-i',\n                        default=False,\n                        action='store_true',\n                        dest='inplace',\n                        help='remove script after build (default: %(default)s)')\n    parser.add_argument('scripts',\n                        metavar='PATH',\n                        nargs='+',\n                        help=\"obfuscated script or path\")\n\n    args = parser.parse_args(sys.argv[1:])\n    if args.debug:\n        logger.setLevel(logging.DEBUG)\n    else:\n        sys.excepthook = excepthook\n\n    filelist = []\n    for pat in args.scripts:\n        if pat.endswith('.py'):\n            filelist.append(pat)\n        elif os.path.isdir(pat):\n            filelist.extend(glob.glob(os.path.join(pat, '*.py')))\n        else:\n            logger.warning('Ignore %s', pat)\n    filelist.sort()\n\n    random.seed()\n    sources = [make_c_source(x, extra=args.executable) for x in filelist]\n    sources = [x for x in sources if x]\n\n    if args.build:\n        make_extensions(sources, executable=args.executable)\n        if not args.debug:\n            [os.remove(x) for x in sources]\n\n    if args.inplace and sources:\n        logger.info('Remove obfuscated scripts')\n        [os.remove(x[:-2] + '.py') for x in sources]\n\n\nif __name__ == '__main__':\n    logging.basicConfig(level=logging.INFO)\n    main()\n\n\nFile: pyarmor/helper/build_data_module.py\n#! /usr/bin/env python\n'''This script could create a python module from data file, so that\nthe data file could be protected by PyArmor.\n\n1. First create data module from date file by this script\n\n    python build_data_module.py data.txt > data.py\n\n    Or\n\n    python -m pyarmor.helper.build_data_module data.txt > data.py\n\n2. Next obfuscate this data module with restrict mode 4\n\n    pyarmor obfuscate --exact --restrict 4 --no-runtime data.py\n\nAfter that, use the data file in other obfuscated scripts. For example,\n\n    import data\n\n    # Here load the content of data file to memory variable \"text\"\n    # And clear it from memory as exiting the context\n    with data.Safestr() as text:\n        ...\n\nThis script encodes the string data by a simple way (xor), DO NOT\ngenerate data module by this script directly. It's recommend to write\nyour own script to generate data module base on it or not.\n\n'''\nimport argparse\nimport logging\nimport random\nimport sys\n\nfrom os import makedirs\nfrom os.path import basename, exists, join as join_path, splitext\n\n#\n# The template of data module\n#\n# Do not yield key directly, because generator will not be obfuscated\n#\ntemplate = '''\ndef index(n):\n    rlist = range(n)\n    while 1:\n        for x in rlist:\n            yield x\n\n\nclass Safestr(object):\n\n    def __enter__(self):\n        key = {key}\n        i = index(len(key))\n        data = bytearray([x ^ key[next(i)] for x in bytearray(b\"\\\\x{data}\")])\n        self._value = data.decode({encoding})\n        return self._value\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        del self._value\n\n'''\n\n\ndef key(xlist):\n    while 1:\n        for x in xlist:\n            yield x\n\n\ndef build_module(filename, keylen=32, encoding=''):\n    with open(filename, 'rb') as f:\n        data = bytearray(f.read())\n    keylist = [random.randint(0, 255) for i in range(keylen)]\n\n    k = key(keylist)\n    s = r'\\x'.join(['%02x' % (x ^ next(k)) for x in data])\n    return template.format(data=s, key=str(keylist), encoding=encoding)\n\n\ndef main(argv):\n    parser = argparse.ArgumentParser(\n        prog='build-data-module',\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        description='Build data module from data file',\n    )\n    parser.add_argument('-n', '--key', default=32, type=int,\n                        help='length of key list used to xor data')\n    parser.add_argument('-c', '--encoding', help='encoding of data file')\n    parser.add_argument('-f', '--force', action='store_true',\n                        help='overwrite the exists module file')\n    parser.add_argument('-O', '--output', metavar='PATH',\n                        help='write data module here other than stdout')\n    parser.add_argument('files', metavar='FILE', nargs='+',\n                        help='data files')\n\n    args = parser.parse_args(argv)\n    encoding = repr(args.encoding) if args.encoding else ''\n\n    if args.output:\n        if not exists(args.output):\n            logging.info('Make output path: %s', args.output)\n            makedirs(args.output)\n\n        def output(filename, code):\n            name = splitext(basename(filename))[0] + '.py'\n            target = join_path(args.output, name)\n            if exists(target) and not args.force:\n                raise RuntimeError('Data module \"%s\" exists' % target)\n            logging.info('Write data module to \"%s\"', target)\n            with open(target, 'w') as f:\n                f.write(code)\n    else:\n        def output(filename, code):\n            print(code)\n\n    random.seed()\n    for filename in args.files:\n        code = build_module(filename, keylen=args.key, encoding=encoding)\n        output(filename, code)\n\n\nif __name__ == '__main__':\n    logging.basicConfig(\n        level=logging.INFO,\n        format='%(levelname)-8s %(message)s',\n    )\n    main(sys.argv[1:])\n\n\nFile: pyarmor/polyfills/__init__.py\n# Package pyarmor.polyfills\n\n\nFile: pyarmor/polyfills/argparse.py\n# Author: Steven J. Bethard <steven.bethard@gmail.com>.\n\n\"\"\"Command-line parsing library\n\nThis module is an optparse-inspired command-line parsing library that:\n\n    - handles both optional and positional arguments\n    - produces highly informative usage messages\n    - supports parsers that dispatch to sub-parsers\n\nThe following is a simple usage example that sums integers from the\ncommand-line and writes the result to a file::\n\n    parser = argparse.ArgumentParser(\n        description='sum the integers at the command line')\n    parser.add_argument(\n        'integers', metavar='int', nargs='+', type=int,\n        help='an integer to be summed')\n    parser.add_argument(\n        '--log', default=sys.stdout, type=argparse.FileType('w'),\n        help='the file where the sum should be written')\n    args = parser.parse_args()\n    args.log.write('%s' % sum(args.integers))\n    args.log.close()\n\nThe module contains the following public classes:\n\n    - ArgumentParser -- The main entry point for command-line parsing. As the\n        example above shows, the add_argument() method is used to populate\n        the parser with actions for optional and positional arguments. Then\n        the parse_args() method is invoked to convert the args at the\n        command-line into an object with attributes.\n\n    - ArgumentError -- The exception raised by ArgumentParser objects when\n        there are errors with the parser's actions. Errors raised while\n        parsing the command-line are caught by ArgumentParser and emitted\n        as command-line messages.\n\n    - FileType -- A factory for defining types of files to be created. As the\n        example above shows, instances of FileType are typically passed as\n        the type= argument of add_argument() calls.\n\n    - Action -- The base class for parser actions. Typically actions are\n        selected by passing strings like 'store_true' or 'append_const' to\n        the action= argument of add_argument(). However, for greater\n        customization of ArgumentParser actions, subclasses of Action may\n        be defined and passed as the action= argument.\n\n    - HelpFormatter, RawDescriptionHelpFormatter, RawTextHelpFormatter,\n        ArgumentDefaultsHelpFormatter -- Formatter classes which\n        may be passed as the formatter_class= argument to the\n        ArgumentParser constructor. HelpFormatter is the default,\n        RawDescriptionHelpFormatter and RawTextHelpFormatter tell the parser\n        not to change the formatting for help text, and\n        ArgumentDefaultsHelpFormatter adds information about argument defaults\n        to the help.\n\nAll other classes in this module are considered implementation details.\n(Also note that HelpFormatter and RawDescriptionHelpFormatter are only\nconsidered public as object names -- the API of the formatter objects is\nstill considered an implementation detail.)\n\"\"\"\n\n__version__ = '1.1'\n__all__ = [\n    'ArgumentParser',\n    'ArgumentError',\n    'ArgumentTypeError',\n    'FileType',\n    'HelpFormatter',\n    'ArgumentDefaultsHelpFormatter',\n    'RawDescriptionHelpFormatter',\n    'RawTextHelpFormatter',\n    'Namespace',\n    'Action',\n    'ONE_OR_MORE',\n    'OPTIONAL',\n    'PARSER',\n    'REMAINDER',\n    'SUPPRESS',\n    'ZERO_OR_MORE',\n]\n\n\nimport copy as _copy\nimport os as _os\nimport re as _re\nimport sys as _sys\nimport textwrap as _textwrap\n\nfrom gettext import gettext as _, ngettext\n\n\ndef _callable(obj):\n    return hasattr(obj, '__call__') or hasattr(obj, '__bases__')\n\n\nSUPPRESS = '==SUPPRESS=='\n\nOPTIONAL = '?'\nZERO_OR_MORE = '*'\nONE_OR_MORE = '+'\nPARSER = 'A...'\nREMAINDER = '...'\n_UNRECOGNIZED_ARGS_ATTR = '_unrecognized_args'\n\n# =============================\n# Utility functions and classes\n# =============================\n\nclass _AttributeHolder(object):\n    \"\"\"Abstract base class that provides __repr__.\n\n    The __repr__ method returns a string in the format::\n        ClassName(attr=name, attr=name, ...)\n    The attributes are determined either by a class-level attribute,\n    '_kwarg_names', or by inspecting the instance __dict__.\n    \"\"\"\n\n    def __repr__(self):\n        type_name = type(self).__name__\n        arg_strings = []\n        for arg in self._get_args():\n            arg_strings.append(repr(arg))\n        for name, value in self._get_kwargs():\n            arg_strings.append('%s=%r' % (name, value))\n        return '%s(%s)' % (type_name, ', '.join(arg_strings))\n\n    def _get_kwargs(self):\n        return sorted(self.__dict__.items())\n\n    def _get_args(self):\n        return []\n\n\ndef _ensure_value(namespace, name, value):\n    if getattr(namespace, name, None) is None:\n        setattr(namespace, name, value)\n    return getattr(namespace, name)\n\n\n# ===============\n# Formatting Help\n# ===============\n\nclass HelpFormatter(object):\n    \"\"\"Formatter for generating usage messages and argument help strings.\n\n    Only the name of this class is considered a public API. All the methods\n    provided by the class are considered an implementation detail.\n    \"\"\"\n\n    def __init__(self,\n                 prog,\n                 indent_increment=2,\n                 max_help_position=24,\n                 width=None):\n\n        # default setting for width\n        if width is None:\n            try:\n                width = int(_os.environ['COLUMNS'])\n            except (KeyError, ValueError):\n                width = 80\n            width -= 2\n\n        self._prog = prog\n        self._indent_increment = indent_increment\n        self._max_help_position = max_help_position\n        self._width = width\n\n        self._current_indent = 0\n        self._level = 0\n        self._action_max_length = 0\n\n        self._root_section = self._Section(self, None)\n        self._current_section = self._root_section\n\n        self._whitespace_matcher = _re.compile(r'\\s+')\n        self._long_break_matcher = _re.compile(r'\\n\\n\\n+')\n\n    # ===============================\n    # Section and indentation methods\n    # ===============================\n    def _indent(self):\n        self._current_indent += self._indent_increment\n        self._level += 1\n\n    def _dedent(self):\n        self._current_indent -= self._indent_increment\n        assert self._current_indent >= 0, 'Indent decreased below 0.'\n        self._level -= 1\n\n    class _Section(object):\n\n        def __init__(self, formatter, parent, heading=None):\n            self.formatter = formatter\n            self.parent = parent\n            self.heading = heading\n            self.items = []\n\n        def format_help(self):\n            # format the indented section\n            if self.parent is not None:\n                self.formatter._indent()\n            join = self.formatter._join_parts\n            for func, args in self.items:\n                func(*args)\n            item_help = join([func(*args) for func, args in self.items])\n            if self.parent is not None:\n                self.formatter._dedent()\n\n            # return nothing if the section was empty\n            if not item_help:\n                return ''\n\n            # add the heading if the section was non-empty\n            if self.heading is not SUPPRESS and self.heading is not None:\n                current_indent = self.formatter._current_indent\n                heading = '%*s%s:\\n' % (current_indent, '', self.heading)\n            else:\n                heading = ''\n\n            # join the section-initial newline, the heading and the help\n            return join(['\\n', heading, item_help, '\\n'])\n\n    def _add_item(self, func, args):\n        self._current_section.items.append((func, args))\n\n    # ========================\n    # Message building methods\n    # ========================\n    def start_section(self, heading):\n        self._indent()\n        section = self._Section(self, self._current_section, heading)\n        self._add_item(section.format_help, [])\n        self._current_section = section\n\n    def end_section(self):\n        self._current_section = self._current_section.parent\n        self._dedent()\n\n    def add_text(self, text):\n        if text is not SUPPRESS and text is not None:\n            self._add_item(self._format_text, [text])\n\n    def add_usage(self, usage, actions, groups, prefix=None):\n        if usage is not SUPPRESS:\n            args = usage, actions, groups, prefix\n            self._add_item(self._format_usage, args)\n\n    def add_argument(self, action):\n        if action.help is not SUPPRESS:\n\n            # find all invocations\n            get_invocation = self._format_action_invocation\n            invocations = [get_invocation(action)]\n            for subaction in self._iter_indented_subactions(action):\n                invocations.append(get_invocation(subaction))\n\n            # update the maximum item length\n            invocation_length = max([len(s) for s in invocations])\n            action_length = invocation_length + self._current_indent\n            self._action_max_length = max(self._action_max_length,\n                                          action_length)\n\n            # add the item to the list\n            self._add_item(self._format_action, [action])\n\n    def add_arguments(self, actions):\n        for action in actions:\n            self.add_argument(action)\n\n    # =======================\n    # Help-formatting methods\n    # =======================\n    def format_help(self):\n        help = self._root_section.format_help()\n        if help:\n            help = self._long_break_matcher.sub('\\n\\n', help)\n            help = help.strip('\\n') + '\\n'\n        return help\n\n    def _join_parts(self, part_strings):\n        return ''.join([part\n                        for part in part_strings\n                        if part and part is not SUPPRESS])\n\n    def _format_usage(self, usage, actions, groups, prefix):\n        if prefix is None:\n            prefix = _('usage: ')\n\n        # if usage is specified, use that\n        if usage is not None:\n            usage = usage % dict(prog=self._prog)\n\n        # if no optionals or positionals are available, usage is just prog\n        elif usage is None and not actions:\n            usage = '%(prog)s' % dict(prog=self._prog)\n\n        # if optionals and positionals are available, calculate usage\n        elif usage is None:\n            prog = '%(prog)s' % dict(prog=self._prog)\n\n            # split optionals from positionals\n            optionals = []\n            positionals = []\n            for action in actions:\n                if action.option_strings:\n                    optionals.append(action)\n                else:\n                    positionals.append(action)\n\n            # build full usage string\n            format = self._format_actions_usage\n            action_usage = format(optionals + positionals, groups)\n            usage = ' '.join([s for s in [prog, action_usage] if s])\n\n            # wrap the usage parts if it's too long\n            text_width = self._width - self._current_indent\n            if len(prefix) + len(usage) > text_width:\n\n                # break usage into wrappable parts\n                part_regexp = r'\\(.*?\\)+|\\[.*?\\]+|\\S+'\n                opt_usage = format(optionals, groups)\n                pos_usage = format(positionals, groups)\n                opt_parts = _re.findall(part_regexp, opt_usage)\n                pos_parts = _re.findall(part_regexp, pos_usage)\n                assert ' '.join(opt_parts) == opt_usage\n                assert ' '.join(pos_parts) == pos_usage\n\n                # helper for wrapping lines\n                def get_lines(parts, indent, prefix=None):\n                    lines = []\n                    line = []\n                    if prefix is not None:\n                        line_len = len(prefix) - 1\n                    else:\n                        line_len = len(indent) - 1\n                    for part in parts:\n                        if line_len + 1 + len(part) > text_width:\n                            lines.append(indent + ' '.join(line))\n                            line = []\n                            line_len = len(indent) - 1\n                        line.append(part)\n                        line_len += len(part) + 1\n                    if line:\n                        lines.append(indent + ' '.join(line))\n                    if prefix is not None:\n                        lines[0] = lines[0][len(indent):]\n                    return lines\n\n                # if prog is short, follow it with optionals or positionals\n                if len(prefix) + len(prog) <= 0.75 * text_width:\n                    indent = ' ' * (len(prefix) + len(prog) + 1)\n                    if opt_parts:\n                        lines = get_lines([prog] + opt_parts, indent, prefix)\n                        lines.extend(get_lines(pos_parts, indent))\n                    elif pos_parts:\n                        lines = get_lines([prog] + pos_parts, indent, prefix)\n                    else:\n                        lines = [prog]\n\n                # if prog is long, put it on its own line\n                else:\n                    indent = ' ' * len(prefix)\n                    parts = opt_parts + pos_parts\n                    lines = get_lines(parts, indent)\n                    if len(lines) > 1:\n                        lines = []\n                        lines.extend(get_lines(opt_parts, indent))\n                        lines.extend(get_lines(pos_parts, indent))\n                    lines = [prog] + lines\n\n                # join lines into usage\n                usage = '\\n'.join(lines)\n\n        # prefix with 'usage:'\n        return '%s%s\\n\\n' % (prefix, usage)\n\n    def _format_actions_usage(self, actions, groups):\n        # find group indices and identify actions in groups\n        group_actions = set()\n        inserts = {}\n        for group in groups:\n            try:\n                start = actions.index(group._group_actions[0])\n            except ValueError:\n                continue\n            else:\n                end = start + len(group._group_actions)\n                if actions[start:end] == group._group_actions:\n                    for action in group._group_actions:\n                        group_actions.add(action)\n                    if not group.required:\n                        if start in inserts:\n                            inserts[start] += ' ['\n                        else:\n                            inserts[start] = '['\n                        inserts[end] = ']'\n                    else:\n                        if start in inserts:\n                            inserts[start] += ' ('\n                        else:\n                            inserts[start] = '('\n                        inserts[end] = ')'\n                    for i in range(start + 1, end):\n                        inserts[i] = '|'\n\n        # collect all actions format strings\n        parts = []\n        for i, action in enumerate(actions):\n\n            # suppressed arguments are marked with None\n            # remove | separators for suppressed arguments\n            if action.help is SUPPRESS:\n                parts.append(None)\n                if inserts.get(i) == '|':\n                    inserts.pop(i)\n                elif inserts.get(i + 1) == '|':\n                    inserts.pop(i + 1)\n\n            # produce all arg strings\n            elif not action.option_strings:\n                part = self._format_args(action, action.dest)\n\n                # if it's in a group, strip the outer []\n                if action in group_actions:\n                    if part[0] == '[' and part[-1] == ']':\n                        part = part[1:-1]\n\n                # add the action string to the list\n                parts.append(part)\n\n            # produce the first way to invoke the option in brackets\n            else:\n                option_string = action.option_strings[0]\n\n                # if the Optional doesn't take a value, format is:\n                #    -s or --long\n                if action.nargs == 0:\n                    part = '%s' % option_string\n\n                # if the Optional takes a value, format is:\n                #    -s ARGS or --long ARGS\n                else:\n                    default = action.dest.upper()\n                    args_string = self._format_args(action, default)\n                    part = '%s %s' % (option_string, args_string)\n\n                # make it look optional if it's not required or in a group\n                if not action.required and action not in group_actions:\n                    part = '[%s]' % part\n\n                # add the action string to the list\n                parts.append(part)\n\n        # insert things at the necessary indices\n        for i in sorted(inserts, reverse=True):\n            parts[i:i] = [inserts[i]]\n\n        # join all the action items with spaces\n        text = ' '.join([item for item in parts if item is not None])\n\n        # clean up separators for mutually exclusive groups\n        open = r'[\\[(]'\n        close = r'[\\])]'\n        text = _re.sub(r'(%s) ' % open, r'\\1', text)\n        text = _re.sub(r' (%s)' % close, r'\\1', text)\n        text = _re.sub(r'%s *%s' % (open, close), r'', text)\n        text = _re.sub(r'\\(([^|]*)\\)', r'\\1', text)\n        text = text.strip()\n\n        # return the text\n        return text\n\n    def _format_text(self, text):\n        if '%(prog)' in text:\n            text = text % dict(prog=self._prog)\n        text_width = self._width - self._current_indent\n        indent = ' ' * self._current_indent\n        return self._fill_text(text, text_width, indent) + '\\n\\n'\n\n    def _format_action(self, action):\n        # determine the required width and the entry label\n        help_position = min(self._action_max_length + 2,\n                            self._max_help_position)\n        help_width = self._width - help_position\n        action_width = help_position - self._current_indent - 2\n        action_header = self._format_action_invocation(action)\n\n        # ho nelp; start on same line and add a final newline\n        if not action.help:\n            tup = self._current_indent, '', action_header\n            action_header = '%*s%s\\n' % tup\n\n        # short action name; start on the same line and pad two spaces\n        elif len(action_header) <= action_width:\n            tup = self._current_indent, '', action_width, action_header\n            action_header = '%*s%-*s  ' % tup\n            indent_first = 0\n\n        # long action name; start on the next line\n        else:\n            tup = self._current_indent, '', action_header\n            action_header = '%*s%s\\n' % tup\n            indent_first = help_position\n\n        # collect the pieces of the action help\n        parts = [action_header]\n\n        # if there was help for the action, add lines of help text\n        if action.help:\n            help_text = self._expand_help(action)\n            help_lines = self._split_lines(help_text, help_width)\n            parts.append('%*s%s\\n' % (indent_first, '', help_lines[0]))\n            for line in help_lines[1:]:\n                parts.append('%*s%s\\n' % (help_position, '', line))\n\n        # or add a newline if the description doesn't end with one\n        elif not action_header.endswith('\\n'):\n            parts.append('\\n')\n\n        # if there are any sub-actions, add their help as well\n        for subaction in self._iter_indented_subactions(action):\n            parts.append(self._format_action(subaction))\n\n        # return a single string\n        return self._join_parts(parts)\n\n    def _format_action_invocation(self, action):\n        if not action.option_strings:\n            metavar, = self._metavar_formatter(action, action.dest)(1)\n            return metavar\n\n        else:\n            parts = []\n\n            # if the Optional doesn't take a value, format is:\n            #    -s, --long\n            if action.nargs == 0:\n                parts.extend(action.option_strings)\n\n            # if the Optional takes a value, format is:\n            #    -s ARGS, --long ARGS\n            else:\n                default = action.dest.upper()\n                args_string = self._format_args(action, default)\n                for option_string in action.option_strings:\n                    parts.append('%s %s' % (option_string, args_string))\n\n            return ', '.join(parts)\n\n    def _metavar_formatter(self, action, default_metavar):\n        if action.metavar is not None:\n            result = action.metavar\n        elif action.choices is not None:\n            choice_strs = [str(choice) for choice in action.choices]\n            result = '{%s}' % ','.join(choice_strs)\n        else:\n            result = default_metavar\n\n        def format(tuple_size):\n            if isinstance(result, tuple):\n                return result\n            else:\n                return (result, ) * tuple_size\n        return format\n\n    def _format_args(self, action, default_metavar):\n        get_metavar = self._metavar_formatter(action, default_metavar)\n        if action.nargs is None:\n            result = '%s' % get_metavar(1)\n        elif action.nargs == OPTIONAL:\n            result = '[%s]' % get_metavar(1)\n        elif action.nargs == ZERO_OR_MORE:\n            result = '[%s [%s ...]]' % get_metavar(2)\n        elif action.nargs == ONE_OR_MORE:\n            result = '%s [%s ...]' % get_metavar(2)\n        elif action.nargs == REMAINDER:\n            result = '...'\n        elif action.nargs == PARSER:\n            result = '%s ...' % get_metavar(1)\n        else:\n            formats = ['%s' for _ in range(action.nargs)]\n            result = ' '.join(formats) % get_metavar(action.nargs)\n        return result\n\n    def _expand_help(self, action):\n        params = dict(vars(action), prog=self._prog)\n        for name in list(params):\n            if params[name] is SUPPRESS:\n                del params[name]\n        for name in list(params):\n            if hasattr(params[name], '__name__'):\n                params[name] = params[name].__name__\n        if params.get('choices') is not None:\n            choices_str = ', '.join([str(c) for c in params['choices']])\n            params['choices'] = choices_str\n        return self._get_help_string(action) % params\n\n    def _iter_indented_subactions(self, action):\n        try:\n            get_subactions = action._get_subactions\n        except AttributeError:\n            pass\n        else:\n            self._indent()\n            for subaction in get_subactions():\n                yield subaction\n            self._dedent()\n\n    def _split_lines(self, text, width):\n        text = self._whitespace_matcher.sub(' ', text).strip()\n        return _textwrap.wrap(text, width)\n\n    def _fill_text(self, text, width, indent):\n        text = self._whitespace_matcher.sub(' ', text).strip()\n        return _textwrap.fill(text, width, initial_indent=indent,\n                                           subsequent_indent=indent)\n\n    def _get_help_string(self, action):\n        return action.help\n\n\nclass RawDescriptionHelpFormatter(HelpFormatter):\n    \"\"\"Help message formatter which retains any formatting in descriptions.\n\n    Only the name of this class is considered a public API. All the methods\n    provided by the class are considered an implementation detail.\n    \"\"\"\n\n    def _fill_text(self, text, width, indent):\n        return ''.join([indent + line for line in text.splitlines(True)])\n\n\nclass RawTextHelpFormatter(RawDescriptionHelpFormatter):\n    \"\"\"Help message formatter which retains formatting of all help text.\n\n    Only the name of this class is considered a public API. All the methods\n    provided by the class are considered an implementation detail.\n    \"\"\"\n\n    def _split_lines(self, text, width):\n        return text.splitlines()\n\n\nclass ArgumentDefaultsHelpFormatter(HelpFormatter):\n    \"\"\"Help message formatter which adds default values to argument help.\n\n    Only the name of this class is considered a public API. All the methods\n    provided by the class are considered an implementation detail.\n    \"\"\"\n\n    def _get_help_string(self, action):\n        help = action.help\n        if '%(default)' not in action.help:\n            if action.default is not SUPPRESS:\n                defaulting_nargs = [OPTIONAL, ZERO_OR_MORE]\n                if action.option_strings or action.nargs in defaulting_nargs:\n                    help += ' (default: %(default)s)'\n        return help\n\n\n# =====================\n# Options and Arguments\n# =====================\n\ndef _get_action_name(argument):\n    if argument is None:\n        return None\n    elif argument.option_strings:\n        return  '/'.join(argument.option_strings)\n    elif argument.metavar not in (None, SUPPRESS):\n        return argument.metavar\n    elif argument.dest not in (None, SUPPRESS):\n        return argument.dest\n    else:\n        return None\n\n\nclass ArgumentError(Exception):\n    \"\"\"An error from creating or using an argument (optional or positional).\n\n    The string value of this exception is the message, augmented with\n    information about the argument that caused it.\n    \"\"\"\n\n    def __init__(self, argument, message):\n        self.argument_name = _get_action_name(argument)\n        self.message = message\n\n    def __str__(self):\n        if self.argument_name is None:\n            format = '%(message)s'\n        else:\n            format = 'argument %(argument_name)s: %(message)s'\n        return format % dict(message=self.message,\n                             argument_name=self.argument_name)\n\n\nclass ArgumentTypeError(Exception):\n    \"\"\"An error from trying to convert a command line string to a type.\"\"\"\n    pass\n\n\n# ==============\n# Action classes\n# ==============\n\nclass Action(_AttributeHolder):\n    \"\"\"Information about how to convert command line strings to Python objects.\n\n    Action objects are used by an ArgumentParser to represent the information\n    needed to parse a single argument from one or more strings from the\n    command line. The keyword arguments to the Action constructor are also\n    all attributes of Action instances.\n\n    Keyword Arguments:\n\n        - option_strings -- A list of command-line option strings which\n            should be associated with this action.\n\n        - dest -- The name of the attribute to hold the created object(s)\n\n        - nargs -- The number of command-line arguments that should be\n            consumed. By default, one argument will be consumed and a single\n            value will be produced.  Other values include:\n                - N (an integer) consumes N arguments (and produces a list)\n                - '?' consumes zero or one arguments\n                - '*' consumes zero or more arguments (and produces a list)\n                - '+' consumes one or more arguments (and produces a list)\n            Note that the difference between the default and nargs=1 is that\n            with the default, a single value will be produced, while with\n            nargs=1, a list containing a single value will be produced.\n\n        - const -- The value to be produced if the option is specified and the\n            option uses an action that takes no values.\n\n        - default -- The value to be produced if the option is not specified.\n\n        - type -- The type which the command-line arguments should be converted\n            to, should be one of 'string', 'int', 'float', 'complex' or a\n            callable object that accepts a single string argument. If None,\n            'string' is assumed.\n\n        - choices -- A container of values that should be allowed. If not None,\n            after a command-line argument has been converted to the appropriate\n            type, an exception will be raised if it is not a member of this\n            collection.\n\n        - required -- True if the action must always be specified at the\n            command line. This is only meaningful for optional command-line\n            arguments.\n\n        - help -- The help string describing the argument.\n\n        - metavar -- The name to be used for the option's argument with the\n            help string. If None, the 'dest' value will be used as the name.\n    \"\"\"\n\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 nargs=None,\n                 const=None,\n                 default=None,\n                 type=None,\n                 choices=None,\n                 required=False,\n                 help=None,\n                 metavar=None):\n        self.option_strings = option_strings\n        self.dest = dest\n        self.nargs = nargs\n        self.const = const\n        self.default = default\n        self.type = type\n        self.choices = choices\n        self.required = required\n        self.help = help\n        self.metavar = metavar\n\n    def _get_kwargs(self):\n        names = [\n            'option_strings',\n            'dest',\n            'nargs',\n            'const',\n            'default',\n            'type',\n            'choices',\n            'help',\n            'metavar',\n        ]\n        return [(name, getattr(self, name)) for name in names]\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        raise NotImplementedError(_('.__call__() not defined'))\n\n\nclass _StoreAction(Action):\n\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 nargs=None,\n                 const=None,\n                 default=None,\n                 type=None,\n                 choices=None,\n                 required=False,\n                 help=None,\n                 metavar=None):\n        if nargs == 0:\n            raise ValueError('nargs for store actions must be > 0; if you '\n                             'have nothing to store, actions such as store '\n                             'true or store const may be more appropriate')\n        if const is not None and nargs != OPTIONAL:\n            raise ValueError('nargs must be %r to supply const' % OPTIONAL)\n        super(_StoreAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            nargs=nargs,\n            const=const,\n            default=default,\n            type=type,\n            choices=choices,\n            required=required,\n            help=help,\n            metavar=metavar)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        setattr(namespace, self.dest, values)\n\n\nclass _StoreConstAction(Action):\n\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 const,\n                 default=None,\n                 required=False,\n                 help=None,\n                 metavar=None):\n        super(_StoreConstAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            nargs=0,\n            const=const,\n            default=default,\n            required=required,\n            help=help)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        setattr(namespace, self.dest, self.const)\n\n\nclass _StoreTrueAction(_StoreConstAction):\n\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 default=False,\n                 required=False,\n                 help=None):\n        super(_StoreTrueAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            const=True,\n            default=default,\n            required=required,\n            help=help)\n\n\nclass _StoreFalseAction(_StoreConstAction):\n\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 default=True,\n                 required=False,\n                 help=None):\n        super(_StoreFalseAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            const=False,\n            default=default,\n            required=required,\n            help=help)\n\n\nclass _AppendAction(Action):\n\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 nargs=None,\n                 const=None,\n                 default=None,\n                 type=None,\n                 choices=None,\n                 required=False,\n                 help=None,\n                 metavar=None):\n        if nargs == 0:\n            raise ValueError('nargs for append actions must be > 0; if arg '\n                             'strings are not supplying the value to append, '\n                             'the append const action may be more appropriate')\n        if const is not None and nargs != OPTIONAL:\n            raise ValueError('nargs must be %r to supply const' % OPTIONAL)\n        super(_AppendAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            nargs=nargs,\n            const=const,\n            default=default,\n            type=type,\n            choices=choices,\n            required=required,\n            help=help,\n            metavar=metavar)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        items = _copy.copy(_ensure_value(namespace, self.dest, []))\n        items.append(values)\n        setattr(namespace, self.dest, items)\n\n\nclass _AppendConstAction(Action):\n\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 const,\n                 default=None,\n                 required=False,\n                 help=None,\n                 metavar=None):\n        super(_AppendConstAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            nargs=0,\n            const=const,\n            default=default,\n            required=required,\n            help=help,\n            metavar=metavar)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        items = _copy.copy(_ensure_value(namespace, self.dest, []))\n        items.append(self.const)\n        setattr(namespace, self.dest, items)\n\n\nclass _CountAction(Action):\n\n    def __init__(self,\n                 option_strings,\n                 dest,\n                 default=None,\n                 required=False,\n                 help=None):\n        super(_CountAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            nargs=0,\n            default=default,\n            required=required,\n            help=help)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        new_count = _ensure_value(namespace, self.dest, 0) + 1\n        setattr(namespace, self.dest, new_count)\n\n\nclass _HelpAction(Action):\n\n    def __init__(self,\n                 option_strings,\n                 dest=SUPPRESS,\n                 default=SUPPRESS,\n                 help=None):\n        super(_HelpAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            default=default,\n            nargs=0,\n            help=help)\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        parser.print_help()\n        parser.exit()\n\n\nclass _VersionAction(Action):\n\n    def __init__(self,\n                 option_strings,\n                 version=None,\n                 dest=SUPPRESS,\n                 default=SUPPRESS,\n                 help=\"show program's version number and exit\"):\n        super(_VersionAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            default=default,\n            nargs=0,\n            help=help)\n        self.version = version\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        version = self.version\n        if version is None:\n            version = parser.version\n        elif hasattr(version, '__name__'):\n            version = version()\n        formatter = parser._get_formatter()\n        formatter.add_text(version)\n        parser.exit(message=formatter.format_help())\n\n\nclass _SubParsersAction(Action):\n\n    class _ChoicesPseudoAction(Action):\n\n        def __init__(self, name, aliases, help):\n            metavar = dest = name\n            if aliases:\n                metavar += ' (%s)' % ', '.join(aliases)\n            sup = super(_SubParsersAction._ChoicesPseudoAction, self)\n            sup.__init__(option_strings=[], dest=dest, help=help,\n                         metavar=metavar)\n\n    def __init__(self,\n                 option_strings,\n                 prog,\n                 parser_class,\n                 dest=SUPPRESS,\n                 help=None,\n                 metavar=None):\n\n        self._prog_prefix = prog\n        self._parser_class = parser_class\n        self._name_parser_map = {}\n        self._choices_actions = []\n\n        super(_SubParsersAction, self).__init__(\n            option_strings=option_strings,\n            dest=dest,\n            nargs=PARSER,\n            choices=self._name_parser_map,\n            help=help,\n            metavar=metavar)\n\n    def add_parser(self, name, **kwargs):\n        # set prog from the existing prefix\n        if kwargs.get('prog') is None:\n            kwargs['prog'] = '%s %s' % (self._prog_prefix, name)\n\n        aliases = kwargs.pop('aliases', ())\n\n        # create a pseudo-action to hold the choice help\n        if 'help' in kwargs:\n            help = kwargs.pop('help')\n            choice_action = self._ChoicesPseudoAction(name, aliases, help)\n            self._choices_actions.append(choice_action)\n\n        # create the parser and add it to the map\n        parser = self._parser_class(**kwargs)\n        self._name_parser_map[name] = parser\n\n        # make parser available under aliases also\n        for alias in aliases:\n            self._name_parser_map[alias] = parser\n\n        return parser\n\n    def _get_subactions(self):\n        return self._choices_actions\n\n    def __call__(self, parser, namespace, values, option_string=None):\n        parser_name = values[0]\n        arg_strings = values[1:]\n\n        # set the parser name if requested\n        if self.dest is not SUPPRESS:\n            setattr(namespace, self.dest, parser_name)\n\n        # select the parser\n        try:\n            parser = self._name_parser_map[parser_name]\n        except KeyError:\n            args = {'parser_name': parser_name,\n                    'choices': ', '.join(self._name_parser_map)}\n            msg = _('unknown parser %(parser_name)r (choices: %(choices)s)') % args\n            raise ArgumentError(self, msg)\n\n        # parse all the remaining options into the namespace\n        # store any unrecognized options on the object, so that the top\n        # level parser can decide what to do with them\n        namespace, arg_strings = parser.parse_known_args(arg_strings, namespace)\n        if arg_strings:\n            vars(namespace).setdefault(_UNRECOGNIZED_ARGS_ATTR, [])\n            getattr(namespace, _UNRECOGNIZED_ARGS_ATTR).extend(arg_strings)\n\n\n# ==============\n# Type classes\n# ==============\n\nclass FileType(object):\n    \"\"\"Factory for creating file object types\n\n    Instances of FileType are typically passed as type= arguments to the\n    ArgumentParser add_argument() method.\n\n    Keyword Arguments:\n        - mode -- A string indicating how the file is to be opened. Accepts the\n            same values as the builtin open() function.\n        - bufsize -- The file's desired buffer size. Accepts the same values as\n            the builtin open() function.\n    \"\"\"\n\n    def __init__(self, mode='r', bufsize=-1):\n        self._mode = mode\n        self._bufsize = bufsize\n\n    def __call__(self, string):\n        # the special argument \"-\" means sys.std{in,out}\n        if string == '-':\n            if 'r' in self._mode:\n                return _sys.stdin\n            elif 'w' in self._mode:\n                return _sys.stdout\n            else:\n                msg = _('argument \"-\" with mode %r') % self._mode\n                raise ValueError(msg)\n\n        # all other arguments are used as file names\n        try:\n            return open(string, self._mode, self._bufsize)\n        except IOError as e:\n            message = _(\"can't open '%s': %s\")\n            raise ArgumentTypeError(message % (string, e))\n\n    def __repr__(self):\n        args = self._mode, self._bufsize\n        args_str = ', '.join(repr(arg) for arg in args if arg != -1)\n        return '%s(%s)' % (type(self).__name__, args_str)\n\n# ===========================\n# Optional and Positional Parsing\n# ===========================\n\nclass Namespace(_AttributeHolder):\n    \"\"\"Simple object for storing attributes.\n\n    Implements equality by attribute names and values, and provides a simple\n    string representation.\n    \"\"\"\n\n    def __init__(self, **kwargs):\n        for name in kwargs:\n            setattr(self, name, kwargs[name])\n\n    def __eq__(self, other):\n        return vars(self) == vars(other)\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __contains__(self, key):\n        return key in self.__dict__\n\n\nclass _ActionsContainer(object):\n\n    def __init__(self,\n                 description,\n                 prefix_chars,\n                 argument_default,\n                 conflict_handler):\n        super(_ActionsContainer, self).__init__()\n\n        self.description = description\n        self.argument_default = argument_default\n        self.prefix_chars = prefix_chars\n        self.conflict_handler = conflict_handler\n\n        # set up registries\n        self._registries = {}\n\n        # register actions\n        self.register('action', None, _StoreAction)\n        self.register('action', 'store', _StoreAction)\n        self.register('action', 'store_const', _StoreConstAction)\n        self.register('action', 'store_true', _StoreTrueAction)\n        self.register('action', 'store_false', _StoreFalseAction)\n        self.register('action', 'append', _AppendAction)\n        self.register('action', 'append_const', _AppendConstAction)\n        self.register('action', 'count', _CountAction)\n        self.register('action', 'help', _HelpAction)\n        self.register('action', 'version', _VersionAction)\n        self.register('action', 'parsers', _SubParsersAction)\n\n        # raise an exception if the conflict handler is invalid\n        self._get_handler()\n\n        # action storage\n        self._actions = []\n        self._option_string_actions = {}\n\n        # groups\n        self._action_groups = []\n        self._mutually_exclusive_groups = []\n\n        # defaults storage\n        self._defaults = {}\n\n        # determines whether an \"option\" looks like a negative number\n        self._negative_number_matcher = _re.compile(r'^-\\d+$|^-\\d*\\.\\d+$')\n\n        # whether or not there are any optionals that look like negative\n        # numbers -- uses a list so it can be shared and edited\n        self._has_negative_number_optionals = []\n\n    # ====================\n    # Registration methods\n    # ====================\n    def register(self, registry_name, value, object):\n        registry = self._registries.setdefault(registry_name, {})\n        registry[value] = object\n\n    def _registry_get(self, registry_name, value, default=None):\n        return self._registries[registry_name].get(value, default)\n\n    # ==================================\n    # Namespace default accessor methods\n    # ==================================\n    def set_defaults(self, **kwargs):\n        self._defaults.update(kwargs)\n\n        # if these defaults match any existing arguments, replace\n        # the previous default on the object with the new one\n        for action in self._actions:\n            if action.dest in kwargs:\n                action.default = kwargs[action.dest]\n\n    def get_default(self, dest):\n        for action in self._actions:\n            if action.dest == dest and action.default is not None:\n                return action.default\n        return self._defaults.get(dest, None)\n\n\n    # =======================\n    # Adding argument actions\n    # =======================\n    def add_argument(self, *args, **kwargs):\n        \"\"\"\n        add_argument(dest, ..., name=value, ...)\n        add_argument(option_string, option_string, ..., name=value, ...)\n        \"\"\"\n\n        # if no positional args are supplied or only one is supplied and\n        # it doesn't look like an option string, parse a positional\n        # argument\n        chars = self.prefix_chars\n        if not args or len(args) == 1 and args[0][0] not in chars:\n            if args and 'dest' in kwargs:\n                raise ValueError('dest supplied twice for positional argument')\n            kwargs = self._get_positional_kwargs(*args, **kwargs)\n\n        # otherwise, we're adding an optional argument\n        else:\n            kwargs = self._get_optional_kwargs(*args, **kwargs)\n\n        # if no default was supplied, use the parser-level default\n        if 'default' not in kwargs:\n            dest = kwargs['dest']\n            if dest in self._defaults:\n                kwargs['default'] = self._defaults[dest]\n            elif self.argument_default is not None:\n                kwargs['default'] = self.argument_default\n\n        # create the action object, and add it to the parser\n        action_class = self._pop_action_class(kwargs)\n        if not _callable(action_class):\n            raise ValueError('unknown action \"%s\"' % action_class)\n        action = action_class(**kwargs)\n\n        # raise an error if the action type is not callable\n        type_func = self._registry_get('type', action.type, action.type)\n        if not _callable(type_func):\n            raise ValueError('%r is not callable' % type_func)\n\n        return self._add_action(action)\n\n    def add_argument_group(self, *args, **kwargs):\n        group = _ArgumentGroup(self, *args, **kwargs)\n        self._action_groups.append(group)\n        return group\n\n    def add_mutually_exclusive_group(self, **kwargs):\n        group = _MutuallyExclusiveGroup(self, **kwargs)\n        self._mutually_exclusive_groups.append(group)\n        return group\n\n    def _add_action(self, action):\n        # resolve any conflicts\n        self._check_conflict(action)\n\n        # add to actions list\n        self._actions.append(action)\n        action.container = self\n\n        # index the action by any option strings it has\n        for option_string in action.option_strings:\n            self._option_string_actions[option_string] = action\n\n        # set the flag if any option strings look like negative numbers\n        for option_string in action.option_strings:\n            if self._negative_number_matcher.match(option_string):\n                if not self._has_negative_number_optionals:\n                    self._has_negative_number_optionals.append(True)\n\n        # return the created action\n        return action\n\n    def _remove_action(self, action):\n        self._actions.remove(action)\n\n    def _add_container_actions(self, container):\n        # collect groups by titles\n        title_group_map = {}\n        for group in self._action_groups:\n            if group.title in title_group_map:\n                msg = _('cannot merge actions - two groups are named %r')\n                raise ValueError(msg % (group.title))\n            title_group_map[group.title] = group\n\n        # map each action to its group\n        group_map = {}\n        for group in container._action_groups:\n\n            # if a group with the title exists, use that, otherwise\n            # create a new group matching the container's group\n            if group.title not in title_group_map:\n                title_group_map[group.title] = self.add_argument_group(\n                    title=group.title,\n                    description=group.description,\n                    conflict_handler=group.conflict_handler)\n\n            # map the actions to their new group\n            for action in group._group_actions:\n                group_map[action] = title_group_map[group.title]\n\n        # add container's mutually exclusive groups\n        # NOTE: if add_mutually_exclusive_group ever gains title= and\n        # description= then this code will need to be expanded as above\n        for group in container._mutually_exclusive_groups:\n            mutex_group = self.add_mutually_exclusive_group(\n                required=group.required)\n\n            # map the actions to their new mutex group\n            for action in group._group_actions:\n                group_map[action] = mutex_group\n\n        # add all actions to this container or their group\n        for action in container._actions:\n            group_map.get(action, self)._add_action(action)\n\n    def _get_positional_kwargs(self, dest, **kwargs):\n        # make sure required is not specified\n        if 'required' in kwargs:\n            msg = _(\"'required' is an invalid argument for positionals\")\n            raise TypeError(msg)\n\n        # mark positional arguments as required if at least one is\n        # always required\n        if kwargs.get('nargs') not in [OPTIONAL, ZERO_OR_MORE]:\n            kwargs['required'] = True\n        if kwargs.get('nargs') == ZERO_OR_MORE and 'default' not in kwargs:\n            kwargs['required'] = True\n\n        # return the keyword arguments with no option strings\n        return dict(kwargs, dest=dest, option_strings=[])\n\n    def _get_optional_kwargs(self, *args, **kwargs):\n        # determine short and long option strings\n        option_strings = []\n        long_option_strings = []\n        for option_string in args:\n            # error on strings that don't start with an appropriate prefix\n            if not option_string[0] in self.prefix_chars:\n                args = {'option': option_string,\n                        'prefix_chars': self.prefix_chars}\n                msg = _('invalid option string %(option)r: '\n                        'must start with a character %(prefix_chars)r')\n                raise ValueError(msg % args)\n\n            # strings starting with two prefix characters are long options\n            option_strings.append(option_string)\n            if option_string[0] in self.prefix_chars:\n                if len(option_string) > 1:\n                    if option_string[1] in self.prefix_chars:\n                        long_option_strings.append(option_string)\n\n        # infer destination, '--foo-bar' -> 'foo_bar' and '-x' -> 'x'\n        dest = kwargs.pop('dest', None)\n        if dest is None:\n            if long_option_strings:\n                dest_option_string = long_option_strings[0]\n            else:\n                dest_option_string = option_strings[0]\n            dest = dest_option_string.lstrip(self.prefix_chars)\n            if not dest:\n                msg = _('dest= is required for options like %r')\n                raise ValueError(msg % option_string)\n            dest = dest.replace('-', '_')\n\n        # return the updated keyword arguments\n        return dict(kwargs, dest=dest, option_strings=option_strings)\n\n    def _pop_action_class(self, kwargs, default=None):\n        action = kwargs.pop('action', default)\n        return self._registry_get('action', action, action)\n\n    def _get_handler(self):\n        # determine function from conflict handler string\n        handler_func_name = '_handle_conflict_%s' % self.conflict_handler\n        try:\n            return getattr(self, handler_func_name)\n        except AttributeError:\n            msg = _('invalid conflict_resolution value: %r')\n            raise ValueError(msg % self.conflict_handler)\n\n    def _check_conflict(self, action):\n\n        # find all options that conflict with this option\n        confl_optionals = []\n        for option_string in action.option_strings:\n            if option_string in self._option_string_actions:\n                confl_optional = self._option_string_actions[option_string]\n                confl_optionals.append((option_string, confl_optional))\n\n        # resolve any conflicts\n        if confl_optionals:\n            conflict_handler = self._get_handler()\n            conflict_handler(action, confl_optionals)\n\n    def _handle_conflict_error(self, action, conflicting_actions):\n        message = ngettext('conflicting option string: %s',\n                           'conflicting option strings: %s',\n                           len(conflicting_actions))\n        conflict_string = ', '.join([option_string\n                                     for option_string, action\n                                     in conflicting_actions])\n        raise ArgumentError(action, message % conflict_string)\n\n    def _handle_conflict_resolve(self, action, conflicting_actions):\n\n        # remove all conflicting options\n        for option_string, action in conflicting_actions:\n\n            # remove the conflicting option\n            action.option_strings.remove(option_string)\n            self._option_string_actions.pop(option_string, None)\n\n            # if the option now has no option string, remove it from the\n            # container holding it\n            if not action.option_strings:\n                action.container._remove_action(action)\n\n\nclass _ArgumentGroup(_ActionsContainer):\n\n    def __init__(self, container, title=None, description=None, **kwargs):\n        # add any missing keyword arguments by checking the container\n        update = kwargs.setdefault\n        update('conflict_handler', container.conflict_handler)\n        update('prefix_chars', container.prefix_chars)\n        update('argument_default', container.argument_default)\n        super_init = super(_ArgumentGroup, self).__init__\n        super_init(description=description, **kwargs)\n\n        # group attributes\n        self.title = title\n        self._group_actions = []\n\n        # share most attributes with the container\n        self._registries = container._registries\n        self._actions = container._actions\n        self._option_string_actions = container._option_string_actions\n        self._defaults = container._defaults\n        self._has_negative_number_optionals = \\\n            container._has_negative_number_optionals\n        self._mutually_exclusive_groups = container._mutually_exclusive_groups\n\n    def _add_action(self, action):\n        action = super(_ArgumentGroup, self)._add_action(action)\n        self._group_actions.append(action)\n        return action\n\n    def _remove_action(self, action):\n        super(_ArgumentGroup, self)._remove_action(action)\n        self._group_actions.remove(action)\n\n\nclass _MutuallyExclusiveGroup(_ArgumentGroup):\n\n    def __init__(self, container, required=False):\n        super(_MutuallyExclusiveGroup, self).__init__(container)\n        self.required = required\n        self._container = container\n\n    def _add_action(self, action):\n        if action.required:\n            msg = _('mutually exclusive arguments must be optional')\n            raise ValueError(msg)\n        action = self._container._add_action(action)\n        self._group_actions.append(action)\n        return action\n\n    def _remove_action(self, action):\n        self._container._remove_action(action)\n        self._group_actions.remove(action)\n\n\nclass ArgumentParser(_AttributeHolder, _ActionsContainer):\n    \"\"\"Object for parsing command line strings into Python objects.\n\n    Keyword Arguments:\n        - prog -- The name of the program (default: sys.argv[0])\n        - usage -- A usage message (default: auto-generated from arguments)\n        - description -- A description of what the program does\n        - epilog -- Text following the argument descriptions\n        - parents -- Parsers whose arguments should be copied into this one\n        - formatter_class -- HelpFormatter class for printing help messages\n        - prefix_chars -- Characters that prefix optional arguments\n        - fromfile_prefix_chars -- Characters that prefix files containing\n            additional arguments\n        - argument_default -- The default value for all arguments\n        - conflict_handler -- String indicating how to handle conflicts\n        - add_help -- Add a -h/-help option\n    \"\"\"\n\n    def __init__(self,\n                 prog=None,\n                 usage=None,\n                 description=None,\n                 epilog=None,\n                 version=None,\n                 parents=[],\n                 formatter_class=HelpFormatter,\n                 prefix_chars='-',\n                 fromfile_prefix_chars=None,\n                 argument_default=None,\n                 conflict_handler='error',\n                 add_help=True):\n\n        if version is not None:\n            import warnings\n            warnings.warn(\n                \"\"\"The \"version\" argument to ArgumentParser is deprecated. \"\"\"\n                \"\"\"Please use \"\"\"\n                \"\"\"\"add_argument(..., action='version', version=\"N\", ...)\" \"\"\"\n                \"\"\"instead\"\"\", DeprecationWarning)\n\n        superinit = super(ArgumentParser, self).__init__\n        superinit(description=description,\n                  prefix_chars=prefix_chars,\n                  argument_default=argument_default,\n                  conflict_handler=conflict_handler)\n\n        # default setting for prog\n        if prog is None:\n            prog = _os.path.basename(_sys.argv[0])\n\n        self.prog = prog\n        self.usage = usage\n        self.epilog = epilog\n        self.version = version\n        self.formatter_class = formatter_class\n        self.fromfile_prefix_chars = fromfile_prefix_chars\n        self.add_help = add_help\n\n        add_group = self.add_argument_group\n        self._positionals = add_group(_('positional arguments'))\n        self._optionals = add_group(_('optional arguments'))\n        self._subparsers = None\n\n        # register types\n        def identity(string):\n            return string\n        self.register('type', None, identity)\n\n        # add help and version arguments if necessary\n        # (using explicit default to override global argument_default)\n        default_prefix = '-' if '-' in prefix_chars else prefix_chars[0]\n        if self.add_help:\n            self.add_argument(\n                default_prefix+'h', default_prefix*2+'help',\n                action='help', default=SUPPRESS,\n                help=_('show this help message and exit'))\n        if self.version:\n            self.add_argument(\n                default_prefix+'v', default_prefix*2+'version',\n                action='version', default=SUPPRESS,\n                version=self.version,\n                help=_(\"show program's version number and exit\"))\n\n        # add parent arguments and defaults\n        for parent in parents:\n            self._add_container_actions(parent)\n            try:\n                defaults = parent._defaults\n            except AttributeError:\n                pass\n            else:\n                self._defaults.update(defaults)\n\n    # =======================\n    # Pretty __repr__ methods\n    # =======================\n    def _get_kwargs(self):\n        names = [\n            'prog',\n            'usage',\n            'description',\n            'version',\n            'formatter_class',\n            'conflict_handler',\n            'add_help',\n        ]\n        return [(name, getattr(self, name)) for name in names]\n\n    # ==================================\n    # Optional/Positional adding methods\n    # ==================================\n    def add_subparsers(self, **kwargs):\n        if self._subparsers is not None:\n            self.error(_('cannot have multiple subparser arguments'))\n\n        # add the parser class to the arguments if it's not present\n        kwargs.setdefault('parser_class', type(self))\n\n        if 'title' in kwargs or 'description' in kwargs:\n            title = _(kwargs.pop('title', 'subcommands'))\n            description = _(kwargs.pop('description', None))\n            self._subparsers = self.add_argument_group(title, description)\n        else:\n            self._subparsers = self._positionals\n\n        # prog defaults to the usage message of this parser, skipping\n        # optional arguments and with no \"usage:\" prefix\n        if kwargs.get('prog') is None:\n            formatter = self._get_formatter()\n            positionals = self._get_positional_actions()\n            groups = self._mutually_exclusive_groups\n            formatter.add_usage(self.usage, positionals, groups, '')\n            kwargs['prog'] = formatter.format_help().strip()\n\n        # create the parsers action and add it to the positionals list\n        parsers_class = self._pop_action_class(kwargs, 'parsers')\n        action = parsers_class(option_strings=[], **kwargs)\n        self._subparsers._add_action(action)\n\n        # return the created parsers action\n        return action\n\n    def _add_action(self, action):\n        if action.option_strings:\n            self._optionals._add_action(action)\n        else:\n            self._positionals._add_action(action)\n        return action\n\n    def _get_optional_actions(self):\n        return [action\n                for action in self._actions\n                if action.option_strings]\n\n    def _get_positional_actions(self):\n        return [action\n                for action in self._actions\n                if not action.option_strings]\n\n    # =====================================\n    # Command line argument parsing methods\n    # =====================================\n    def parse_args(self, args=None, namespace=None):\n        args, argv = self.parse_known_args(args, namespace)\n        if argv:\n            msg = _('unrecognized arguments: %s')\n            self.error(msg % ' '.join(argv))\n        return args\n\n    def parse_known_args(self, args=None, namespace=None):\n        # args default to the system args\n        if args is None:\n            args = _sys.argv[1:]\n\n        # default Namespace built from parser defaults\n        if namespace is None:\n            namespace = Namespace()\n\n        # add any action defaults that aren't present\n        for action in self._actions:\n            if action.dest is not SUPPRESS:\n                if not hasattr(namespace, action.dest):\n                    if action.default is not SUPPRESS:\n                        default = action.default\n                        if isinstance(action.default, str):\n                            default = self._get_value(action, default)\n                        setattr(namespace, action.dest, default)\n\n        # add any parser defaults that aren't present\n        for dest in self._defaults:\n            if not hasattr(namespace, dest):\n                setattr(namespace, dest, self._defaults[dest])\n\n        # parse the arguments and exit if there are any errors\n        try:\n            namespace, args = self._parse_known_args(args, namespace)\n            if hasattr(namespace, _UNRECOGNIZED_ARGS_ATTR):\n                args.extend(getattr(namespace, _UNRECOGNIZED_ARGS_ATTR))\n                delattr(namespace, _UNRECOGNIZED_ARGS_ATTR)\n            return namespace, args\n        except ArgumentError:\n            err = _sys.exc_info()[1]\n            self.error(str(err))\n\n    def _parse_known_args(self, arg_strings, namespace):\n        # replace arg strings that are file references\n        if self.fromfile_prefix_chars is not None:\n            arg_strings = self._read_args_from_files(arg_strings)\n\n        # map all mutually exclusive arguments to the other arguments\n        # they can't occur with\n        action_conflicts = {}\n        for mutex_group in self._mutually_exclusive_groups:\n            group_actions = mutex_group._group_actions\n            for i, mutex_action in enumerate(mutex_group._group_actions):\n                conflicts = action_conflicts.setdefault(mutex_action, [])\n                conflicts.extend(group_actions[:i])\n                conflicts.extend(group_actions[i + 1:])\n\n        # find all option indices, and determine the arg_string_pattern\n        # which has an 'O' if there is an option at an index,\n        # an 'A' if there is an argument, or a '-' if there is a '--'\n        option_string_indices = {}\n        arg_string_pattern_parts = []\n        arg_strings_iter = iter(arg_strings)\n        for i, arg_string in enumerate(arg_strings_iter):\n\n            # all args after -- are non-options\n            if arg_string == '--':\n                arg_string_pattern_parts.append('-')\n                for arg_string in arg_strings_iter:\n                    arg_string_pattern_parts.append('A')\n\n            # otherwise, add the arg to the arg strings\n            # and note the index if it was an option\n            else:\n                option_tuple = self._parse_optional(arg_string)\n                if option_tuple is None:\n                    pattern = 'A'\n                else:\n                    option_string_indices[i] = option_tuple\n                    pattern = 'O'\n                arg_string_pattern_parts.append(pattern)\n\n        # join the pieces together to form the pattern\n        arg_strings_pattern = ''.join(arg_string_pattern_parts)\n\n        # converts arg strings to the appropriate and then takes the action\n        seen_actions = set()\n        seen_non_default_actions = set()\n\n        def take_action(action, argument_strings, option_string=None):\n            seen_actions.add(action)\n            argument_values = self._get_values(action, argument_strings)\n\n            # error if this argument is not allowed with other previously\n            # seen arguments, assuming that actions that use the default\n            # value don't really count as \"present\"\n            if argument_values is not action.default:\n                seen_non_default_actions.add(action)\n                for conflict_action in action_conflicts.get(action, []):\n                    if conflict_action in seen_non_default_actions:\n                        msg = _('not allowed with argument %s')\n                        action_name = _get_action_name(conflict_action)\n                        raise ArgumentError(action, msg % action_name)\n\n            # take the action if we didn't receive a SUPPRESS value\n            # (e.g. from a default)\n            if argument_values is not SUPPRESS:\n                action(self, namespace, argument_values, option_string)\n\n        # function to convert arg_strings into an optional action\n        def consume_optional(start_index):\n\n            # get the optional identified at this index\n            option_tuple = option_string_indices[start_index]\n            action, option_string, explicit_arg = option_tuple\n\n            # identify additional optionals in the same arg string\n            # (e.g. -xyz is the same as -x -y -z if no args are required)\n            match_argument = self._match_argument\n            action_tuples = []\n            while True:\n\n                # if we found no optional action, skip it\n                if action is None:\n                    extras.append(arg_strings[start_index])\n                    return start_index + 1\n\n                # if there is an explicit argument, try to match the\n                # optional's string arguments to only this\n                if explicit_arg is not None:\n                    arg_count = match_argument(action, 'A')\n\n                    # if the action is a single-dash option and takes no\n                    # arguments, try to parse more single-dash options out\n                    # of the tail of the option string\n                    chars = self.prefix_chars\n                    if arg_count == 0 and option_string[1] not in chars:\n                        action_tuples.append((action, [], option_string))\n                        char = option_string[0]\n                        option_string = char + explicit_arg[0]\n                        new_explicit_arg = explicit_arg[1:] or None\n                        optionals_map = self._option_string_actions\n                        if option_string in optionals_map:\n                            action = optionals_map[option_string]\n                            explicit_arg = new_explicit_arg\n                        else:\n                            msg = _('ignored explicit argument %r')\n                            raise ArgumentError(action, msg % explicit_arg)\n\n                    # if the action expect exactly one argument, we've\n                    # successfully matched the option; exit the loop\n                    elif arg_count == 1:\n                        stop = start_index + 1\n                        args = [explicit_arg]\n                        action_tuples.append((action, args, option_string))\n                        break\n\n                    # error if a double-dash option did not use the\n                    # explicit argument\n                    else:\n                        msg = _('ignored explicit argument %r')\n                        raise ArgumentError(action, msg % explicit_arg)\n\n                # if there is no explicit argument, try to match the\n                # optional's string arguments with the following strings\n                # if successful, exit the loop\n                else:\n                    start = start_index + 1\n                    selected_patterns = arg_strings_pattern[start:]\n                    arg_count = match_argument(action, selected_patterns)\n                    stop = start + arg_count\n                    args = arg_strings[start:stop]\n                    action_tuples.append((action, args, option_string))\n                    break\n\n            # add the Optional to the list and return the index at which\n            # the Optional's string args stopped\n            assert action_tuples\n            for action, args, option_string in action_tuples:\n                take_action(action, args, option_string)\n            return stop\n\n        # the list of Positionals left to be parsed; this is modified\n        # by consume_positionals()\n        positionals = self._get_positional_actions()\n\n        # function to convert arg_strings into positional actions\n        def consume_positionals(start_index):\n            # match as many Positionals as possible\n            match_partial = self._match_arguments_partial\n            selected_pattern = arg_strings_pattern[start_index:]\n            arg_counts = match_partial(positionals, selected_pattern)\n\n            # slice off the appropriate arg strings for each Positional\n            # and add the Positional and its args to the list\n            for action, arg_count in zip(positionals, arg_counts):\n                args = arg_strings[start_index: start_index + arg_count]\n                start_index += arg_count\n                take_action(action, args)\n\n            # slice off the Positionals that we just parsed and return the\n            # index at which the Positionals' string args stopped\n            positionals[:] = positionals[len(arg_counts):]\n            return start_index\n\n        # consume Positionals and Optionals alternately, until we have\n        # passed the last option string\n        extras = []\n        start_index = 0\n        if option_string_indices:\n            max_option_string_index = max(option_string_indices)\n        else:\n            max_option_string_index = -1\n        while start_index <= max_option_string_index:\n\n            # consume any Positionals preceding the next option\n            next_option_string_index = min([\n                index\n                for index in option_string_indices\n                if index >= start_index])\n            if start_index != next_option_string_index:\n                positionals_end_index = consume_positionals(start_index)\n\n                # only try to parse the next optional if we didn't consume\n                # the option string during the positionals parsing\n                if positionals_end_index > start_index:\n                    start_index = positionals_end_index\n                    continue\n                else:\n                    start_index = positionals_end_index\n\n            # if we consumed all the positionals we could and we're not\n            # at the index of an option string, there were extra arguments\n            if start_index not in option_string_indices:\n                strings = arg_strings[start_index:next_option_string_index]\n                extras.extend(strings)\n                start_index = next_option_string_index\n\n            # consume the next optional and any arguments for it\n            start_index = consume_optional(start_index)\n\n        # consume any positionals following the last Optional\n        stop_index = consume_positionals(start_index)\n\n        # if we didn't consume all the argument strings, there were extras\n        extras.extend(arg_strings[stop_index:])\n\n        # if we didn't use all the Positional objects, there were too few\n        # arg strings supplied.\n        if positionals:\n            self.error(_('too few arguments'))\n\n        # make sure all required actions were present\n        for action in self._actions:\n            if action.required:\n                if action not in seen_actions:\n                    name = _get_action_name(action)\n                    self.error(_('argument %s is required') % name)\n\n        # make sure all required groups had one option present\n        for group in self._mutually_exclusive_groups:\n            if group.required:\n                for action in group._group_actions:\n                    if action in seen_non_default_actions:\n                        break\n\n                # if no actions were used, report the error\n                else:\n                    names = [_get_action_name(action)\n                             for action in group._group_actions\n                             if action.help is not SUPPRESS]\n                    msg = _('one of the arguments %s is required')\n                    self.error(msg % ' '.join(names))\n\n        # return the updated namespace and the extra arguments\n        return namespace, extras\n\n    def _read_args_from_files(self, arg_strings):\n        # expand arguments referencing files\n        new_arg_strings = []\n        for arg_string in arg_strings:\n\n            # for regular arguments, just add them back into the list\n            if arg_string[0] not in self.fromfile_prefix_chars:\n                new_arg_strings.append(arg_string)\n\n            # replace arguments referencing files with the file content\n            else:\n                try:\n                    args_file = open(arg_string[1:])\n                    try:\n                        arg_strings = []\n                        for arg_line in args_file.read().splitlines():\n                            for arg in self.convert_arg_line_to_args(arg_line):\n                                arg_strings.append(arg)\n                        arg_strings = self._read_args_from_files(arg_strings)\n                        new_arg_strings.extend(arg_strings)\n                    finally:\n                        args_file.close()\n                except IOError:\n                    err = _sys.exc_info()[1]\n                    self.error(str(err))\n\n        # return the modified argument list\n        return new_arg_strings\n\n    def convert_arg_line_to_args(self, arg_line):\n        return [arg_line]\n\n    def _match_argument(self, action, arg_strings_pattern):\n        # match the pattern for this action to the arg strings\n        nargs_pattern = self._get_nargs_pattern(action)\n        match = _re.match(nargs_pattern, arg_strings_pattern)\n\n        # raise an exception if we weren't able to find a match\n        if match is None:\n            nargs_errors = {\n                None: _('expected one argument'),\n                OPTIONAL: _('expected at most one argument'),\n                ONE_OR_MORE: _('expected at least one argument'),\n            }\n            default = ngettext('expected %s argument',\n                               'expected %s arguments',\n                               action.nargs) % action.nargs\n            msg = nargs_errors.get(action.nargs, default)\n            raise ArgumentError(action, msg)\n\n        # return the number of arguments matched\n        return len(match.group(1))\n\n    def _match_arguments_partial(self, actions, arg_strings_pattern):\n        # progressively shorten the actions list by slicing off the\n        # final actions until we find a match\n        result = []\n        for i in range(len(actions), 0, -1):\n            actions_slice = actions[:i]\n            pattern = ''.join([self._get_nargs_pattern(action)\n                               for action in actions_slice])\n            match = _re.match(pattern, arg_strings_pattern)\n            if match is not None:\n                result.extend([len(string) for string in match.groups()])\n                break\n\n        # return the list of arg string counts\n        return result\n\n    def _parse_optional(self, arg_string):\n        # if it's an empty string, it was meant to be a positional\n        if not arg_string:\n            return None\n\n        # if it doesn't start with a prefix, it was meant to be positional\n        if not arg_string[0] in self.prefix_chars:\n            return None\n\n        # if the option string is present in the parser, return the action\n        if arg_string in self._option_string_actions:\n            action = self._option_string_actions[arg_string]\n            return action, arg_string, None\n\n        # if it's just a single character, it was meant to be positional\n        if len(arg_string) == 1:\n            return None\n\n        # if the option string before the \"=\" is present, return the action\n        if '=' in arg_string:\n            option_string, explicit_arg = arg_string.split('=', 1)\n            if option_string in self._option_string_actions:\n                action = self._option_string_actions[option_string]\n                return action, option_string, explicit_arg\n\n        # search through all possible prefixes of the option string\n        # and all actions in the parser for possible interpretations\n        option_tuples = self._get_option_tuples(arg_string)\n\n        # if multiple actions match, the option string was ambiguous\n        if len(option_tuples) > 1:\n            options = ', '.join([option_string\n                for action, option_string, explicit_arg in option_tuples])\n            args = {'option': arg_string, 'matches': options}\n            msg = _('ambiguous option: %(option)s could match %(matches)s')\n            self.error(msg % args)\n\n        # if exactly one action matched, this segmentation is good,\n        # so return the parsed action\n        elif len(option_tuples) == 1:\n            option_tuple, = option_tuples\n            return option_tuple\n\n        # if it was not found as an option, but it looks like a negative\n        # number, it was meant to be positional\n        # unless there are negative-number-like options\n        if self._negative_number_matcher.match(arg_string):\n            if not self._has_negative_number_optionals:\n                return None\n\n        # if it contains a space, it was meant to be a positional\n        if ' ' in arg_string:\n            return None\n\n        # it was meant to be an optional but there is no such option\n        # in this parser (though it might be a valid option in a subparser)\n        return None, arg_string, None\n\n    def _get_option_tuples(self, option_string):\n        result = []\n\n        # option strings starting with two prefix characters are only\n        # split at the '='\n        chars = self.prefix_chars\n        if option_string[0] in chars and option_string[1] in chars:\n            if '=' in option_string:\n                option_prefix, explicit_arg = option_string.split('=', 1)\n            else:\n                option_prefix = option_string\n                explicit_arg = None\n            for option_string in self._option_string_actions:\n                if option_string.startswith(option_prefix):\n                    action = self._option_string_actions[option_string]\n                    tup = action, option_string, explicit_arg\n                    result.append(tup)\n\n        # single character options can be concatenated with their arguments\n        # but multiple character options always have to have their argument\n        # separate\n        elif option_string[0] in chars and option_string[1] not in chars:\n            option_prefix = option_string\n            explicit_arg = None\n            short_option_prefix = option_string[:2]\n            short_explicit_arg = option_string[2:]\n\n            for option_string in self._option_string_actions:\n                if option_string == short_option_prefix:\n                    action = self._option_string_actions[option_string]\n                    tup = action, option_string, short_explicit_arg\n                    result.append(tup)\n                elif option_string.startswith(option_prefix):\n                    action = self._option_string_actions[option_string]\n                    tup = action, option_string, explicit_arg\n                    result.append(tup)\n\n        # shouldn't ever get here\n        else:\n            self.error(_('unexpected option string: %s') % option_string)\n\n        # return the collected option tuples\n        return result\n\n    def _get_nargs_pattern(self, action):\n        # in all examples below, we have to allow for '--' args\n        # which are represented as '-' in the pattern\n        nargs = action.nargs\n\n        # the default (None) is assumed to be a single argument\n        if nargs is None:\n            nargs_pattern = '(-*A-*)'\n\n        # allow zero or one arguments\n        elif nargs == OPTIONAL:\n            nargs_pattern = '(-*A?-*)'\n\n        # allow zero or more arguments\n        elif nargs == ZERO_OR_MORE:\n            nargs_pattern = '(-*[A-]*)'\n\n        # allow one or more arguments\n        elif nargs == ONE_OR_MORE:\n            nargs_pattern = '(-*A[A-]*)'\n\n        # allow any number of options or arguments\n        elif nargs == REMAINDER:\n            nargs_pattern = '([-AO]*)'\n\n        # allow one argument followed by any number of options or arguments\n        elif nargs == PARSER:\n            nargs_pattern = '(-*A[-AO]*)'\n\n        # all others should be integers\n        else:\n            nargs_pattern = '(-*%s-*)' % '-*'.join('A' * nargs)\n\n        # if this is an optional action, -- is not allowed\n        if action.option_strings:\n            nargs_pattern = nargs_pattern.replace('-*', '')\n            nargs_pattern = nargs_pattern.replace('-', '')\n\n        # return the pattern\n        return nargs_pattern\n\n    # ========================\n    # Value conversion methods\n    # ========================\n    def _get_values(self, action, arg_strings):\n        # for everything but PARSER args, strip out '--'\n        if action.nargs not in [PARSER, REMAINDER]:\n            arg_strings = [s for s in arg_strings if s != '--']\n\n        # optional argument produces a default when not present\n        if not arg_strings and action.nargs == OPTIONAL:\n            if action.option_strings:\n                value = action.const\n            else:\n                value = action.default\n            if isinstance(value, str):\n                value = self._get_value(action, value)\n                self._check_value(action, value)\n\n        # when nargs='*' on a positional, if there were no command-line\n        # args, use the default if it is anything other than None\n        elif (not arg_strings and action.nargs == ZERO_OR_MORE and\n              not action.option_strings):\n            if action.default is not None:\n                value = action.default\n            else:\n                value = arg_strings\n            self._check_value(action, value)\n\n        # single argument or optional argument produces a single value\n        elif len(arg_strings) == 1 and action.nargs in [None, OPTIONAL]:\n            arg_string, = arg_strings\n            value = self._get_value(action, arg_string)\n            self._check_value(action, value)\n\n        # REMAINDER arguments convert all values, checking none\n        elif action.nargs == REMAINDER:\n            value = [self._get_value(action, v) for v in arg_strings]\n\n        # PARSER arguments convert all values, but check only the first\n        elif action.nargs == PARSER:\n            value = [self._get_value(action, v) for v in arg_strings]\n            self._check_value(action, value[0])\n\n        # all other types of nargs produce a list\n        else:\n            value = [self._get_value(action, v) for v in arg_strings]\n            for v in value:\n                self._check_value(action, v)\n\n        # return the converted value\n        return value\n\n    def _get_value(self, action, arg_string):\n        type_func = self._registry_get('type', action.type, action.type)\n        if not _callable(type_func):\n            msg = _('%r is not callable')\n            raise ArgumentError(action, msg % type_func)\n\n        # convert the value to the appropriate type\n        try:\n            result = type_func(arg_string)\n\n        # ArgumentTypeErrors indicate errors\n        except ArgumentTypeError:\n            name = getattr(action.type, '__name__', repr(action.type))\n            msg = str(_sys.exc_info()[1])\n            raise ArgumentError(action, msg)\n\n        # TypeErrors or ValueErrors also indicate errors\n        except (TypeError, ValueError):\n            name = getattr(action.type, '__name__', repr(action.type))\n            args = {'type': name, 'value': arg_string}\n            msg = _('invalid %(type)s value: %(value)r')\n            raise ArgumentError(action, msg % args)\n\n        # return the converted value\n        return result\n\n    def _check_value(self, action, value):\n        # converted value must be one of the choices (if specified)\n        if action.choices is not None and value not in action.choices:\n            args = {'value': value,\n                    'choices': ', '.join(map(repr, action.choices))}\n            msg = _('invalid choice: %(value)r (choose from %(choices)s)')\n            raise ArgumentError(action, msg % args)\n\n    # =======================\n    # Help-formatting methods\n    # =======================\n    def format_usage(self):\n        formatter = self._get_formatter()\n        formatter.add_usage(self.usage, self._actions,\n                            self._mutually_exclusive_groups)\n        return formatter.format_help()\n\n    def format_help(self):\n        formatter = self._get_formatter()\n\n        # usage\n        formatter.add_usage(self.usage, self._actions,\n                            self._mutually_exclusive_groups)\n\n        # description\n        formatter.add_text(self.description)\n\n        # positionals, optionals and user-defined groups\n        for action_group in self._action_groups:\n            formatter.start_section(action_group.title)\n            formatter.add_text(action_group.description)\n            formatter.add_arguments(action_group._group_actions)\n            formatter.end_section()\n\n        # epilog\n        formatter.add_text(self.epilog)\n\n        # determine help from format above\n        return formatter.format_help()\n\n    def format_version(self):\n        import warnings\n        warnings.warn(\n            'The format_version method is deprecated -- the \"version\" '\n            'argument to ArgumentParser is no longer supported.',\n            DeprecationWarning)\n        formatter = self._get_formatter()\n        formatter.add_text(self.version)\n        return formatter.format_help()\n\n    def _get_formatter(self):\n        return self.formatter_class(prog=self.prog)\n\n    # =====================\n    # Help-printing methods\n    # =====================\n    def print_usage(self, file=None):\n        if file is None:\n            file = _sys.stdout\n        self._print_message(self.format_usage(), file)\n\n    def print_help(self, file=None):\n        if file is None:\n            file = _sys.stdout\n        self._print_message(self.format_help(), file)\n\n    def print_version(self, file=None):\n        import warnings\n        warnings.warn(\n            'The print_version method is deprecated -- the \"version\" '\n            'argument to ArgumentParser is no longer supported.',\n            DeprecationWarning)\n        self._print_message(self.format_version(), file)\n\n    def _print_message(self, message, file=None):\n        if message:\n            if file is None:\n                file = _sys.stderr\n            file.write(message)\n\n    # ===============\n    # Exiting methods\n    # ===============\n    def exit(self, status=0, message=None):\n        if message:\n            self._print_message(message, _sys.stderr)\n        _sys.exit(status)\n\n    def error(self, message):\n        \"\"\"error(message: string)\n\n        Prints a usage message incorporating the message to stderr and\n        exits.\n\n        If you override this in a subclass, it should not return -- it\n        should either exit or raise an exception.\n        \"\"\"\n        self.print_usage(_sys.stderr)\n        args = {'prog': self.prog, 'message': message}\n        self.exit(2, _('%(prog)s: error: %(message)s\\n') % args)\n\n\nFile: pyarmor/plugins/README.md\n# Plugins\n\nPlugin usually is used to extend license type, or insert some extra check code\nto obfuscated scripts to improve the security.\n\nHere are some examples:\n\n* [Check all the mac address](#example-1-check-all-the-mac-address)\n* [Check docker container id](#example-2-check-docker-container-id)\n* [Check internet time](#example-3-check-internet-time)\n* [Check GPU](#example-5-check-gpu)\n\n\n**The sample code is only a guide, it's strongly recommended to write your\nprivate code in plugin script**\n\n##  Example 1: Check All the Mac Address\n\nHere is an example show how to check all the mac addresses.\n\nThere are 2 files in this plugin\n\n    extra_hdinfo.c\n    check_multi_mac.py\n\nThe dynamic library `extra_hdinfo.so` exports one function `get_multi_mac` which\ncould get all the mac addresses.\n\nThe script [check_multi_mac.py](check_multi_mac.py) will get the multiple mac\naddress by calling `get_multi_mac` in the dynamic library `extra_hdinfo.so`,\nthen compare the expected mac address saved in the `license.lic` of the\nobfuscated scripts, check whether it's expected.\n\nIt will also check the file `extra_hdinfo.so` to be sure it's not changed by\nsomeone else.\n\nFirst build [extra_hdinfo.c](extra_hdinfo.c):\n\n    gcc -shared -o extra_hdinfo.so -fPIC extra_hdinfo.c\n\nGet sha384 of `extra_hdinfo.so`:\n\n    sha384sum extra_hdinfo.so\n\nEdit the file [check_multi_mac.py](check_multi_mac.py), replace the value of\n`lib_hdinfo_checksum` got above.\n\nThen edit the entry script [foo.py](foo.py), insert two comment lines:\n\n    # {PyArmor Plugins}\n    # PyArmor Plugin: check_multi_mac()\n\nNow, obfuscate the script with this plugin:\n\n    pyarmor obfuscate --plugin check_multi_mac foo.py\n\nThe content of [check_multi_mac.py](check_multi_mac.py) will be insert after the\nfirst comment line `# {PyArmor Plugins}`\n\nAnd the prefix of second comment will be stripped as:\n\n    check_multi_mac()\n\nSo the plugin takes effect.\n\nIf the plugin file isn't in the current path, use absolute path instead:\n\n    pyarmor obfuscate --plugin /path/to/check_multi_mac foo.py\n\nThe last step is to generate the license file for the obfuscated script.\n\n1. Run the following command to get all mac addresses in target machine\n\n        gcc -DAPP -o hdinfo extra_hdinfo.c\n        ./hdinfo\n\n2. Generate the license file and copy it to dist path\n\n        pyarmor licenses -x 70:f1:a1:23:f0:94.08:00:27:51:d9:fe CODE-0001\n        pyarmor obfuscate --plugin /path/to/check_multi_mac \\\n                          --with-license licenses/CODE-0001/license.lic foo.py\n\nDistributing the obfuscated scripts to target machine:\n\n* Copy all the files in the `dist` path to target machine\n* Copy `extra_hdinfo.so` to `/usr/lib` in target machine\n\n## Example 2: Check Docker Container ID\n\nFirst write the plugin [check_docker.py](check_docker.py)\n\nThen edit the entry script [foo.py](foo.py), insert two comment lines:\n\n    # {PyArmor Plugins}\n    # PyArmor Plugin: check_docker()\n\nNow, obfuscate the script with this plugin:\n\n    pyarmor obfuscate --plugin check_docker foo.py\n\nIf the plugin file isn’t in the current path, use absolute path instead:\n\n    pyarmor obfuscate --plugin /path/to/check_docker foo.py\n\nThe last step is to generate the license file for the obfuscated script:\n\n    pyarmor licenses -x f56b1824e453126ab5426708dbbed41d0232f6f2ab21de1c40da934b68a5d8a2 CODE-0002\n    pyarmor obfuscate --with-license licenses/CODE-0002/license.lic \\\n                      --plugin check_docker foo.py\n\n## Example 3: Check Internet Time\n\nFirst write the plugin [check_ntp_time.py](check_ntp_time.py), you may change\n`NTP_SERVER` to your prefer.\n\nThen edit the entry script [foo.py](foo.py), insert two comment lines:\n\n    # {PyArmor Plugins}\n    # PyArmor Plugin: check_ntp_time()\n\nNow, obfuscate the script with this plugin:\n\n    pyarmor obfuscate --plugin check_ntp_time foo.py\n\nThe last step is to generate the license file for the obfuscated script, which\nexpired on Oct 31, 2020:\n\n    pyarmor licenses -x 20201031 CODE-0003\n    pyarmor obfuscate --with-license licenses/CODE-0003/license.lic \\\n                      --plugin check_ntp_time foo.py\n\n## Example 4: Create License For Multiple Machines\n\nFirst write the plugin [check_multiple_machine.py](check_multiple_machine.py).\n\nThen edit the entry script [foo.py](foo.py), insert two comment lines:\n\n    # {PyArmor Plugins}\n    # PyArmor Plugin: check_multiple_machine()\n\nNow, obfuscate the script with this plugin:\n\n    pyarmor obfuscate --plugin check_multiple_machine foo.py\n\nThe last step is to generate the license file for 3 machines, suppose the serial\nnumber of hard disk in these machines are `ta1`, `ta2`, `ta3`:\n\n    pyarmor licenses -x \"ta1;ta2;ta3\" CODE-0004\n    pyarmor obfuscate --with-license licenses/CODE-0004/license.lic \\\n                      --plugin check_multiple_machine foo.py\n\n## Example 5: Check GPU\n\nIf you are obfuscating the code that should run mostly on GPU (the calculations), there is an easy and straight-forward way to tie your code to a particular GPU.\n\nThis [plugin example](https://github.com/dashingsoft/pyarmor/blob/master/plugins/check_gpu.py) is written for Nvidia GPUs. The GPU UUID reported by `nvidia-smi -L` is supposed to be globally unique. I have tested this example in the `super` mode.\n\nTo use this plugin:\n\n- Copy this `check_gpu.py` plugin file to some folder;\n- Create a simple test script like this (i.e. `test_gpu.py`) in the same folder:\n```\n# {PyArmor Plugins}\n# PyArmor Plugin: check_gpu()\ndef test():\n    print(`It works!`)\n```\n- You can use the `get_gpu_list()` function from `check_gpu.py` to learn your GPU UUID(s), or you can just run `nvidia-smi -L`;\n- Note that the example is written for a use case with only one GPU and its UUID should be in lowercase, amend for your case;\n- Create a separate license file: `pyarmor licenses --expired 2022-02-21 -x gpu-70ef1701-4072-9722-cc0b-7c7e75ff76db gpu_test_license`;\n- Obfuscate your test script: `pyarmor obfuscate --plugin check_gpu --with-license licenses/gpu_test_license/license.lic --advanced 2 --exact test_gpu.py`;\n- Note that since we are using the `super` mode, at the moment of writing this guide there was some [discrepancy](https://github.com/dashingsoft/pyarmor/issues/474) between the public docs and the actual behaviour of runtime module [pytransform](https://pyarmor.readthedocs.io/en/latest/pytransform.html);\n\n\nFile: pyarmor/plugins/check_ntp_time.py\n# Uncomment the next 2 lines for debug as the script isn't obfuscated,\n# otherwise runtime module \"pytransform\" isn't available in development\n# from pytransform import pyarmor_init\n# pyarmor_init()\n\n# -----------------------------------------------------------\n# Start of ntplib.py\n# -----------------------------------------------------------\n\nimport datetime\nimport socket\nimport struct\nimport time\n\n\nclass NTPException(Exception):\n    \"\"\"Exception raised by this module.\"\"\"\n    pass\n\n\nclass NTP:\n    \"\"\"Helper class defining constants.\"\"\"\n\n    _SYSTEM_EPOCH = datetime.date(*time.gmtime(0)[0:3])\n    \"\"\"system epoch\"\"\"\n    _NTP_EPOCH = datetime.date(1900, 1, 1)\n    \"\"\"NTP epoch\"\"\"\n    NTP_DELTA = (_SYSTEM_EPOCH - _NTP_EPOCH).days * 24 * 3600\n    \"\"\"delta between system and NTP time\"\"\"\n\n    REF_ID_TABLE = {\n        \"GOES\":  \"Geostationary Orbit Environment Satellite\",\n        \"GPS\\0\": \"Global Position System\",\n        \"GAL\\0\": \"Galileo Positioning System\",\n        \"PPS\\0\": \"Generic pulse-per-second\",\n        \"IRIG\":  \"Inter-Range Instrumentation Group\",\n        \"WWVB\":  \"LF Radio WWVB Ft. Collins, CO 60 kHz\",\n        \"DCF\\0\": \"LF Radio DCF77 Mainflingen, DE 77.5 kHz\",\n        \"HBG\\0\": \"LF Radio HBG Prangins, HB 75 kHz\",\n        \"MSF\\0\": \"LF Radio MSF Anthorn, UK 60 kHz\",\n        \"JJY\\0\": \"LF Radio JJY Fukushima, JP 40 kHz, Saga, JP 60 kHz\",\n        \"LORC\":  \"MF Radio LORAN C station, 100 kHz\",\n        \"TDF\\0\": \"MF Radio Allouis, FR 162 kHz\",\n        \"CHU\\0\": \"HF Radio CHU Ottawa, Ontario\",\n        \"WWV\\0\": \"HF Radio WWV Ft. Collins, CO\",\n        \"WWVH\":  \"HF Radio WWVH Kauai, HI\",\n        \"NIST\":  \"NIST telephone modem\",\n        \"ACTS\":  \"NIST telephone modem\",\n        \"USNO\":  \"USNO telephone modem\",\n        \"PTB\\0\": \"European telephone modem\",\n        \"LOCL\":  \"uncalibrated local clock\",\n        \"CESM\":  \"calibrated Cesium clock\",\n        \"RBDM\":  \"calibrated Rubidium clock\",\n        \"OMEG\":  \"OMEGA radionavigation system\",\n        \"DCN\\0\": \"DCN routing protocol\",\n        \"TSP\\0\": \"TSP time protocol\",\n        \"DTS\\0\": \"Digital Time Service\",\n        \"ATOM\":  \"Atomic clock (calibrated)\",\n        \"VLF\\0\": \"VLF radio (OMEGA,, etc.)\",\n        \"1PPS\":  \"External 1 PPS input\",\n        \"FREE\":  \"(Internal clock)\",\n        \"INIT\":  \"(Initialization)\",\n        \"\\0\\0\\0\\0\":   \"NULL\",\n    }\n    \"\"\"reference identifier table\"\"\"\n\n    STRATUM_TABLE = {\n        0: \"unspecified or invalid\",\n        1: \"primary reference (%s)\",\n    }\n    \"\"\"stratum table\"\"\"\n\n    MODE_TABLE = {\n        0: \"reserved\",\n        1: \"symmetric active\",\n        2: \"symmetric passive\",\n        3: \"client\",\n        4: \"server\",\n        5: \"broadcast\",\n        6: \"reserved for NTP control messages\",\n        7: \"reserved for private use\",\n    }\n    \"\"\"mode table\"\"\"\n\n    LEAP_TABLE = {\n        0: \"no warning\",\n        1: \"last minute of the day has 61 seconds\",\n        2: \"last minute of the day has 59 seconds\",\n        3: \"unknown (clock unsynchronized)\",\n    }\n    \"\"\"leap indicator table\"\"\"\n\n\nclass NTPPacket:\n    \"\"\"NTP packet class.\n\n    This represents an NTP packet.\n    \"\"\"\n\n    _PACKET_FORMAT = \"!B B B b 11I\"\n    \"\"\"packet format to pack/unpack\"\"\"\n\n    def __init__(self, version=2, mode=3, tx_timestamp=0):\n        \"\"\"Constructor.\n\n        Parameters:\n        version      -- NTP version\n        mode         -- packet mode (client, server)\n        tx_timestamp -- packet transmit timestamp\n        \"\"\"\n        self.leap = 0\n        \"\"\"leap second indicator\"\"\"\n        self.version = version\n        \"\"\"version\"\"\"\n        self.mode = mode\n        \"\"\"mode\"\"\"\n        self.stratum = 0\n        \"\"\"stratum\"\"\"\n        self.poll = 0\n        \"\"\"poll interval\"\"\"\n        self.precision = 0\n        \"\"\"precision\"\"\"\n        self.root_delay = 0\n        \"\"\"root delay\"\"\"\n        self.root_dispersion = 0\n        \"\"\"root dispersion\"\"\"\n        self.ref_id = 0\n        \"\"\"reference clock identifier\"\"\"\n        self.ref_timestamp = 0\n        \"\"\"reference timestamp\"\"\"\n        self.orig_timestamp = 0\n        \"\"\"originate timestamp\"\"\"\n        self.recv_timestamp = 0\n        \"\"\"receive timestamp\"\"\"\n        self.tx_timestamp = tx_timestamp\n        \"\"\"tansmit timestamp\"\"\"\n\n    def to_data(self):\n        \"\"\"Convert this NTPPacket to a buffer that can be sent over a socket.\n\n        Returns:\n        buffer representing this packet\n\n        Raises:\n        NTPException -- in case of invalid field\n        \"\"\"\n        try:\n            packed = struct.pack(NTPPacket._PACKET_FORMAT,\n                (self.leap << 6 | self.version << 3 | self.mode),\n                self.stratum,\n                self.poll,\n                self.precision,\n                _to_int(self.root_delay) << 16 | _to_frac(self.root_delay, 16),\n                _to_int(self.root_dispersion) << 16 |\n                _to_frac(self.root_dispersion, 16),\n                self.ref_id,\n                _to_int(self.ref_timestamp),\n                _to_frac(self.ref_timestamp),\n                _to_int(self.orig_timestamp),\n                _to_frac(self.orig_timestamp),\n                _to_int(self.recv_timestamp),\n                _to_frac(self.recv_timestamp),\n                _to_int(self.tx_timestamp),\n                _to_frac(self.tx_timestamp))\n        except struct.error:\n            raise NTPException(\"Invalid NTP packet fields.\")\n        return packed\n\n    def from_data(self, data):\n        \"\"\"Populate this instance from a NTP packet payload received from\n        the network.\n\n        Parameters:\n        data -- buffer payload\n\n        Raises:\n        NTPException -- in case of invalid packet format\n        \"\"\"\n        try:\n            unpacked = struct.unpack(NTPPacket._PACKET_FORMAT,\n                    data[0:struct.calcsize(NTPPacket._PACKET_FORMAT)])\n        except struct.error:\n            raise NTPException(\"Invalid NTP packet.\")\n\n        self.leap = unpacked[0] >> 6 & 0x3\n        self.version = unpacked[0] >> 3 & 0x7\n        self.mode = unpacked[0] & 0x7\n        self.stratum = unpacked[1]\n        self.poll = unpacked[2]\n        self.precision = unpacked[3]\n        self.root_delay = float(unpacked[4])/2**16\n        self.root_dispersion = float(unpacked[5])/2**16\n        self.ref_id = unpacked[6]\n        self.ref_timestamp = _to_time(unpacked[7], unpacked[8])\n        self.orig_timestamp = _to_time(unpacked[9], unpacked[10])\n        self.recv_timestamp = _to_time(unpacked[11], unpacked[12])\n        self.tx_timestamp = _to_time(unpacked[13], unpacked[14])\n\n\nclass NTPStats(NTPPacket):\n    \"\"\"NTP statistics.\n\n    Wrapper for NTPPacket, offering additional statistics like offset and\n    delay, and timestamps converted to system time.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Constructor.\"\"\"\n        NTPPacket.__init__(self)\n        self.dest_timestamp = 0\n        \"\"\"destination timestamp\"\"\"\n\n    @property\n    def offset(self):\n        \"\"\"offset\"\"\"\n        return ((self.recv_timestamp - self.orig_timestamp) +\n                (self.tx_timestamp - self.dest_timestamp))/2\n\n    @property\n    def delay(self):\n        \"\"\"round-trip delay\"\"\"\n        return ((self.dest_timestamp - self.orig_timestamp) -\n                (self.tx_timestamp - self.recv_timestamp))\n\n    @property\n    def tx_time(self):\n        \"\"\"Transmit timestamp in system time.\"\"\"\n        return ntp_to_system_time(self.tx_timestamp)\n\n    @property\n    def recv_time(self):\n        \"\"\"Receive timestamp in system time.\"\"\"\n        return ntp_to_system_time(self.recv_timestamp)\n\n    @property\n    def orig_time(self):\n        \"\"\"Originate timestamp in system time.\"\"\"\n        return ntp_to_system_time(self.orig_timestamp)\n\n    @property\n    def ref_time(self):\n        \"\"\"Reference timestamp in system time.\"\"\"\n        return ntp_to_system_time(self.ref_timestamp)\n\n    @property\n    def dest_time(self):\n        \"\"\"Destination timestamp in system time.\"\"\"\n        return ntp_to_system_time(self.dest_timestamp)\n\n\nclass NTPClient:\n    \"\"\"NTP client session.\"\"\"\n\n    def __init__(self):\n        \"\"\"Constructor.\"\"\"\n        pass\n\n    def request(self, host, version=2, port='ntp', timeout=5):\n        \"\"\"Query a NTP server.\n\n        Parameters:\n        host    -- server name/address\n        version -- NTP version to use\n        port    -- server port\n        timeout -- timeout on socket operations\n\n        Returns:\n        NTPStats object\n        \"\"\"\n        # lookup server address\n        addrinfo = socket.getaddrinfo(host, port)[0]\n        family, sockaddr = addrinfo[0], addrinfo[4]\n\n        # create the socket\n        s = socket.socket(family, socket.SOCK_DGRAM)\n\n        try:\n            s.settimeout(timeout)\n\n            # create the request packet - mode 3 is client\n            query_packet = NTPPacket(mode=3, version=version,\n                                tx_timestamp=system_to_ntp_time(time.time()))\n\n            # send the request\n            s.sendto(query_packet.to_data(), sockaddr)\n\n            # wait for the response - check the source address\n            src_addr = None,\n            while src_addr[0] != sockaddr[0]:\n                response_packet, src_addr = s.recvfrom(256)\n\n            # build the destination timestamp\n            dest_timestamp = system_to_ntp_time(time.time())\n        except socket.timeout:\n            raise NTPException(\"No response received from %s.\" % host)\n        finally:\n            s.close()\n\n        # construct corresponding statistics\n        stats = NTPStats()\n        stats.from_data(response_packet)\n        stats.dest_timestamp = dest_timestamp\n\n        return stats\n\n\ndef _to_int(timestamp):\n    \"\"\"Return the integral part of a timestamp.\n\n    Parameters:\n    timestamp -- NTP timestamp\n\n    Retuns:\n    integral part\n    \"\"\"\n    return int(timestamp)\n\n\ndef _to_frac(timestamp, n=32):\n    \"\"\"Return the fractional part of a timestamp.\n\n    Parameters:\n    timestamp -- NTP timestamp\n    n         -- number of bits of the fractional part\n\n    Retuns:\n    fractional part\n    \"\"\"\n    return int(abs(timestamp - _to_int(timestamp)) * 2**n)\n\n\ndef _to_time(integ, frac, n=32):\n    \"\"\"Return a timestamp from an integral and fractional part.\n\n    Parameters:\n    integ -- integral part\n    frac  -- fractional part\n    n     -- number of bits of the fractional part\n\n    Retuns:\n    timestamp\n    \"\"\"\n    return integ + float(frac)/2**n\n\n\ndef ntp_to_system_time(timestamp):\n    \"\"\"Convert a NTP time to system time.\n\n    Parameters:\n    timestamp -- timestamp in NTP time\n\n    Returns:\n    corresponding system time\n    \"\"\"\n    return timestamp - NTP.NTP_DELTA\n\n\ndef system_to_ntp_time(timestamp):\n    \"\"\"Convert a system time to a NTP time.\n\n    Parameters:\n    timestamp -- timestamp in system time\n\n    Returns:\n    corresponding NTP time\n    \"\"\"\n    return timestamp + NTP.NTP_DELTA\n\n\ndef leap_to_text(leap):\n    \"\"\"Convert a leap indicator to text.\n\n    Parameters:\n    leap -- leap indicator value\n\n    Returns:\n    corresponding message\n\n    Raises:\n    NTPException -- in case of invalid leap indicator\n    \"\"\"\n    if leap in NTP.LEAP_TABLE:\n        return NTP.LEAP_TABLE[leap]\n    else:\n        raise NTPException(\"Invalid leap indicator.\")\n\n\ndef mode_to_text(mode):\n    \"\"\"Convert a NTP mode value to text.\n\n    Parameters:\n    mode -- NTP mode\n\n    Returns:\n    corresponding message\n\n    Raises:\n    NTPException -- in case of invalid mode\n    \"\"\"\n    if mode in NTP.MODE_TABLE:\n        return NTP.MODE_TABLE[mode]\n    else:\n        raise NTPException(\"Invalid mode.\")\n\n\ndef stratum_to_text(stratum):\n    \"\"\"Convert a stratum value to text.\n\n    Parameters:\n    stratum -- NTP stratum\n\n    Returns:\n    corresponding message\n\n    Raises:\n    NTPException -- in case of invalid stratum\n    \"\"\"\n    if stratum in NTP.STRATUM_TABLE:\n        return NTP.STRATUM_TABLE[stratum] % (stratum)\n    elif 1 < stratum < 16:\n        return \"secondary reference (%s)\" % (stratum)\n    elif stratum == 16:\n        return \"unsynchronized (%s)\" % (stratum)\n    else:\n        raise NTPException(\"Invalid stratum or reserved.\")\n\n\ndef ref_id_to_text(ref_id, stratum=2):\n    \"\"\"Convert a reference clock identifier to text according to its stratum.\n\n    Parameters:\n    ref_id  -- reference clock indentifier\n    stratum -- NTP stratum\n\n    Returns:\n    corresponding message\n\n    Raises:\n    NTPException -- in case of invalid stratum\n    \"\"\"\n    fields = (ref_id >> 24 & 0xff, ref_id >> 16 & 0xff,\n              ref_id >> 8 & 0xff, ref_id & 0xff)\n\n    # return the result as a string or dot-formatted IP address\n    if 0 <= stratum <= 1:\n        text = '%c%c%c%c' % fields\n        if text in NTP.REF_ID_TABLE:\n            return NTP.REF_ID_TABLE[text]\n        else:\n            return \"Unidentified reference source '%s'\" % (text)\n    elif 2 <= stratum < 255:\n        return '%d.%d.%d.%d' % fields\n    else:\n        raise NTPException(\"Invalid stratum.\")\n\n# -----------------------------------------------------------\n# End of ntplib.py\n# -----------------------------------------------------------\n\n\ndef _get_license_data():\n    try:\n        from pytransform import _pytransform\n    except Exception:\n        # For super mode\n        from pytransform import get_user_data\n        return get_user_data().decode()\n\n    from ctypes import py_object, PYFUNCTYPE\n    prototype = PYFUNCTYPE(py_object)\n    dlfunc = prototype(('get_registration_code', _pytransform))\n    rcode = dlfunc().decode()\n    index = rcode.find(';', rcode.find('*CODE:'))\n    return rcode[index+1:]\n\n\ndef check_ntp_time(NTP_SERVER='europe.pool.ntp.org'):\n    EXPIRED_DATE = _get_license_data()\n    c = NTPClient()\n    response = c.request(NTP_SERVER, version=3)\n    if response.tx_time > time.mktime(time.strptime(EXPIRED_DATE, '%Y%m%d')):\n        raise RuntimeError('License is expired')\n\n\nFile: pyarmor/examples/simple/queens.py\n#!/usr/bin/env python3\n\nfrom __future__ import print_function\n\n\"\"\"\nN queens problem.\n\nThe (well-known) problem is due to Niklaus Wirth.\n\nThis solution is inspired by Dijkstra (Structured Programming).  It is\na classic recursive backtracking approach.\n\"\"\"\n\nN = 8                                   # Default; command line overrides\n\nclass Queens:\n\n    def __init__(self, n=N):\n        self.n = n\n        self.reset()\n\n    def reset(self):\n        n = self.n\n        self.y = [None] * n             # Where is the queen in column x\n        self.row = [0] * n              # Is row[y] safe?\n        self.up = [0] * (2*n-1)         # Is upward diagonal[x-y] safe?\n        self.down = [0] * (2*n-1)       # Is downward diagonal[x+y] safe?\n        self.nfound = 0                 # Instrumentation\n\n    def solve(self, x=0):               # Recursive solver\n        for y in range(self.n):\n            if self.safe(x, y):\n                self.place(x, y)\n                if x+1 == self.n:\n                    self.display()\n                else:\n                    self.solve(x+1)\n                self.remove(x, y)\n\n    def safe(self, x, y):\n        return not self.row[y] and not self.up[x-y] and not self.down[x+y]\n\n    def place(self, x, y):\n        self.y[x] = y\n        self.row[y] = 1\n        self.up[x-y] = 1\n        self.down[x+y] = 1\n\n    def remove(self, x, y):\n        self.y[x] = None\n        self.row[y] = 0\n        self.up[x-y] = 0\n        self.down[x+y] = 0\n\n    silent = 0                          # If true, count solutions only\n\n    def display(self):\n        self.nfound = self.nfound + 1\n        if self.silent:\n            return\n        print('+-' + '--'*self.n + '+')\n        for y in range(self.n-1, -1, -1):\n            print('|', end=' ')\n            for x in range(self.n):\n                if self.y[x] == y:\n                    print(\"Q\", end=' ')\n                else:\n                    print(\".\", end=' ')\n            print('|')\n        print('+-' + '--'*self.n + '+')\n\ndef main():\n    import sys\n    silent = 0\n    n = N\n    if sys.argv[1:2] == ['-n']:\n        silent = 1\n        del sys.argv[1]\n    if sys.argv[1:]:\n        n = int(sys.argv[1])\n    q = Queens(n)\n    q.silent = silent\n    q.solve()\n    print(\"Found\", q.nfound, \"solutions.\")\n\nif __name__ == \"__main__\":\n    main()\n\n\nFile: pyarmor/examples/py2exe/setup.py\n# A very simple setup script to create 2 executables.\n#\n# hello.py is a simple \"hello, world\" type program, which alse allows\n# to explore the environment in which the script runs.\n#\n# test_wx.py is a simple wxPython program, it will be converted into a\n# console-less program.\n#\n# If you don't have wxPython installed, you should comment out the\n#   windows = [\"test_wx.py\"]\n# line below.\n#\n#\n# Run the build process by entering 'setup.py py2exe' or\n# 'python setup.py py2exe' in a console prompt.\n#\n# If everything works well, you should find a subdirectory named 'dist'\n# containing some files, among them hello.exe and test_wx.exe.\n\n\nfrom distutils.core import setup\nimport py2exe\n\nsetup(\n    # The first three parameters are not required, if at least a\n    # 'version' is given, then a versioninfo resource is built from\n    # them and added to the executables.\n    version = \"0.5.0\",\n    description = \"py2exe sample script\",\n    name = \"py2exe samples\",\n\n    # targets to build\n    # windows = [\"test_wx.py\"],\n    console = [\"hello.py\"],\n    py_modules = [\"queens\"], \n    )\n\n\nFile: pyarmor/examples/py2exe/hello.py\nimport sys\n\nfrom queens import main\n\nmain()\n\n\nFile: pyarmor/examples/py2exe/queens.py\n#!/usr/bin/env python3\n\nfrom __future__ import print_function\n\n\"\"\"\nN queens problem.\n\nThe (well-known) problem is due to Niklaus Wirth.\n\nThis solution is inspired by Dijkstra (Structured Programming).  It is\na classic recursive backtracking approach.\n\"\"\"\n\nN = 8                                   # Default; command line overrides\n\nclass Queens:\n\n    def __init__(self, n=N):\n        self.n = n\n        self.reset()\n\n    def reset(self):\n        n = self.n\n        self.y = [None] * n             # Where is the queen in column x\n        self.row = [0] * n              # Is row[y] safe?\n        self.up = [0] * (2*n-1)         # Is upward diagonal[x-y] safe?\n        self.down = [0] * (2*n-1)       # Is downward diagonal[x+y] safe?\n        self.nfound = 0                 # Instrumentation\n\n    def solve(self, x=0):               # Recursive solver\n        for y in range(self.n):\n            if self.safe(x, y):\n                self.place(x, y)\n                if x+1 == self.n:\n                    self.display()\n                else:\n                    self.solve(x+1)\n                self.remove(x, y)\n\n    def safe(self, x, y):\n        return not self.row[y] and not self.up[x-y] and not self.down[x+y]\n\n    def place(self, x, y):\n        self.y[x] = y\n        self.row[y] = 1\n        self.up[x-y] = 1\n        self.down[x+y] = 1\n\n    def remove(self, x, y):\n        self.y[x] = None\n        self.row[y] = 0\n        self.up[x-y] = 0\n        self.down[x+y] = 0\n\n    silent = 0                          # If true, count solutions only\n\n    def display(self):\n        self.nfound = self.nfound + 1\n        if self.silent:\n            return\n        print('+-' + '--'*self.n + '+')\n        for y in range(self.n-1, -1, -1):\n            print('|', end=' ')\n            for x in range(self.n):\n                if self.y[x] == y:\n                    print(\"Q\", end=' ')\n                else:\n                    print(\".\", end=' ')\n            print('|')\n        print('+-' + '--'*self.n + '+')\n\ndef main():\n    import sys\n    silent = 0\n    n = N\n    if sys.argv[1:2] == ['-n']:\n        silent = 1\n        del sys.argv[1]\n    if sys.argv[1:]:\n        n = int(sys.argv[1])\n    q = Queens(n)\n    q.silent = silent\n    q.solve()\n    print(\"Found\", q.nfound, \"solutions.\")\n\nif __name__ == \"__main__\":\n    main()\n\n\nFile: pyarmor/examples/testpkg/mypkg/__init__.py\nfrom .foo import hello\n\n\ntitle = 'PyArmor Test Case'\n\n\ndef open_hello(msg):\n    print('This is public hello: %s' % msg)\n\n\ndef proxy_hello(msg):\n    print('This is proxy hello: %s' % msg)\n    hello(msg)\n\n\nFile: pyarmor/examples/testpkg/mypkg/foo.py\ndef hello(msg):\n    print('Hello! %s' % msg)\n\n\nFile: pyarmor/examples/testpkg/main.py\nfrom mypkg import title\nfrom mypkg.foo import hello\n\nhello(title)\n\n\nFile: pyarmor/examples/cx_Freeze/setup.py\n# -*- coding: utf-8 -*-\n\n# A very simple setup script to create a single executable\n#\n# hello.py is a very simple 'Hello, world' type script which also displays the\n# environment in which the script runs\n#\n# Run the build process by running the command 'python setup.py build'\n#\n# If everything works well you should find a subdirectory in the build\n# subdirectory that contains the files needed to run the script without Python\n\nfrom cx_Freeze import setup, Executable\n\nexecutables = [\n    Executable('hello.py')\n]\n\nsetup(name='hello',\n      version='0.1',\n      description='Sample cx_Freeze script',\n      executables=executables\n      )\n\n\nFile: pyarmor/examples/cx_Freeze/hello.py\nimport sys\n\nfrom queens import main\n\nmain()\n\n\nFile: pyarmor/examples/cx_Freeze/queens.py\n#!/usr/bin/env python3\n\nfrom __future__ import print_function\n\n\"\"\"\nN queens problem.\n\nThe (well-known) problem is due to Niklaus Wirth.\n\nThis solution is inspired by Dijkstra (Structured Programming).  It is\na classic recursive backtracking approach.\n\"\"\"\n\nN = 8                                   # Default; command line overrides\n\nclass Queens:\n\n    def __init__(self, n=N):\n        self.n = n\n        self.reset()\n\n    def reset(self):\n        n = self.n\n        self.y = [None] * n             # Where is the queen in column x\n        self.row = [0] * n              # Is row[y] safe?\n        self.up = [0] * (2*n-1)         # Is upward diagonal[x-y] safe?\n        self.down = [0] * (2*n-1)       # Is downward diagonal[x+y] safe?\n        self.nfound = 0                 # Instrumentation\n\n    def solve(self, x=0):               # Recursive solver\n        for y in range(self.n):\n            if self.safe(x, y):\n                self.place(x, y)\n                if x+1 == self.n:\n                    self.display()\n                else:\n                    self.solve(x+1)\n                self.remove(x, y)\n\n    def safe(self, x, y):\n        return not self.row[y] and not self.up[x-y] and not self.down[x+y]\n\n    def place(self, x, y):\n        self.y[x] = y\n        self.row[y] = 1\n        self.up[x-y] = 1\n        self.down[x+y] = 1\n\n    def remove(self, x, y):\n        self.y[x] = None\n        self.row[y] = 0\n        self.up[x-y] = 0\n        self.down[x+y] = 0\n\n    silent = 0                          # If true, count solutions only\n\n    def display(self):\n        self.nfound = self.nfound + 1\n        if self.silent:\n            return\n        print('+-' + '--'*self.n + '+')\n        for y in range(self.n-1, -1, -1):\n            print('|', end=' ')\n            for x in range(self.n):\n                if self.y[x] == y:\n                    print(\"Q\", end=' ')\n                else:\n                    print(\".\", end=' ')\n            print('|')\n        print('+-' + '--'*self.n + '+')\n\ndef main():\n    import sys\n    silent = 0\n    n = N\n    if sys.argv[1:2] == ['-n']:\n        silent = 1\n        del sys.argv[1]\n    if sys.argv[1:]:\n        n = int(sys.argv[1])\n    q = Queens(n)\n    q.silent = silent\n    q.solve()\n    print(\"Found\", q.nfound, \"solutions.\")\n\nif __name__ == \"__main__\":\n    main()\n\n\nFile: pyarmor/examples/testmod/hello.py\nimport dis\nimport os\nimport sys\n\n# Import function and class from obfuscated module\nfrom queens import main, Queens\n\n# Call obfuscated function\nmain()\n\n# Check __file__ of obfuscated module \"queens\" is filename in target machine\nimport queens\nif os.path.abspath(queens.__file__) == os.path.abspath(os.path.join(os.path.dirname(__file__), \"queens.py\")):\n  print(\"The value of __file__ is OK\")\n\n# Check __wraparmor__ can't be called out of decorator\ntry:\n  from builtins import __wraparmor__\nexcept Exception:\n  from __builtin__ import __wraparmor__\ntry:\n  __wraparmor__(main)\nexcept Exception as e:\n  print('__wraparmor__ can not be called out of decorator')\n\n# Check filename in trackback\ntry:\n  queens.test_exception()\nexcept Exception:\n  from traceback import print_exc\n  print_exc()\n\n# Check original func can not be got from exception frame\ntry:\n  queens.test_exception()\nexcept Exception:\n  import inspect\n  for exc_tb in inspect.trace():\n    frame = exc_tb[0]\n    print('Found frame of function %s' % exc_tb[3])\n    if frame.f_locals.get('func') is None \\\n       and frame.f_locals.get('filename') is None \\\n       and frame.f_locals.get('n') is None:\n      print('Can not get data from frame.f_locals')\n\n# Check callback\ndef mycallback():\n  frame = sys._getframe(1)\n  if len(frame.f_locals) == 0:\n    print('Got empty from callback')\nqueens.test_callback(mycallback)\n\n# Check generator\na = list(queens.simple_generator(10))\nif len(a) == 10:\n  print('Generator works well')\n\n# Check nested\nfunc1 = queens.factory()\nfunc2 = queens.factory()\nfunc1(func2)\nprint('Shared code object works well')\n  \n# Access original func_code will crash: Segmentation fault\n# print(dis.dis(main.orig_func))\n# print(dis.dis(Queens.solve.orig_func))\n\n\nFile: pyarmor/examples/testmod/queens.py\n#!/usr/bin/env python3\n\nfrom __future__ import print_function\n\n##\n#  Extra code to define decorator \"wraparmor\"\n##\n\nimport sys\n#\n# __wraparmor__ will be added to builtins from bootstrap code of pyarmor\n#\n#   from pytransform import pyarmor_runtime()\n#   pyarmor_runtime()\n#\ntry:\n    from builtins import __wraparmor__\nexcept Exception:\n    from __builtin__ import __wraparmor__\n\ndef wraparmor(func):\n    def wrapper(*args, **kwargs):\n         __wraparmor__(func)\n         tb = None\n         try:\n             return func(*args, **kwargs)\n         except Exception:\n             tb = sys.exc_info()[2]\n             raise\n         finally:\n             __wraparmor__(func, tb, 1)\n    wrapper.__module__ = func.__module__\n    wrapper.__name__ = func.__name__\n    wrapper.__doc__ = func.__doc__\n    wrapper.__dict__.update(func.__dict__)\n    # Only for test\n    wrapper.orig_func = func\n    return wrapper\n\n##\n#  End of extra code\n##\n\n\"\"\"\nN queens problem.\n\nThe (well-known) problem is due to Niklaus Wirth.\n\nThis solution is inspired by Dijkstra (Structured Programming).  It is\na classic recursive backtracking approach.\n\"\"\"\n\nN = 8                                   # Default; command line overrides\n\nclass Queens:\n\n    @wraparmor\n    def __init__(self, n=N):\n        self.n = n\n        self.reset()\n\n    @wraparmor\n    def reset(self):\n        n = self.n\n        self.y = [None] * n             # Where is the queen in column x\n        self.row = [0] * n              # Is row[y] safe?\n        self.up = [0] * (2*n-1)         # Is upward diagonal[x-y] safe?\n        self.down = [0] * (2*n-1)       # Is downward diagonal[x+y] safe?\n        self.nfound = 0                 # Instrumentation\n\n    @wraparmor\n    def solve(self, x=0):               # Recursive solver\n        for y in range(self.n):\n            if self.safe(x, y):\n                self.place(x, y)\n                if x+1 == self.n:\n                    self.display()\n                else:\n                    self.solve(x+1)\n                self.remove(x, y)\n\n    @wraparmor\n    def safe(self, x, y):\n        return not self.row[y] and not self.up[x-y] and not self.down[x+y]\n\n    @wraparmor\n    def place(self, x, y):\n        self.y[x] = y\n        self.row[y] = 1\n        self.up[x-y] = 1\n        self.down[x+y] = 1\n\n    @wraparmor\n    def remove(self, x, y):\n        self.y[x] = None\n        self.row[y] = 0\n        self.up[x-y] = 0\n        self.down[x+y] = 0\n\n    silent = 0                          # If true, count solutions only\n\n    @wraparmor\n    def display(self):\n        self.nfound = self.nfound + 1\n        if self.silent:\n            return\n        print('+-' + '--'*self.n + '+')\n        for y in range(self.n-1, -1, -1):\n            print('|', end=' ')\n            for x in range(self.n):\n                if self.y[x] == y:\n                    print(\"Q\", end=' ')\n                else:\n                    print(\".\", end=' ')\n            print('|')\n        print('+-' + '--'*self.n + '+')\n\n@wraparmor\ndef main():\n    silent = 0\n    n = N\n    if sys.argv[1:2] == ['-n']:\n        silent = 1\n        del sys.argv[1]\n    if sys.argv[1:]:\n        n = int(sys.argv[1])\n    q = Queens(n)\n    q.silent = silent\n    q.solve()\n    print(\"Found\", q.nfound, \"solutions.\")\n\ndef foo(k):\n    k += 1\n    raise Exception('Filename is right or not')\n\n@wraparmor\ndef test_exception(filename='queens.py'):\n    n = 2\n    foo(n)\n\n@wraparmor\ndef test_callback(callback):\n    msg = 'test callback'\n    callback()\n\n@wraparmor\ndef simple_generator(n):\n    for i in range(n):\n        yield i\n\ndef factory():\n    @wraparmor\n    def nestedfunc(f=None):\n        if f:\n            f()\n    return nestedfunc\n\nif __name__ == \"__main__\":\n    main()\n\n\nFile: pyarmor/examples/pybench/package/__init__.py\n\n\nFile: pyarmor/examples/pybench/package/submodule.py\n\n\nFile: pyarmor/examples/pybench/Lists.py\nfrom pybench import Test\n\nclass SimpleListManipulation(Test):\n\n    version = 2.0\n    operations = 5* (6 + 6 + 6)\n    rounds = 130000\n\n    def test(self):\n\n        l = []\n        append = l.append\n\n        for i in range(self.rounds):\n\n            append(2)\n            append(3)\n            append(4)\n            append(2)\n            append(3)\n            append(4)\n\n            l[0] = 3\n            l[1] = 4\n            l[2] = 5\n            l[3] = 3\n            l[4] = 4\n            l[5] = 5\n\n            x = l[0]\n            x = l[1]\n            x = l[2]\n            x = l[3]\n            x = l[4]\n            x = l[5]\n\n            append(2)\n            append(3)\n            append(4)\n            append(2)\n            append(3)\n            append(4)\n\n            l[0] = 3\n            l[1] = 4\n            l[2] = 5\n            l[3] = 3\n            l[4] = 4\n            l[5] = 5\n\n            x = l[0]\n            x = l[1]\n            x = l[2]\n            x = l[3]\n            x = l[4]\n            x = l[5]\n\n            append(2)\n            append(3)\n            append(4)\n            append(2)\n            append(3)\n            append(4)\n\n            l[0] = 3\n            l[1] = 4\n            l[2] = 5\n            l[3] = 3\n            l[4] = 4\n            l[5] = 5\n\n            x = l[0]\n            x = l[1]\n            x = l[2]\n            x = l[3]\n            x = l[4]\n            x = l[5]\n\n            append(2)\n            append(3)\n            append(4)\n            append(2)\n            append(3)\n            append(4)\n\n            l[0] = 3\n            l[1] = 4\n            l[2] = 5\n            l[3] = 3\n            l[4] = 4\n            l[5] = 5\n\n            x = l[0]\n            x = l[1]\n            x = l[2]\n            x = l[3]\n            x = l[4]\n            x = l[5]\n\n            append(2)\n            append(3)\n            append(4)\n            append(2)\n            append(3)\n            append(4)\n\n            l[0] = 3\n            l[1] = 4\n            l[2] = 5\n            l[3] = 3\n            l[4] = 4\n            l[5] = 5\n\n            x = l[0]\n            x = l[1]\n            x = l[2]\n            x = l[3]\n            x = l[4]\n            x = l[5]\n\n            if len(l) > 10000:\n                # cut down the size\n                del l[:]\n\n    def calibrate(self):\n\n        l = []\n        append = l.append\n\n        for i in range(self.rounds):\n            pass\n\nclass ListSlicing(Test):\n\n    version = 2.0\n    operations = 25*(3+1+2+1)\n    rounds = 800\n\n    def test(self):\n\n        n = list(range(100))\n        r = list(range(25))\n\n        for i in range(self.rounds):\n\n            l = n[:]\n\n            for j in r:\n\n                m = l[50:]\n                m = l[:25]\n                m = l[50:55]\n                l[:3] = n\n                m = l[:-1]\n                m = l[1:]\n                l[-1:] = n\n\n    def calibrate(self):\n\n        n = list(range(100))\n        r = list(range(25))\n\n        for i in range(self.rounds):\n            for j in r:\n                pass\n\nclass SmallLists(Test):\n\n    version = 2.0\n    operations = 5*(1+ 6 + 6 + 3 + 1)\n    rounds = 80000\n\n    def test(self):\n\n        for i in range(self.rounds):\n\n            l = []\n\n            append = l.append\n            append(2)\n            append(3)\n            append(4)\n            append(2)\n            append(3)\n            append(4)\n\n            l[0] = 3\n            l[1] = 4\n            l[2] = 5\n            l[3] = 3\n            l[4] = 4\n            l[5] = 5\n\n            l[:3] = [1,2,3]\n            m = l[:-1]\n            m = l[1:]\n\n            l[-1:] = [4,5,6]\n\n            l = []\n\n            append = l.append\n            append(2)\n            append(3)\n            append(4)\n            append(2)\n            append(3)\n            append(4)\n\n            l[0] = 3\n            l[1] = 4\n            l[2] = 5\n            l[3] = 3\n            l[4] = 4\n            l[5] = 5\n\n            l[:3] = [1,2,3]\n            m = l[:-1]\n            m = l[1:]\n\n            l[-1:] = [4,5,6]\n\n            l = []\n\n            append = l.append\n            append(2)\n            append(3)\n            append(4)\n            append(2)\n            append(3)\n            append(4)\n\n            l[0] = 3\n            l[1] = 4\n            l[2] = 5\n            l[3] = 3\n            l[4] = 4\n            l[5] = 5\n\n            l[:3] = [1,2,3]\n            m = l[:-1]\n            m = l[1:]\n\n            l[-1:] = [4,5,6]\n\n            l = []\n\n            append = l.append\n            append(2)\n            append(3)\n            append(4)\n            append(2)\n            append(3)\n            append(4)\n\n            l[0] = 3\n            l[1] = 4\n            l[2] = 5\n            l[3] = 3\n            l[4] = 4\n            l[5] = 5\n\n            l[:3] = [1,2,3]\n            m = l[:-1]\n            m = l[1:]\n\n            l[-1:] = [4,5,6]\n\n            l = []\n\n            append = l.append\n            append(2)\n            append(3)\n            append(4)\n            append(2)\n            append(3)\n            append(4)\n\n            l[0] = 3\n            l[1] = 4\n            l[2] = 5\n            l[3] = 3\n            l[4] = 4\n            l[5] = 5\n\n            l[:3] = [1,2,3]\n            m = l[:-1]\n            m = l[1:]\n\n            l[-1:] = [4,5,6]\n\n    def calibrate(self):\n\n        for i in range(self.rounds):\n            pass\n\nclass SimpleListComprehensions(Test):\n\n    version = 2.0\n    operations = 6\n    rounds = 20000\n\n    def test(self):\n\n        n = list(range(10)) * 10\n\n        for i in range(self.rounds):\n            l = [x for x in n]\n            l = [x for x in n if x]\n            l = [x for x in n if not x]\n\n            l = [x for x in n]\n            l = [x for x in n if x]\n            l = [x for x in n if not x]\n\n    def calibrate(self):\n\n        n = list(range(10)) * 10\n\n        for i in range(self.rounds):\n            pass\n\nclass NestedListComprehensions(Test):\n\n    version = 2.0\n    operations = 6\n    rounds = 20000\n\n    def test(self):\n\n        m = list(range(10))\n        n = list(range(10))\n\n        for i in range(self.rounds):\n            l = [x for x in n for y in m]\n            l = [y for x in n for y in m]\n\n            l = [x for x in n for y in m if y]\n            l = [y for x in n for y in m if x]\n\n            l = [x for x in n for y in m if not y]\n            l = [y for x in n for y in m if not x]\n\n    def calibrate(self):\n\n        m = list(range(10))\n        n = list(range(10))\n\n        for i in range(self.rounds):\n            pass\n\n\nFile: pyarmor/examples/pybench/pybench.py\n#!/usr/local/bin/python -O\n\n\"\"\" A Python Benchmark Suite\n\n\"\"\"\n# Note: Please keep this module compatible to Python 2.6.\n#\n# Tests may include features in later Python versions, but these\n# should then be embedded in try-except clauses in the configuration\n# module Setup.py.\n#\n\nfrom __future__ import print_function\n\n# pybench Copyright\n__copyright__ = \"\"\"\\\nCopyright (c), 1997-2006, Marc-Andre Lemburg (mal@lemburg.com)\nCopyright (c), 2000-2006, eGenix.com Software GmbH (info@egenix.com)\n\n                   All Rights Reserved.\n\nPermission to use, copy, modify, and distribute this software and its\ndocumentation for any purpose and without fee or royalty is hereby\ngranted, provided that the above copyright notice appear in all copies\nand that both that copyright notice and this permission notice appear\nin supporting documentation or portions thereof, including\nmodifications, that you make.\n\nTHE AUTHOR MARC-ANDRE LEMBURG DISCLAIMS ALL WARRANTIES WITH REGARD TO\nTHIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS, IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL,\nINDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING\nFROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,\nNEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION\nWITH THE USE OR PERFORMANCE OF THIS SOFTWARE !\n\"\"\"\n\nimport sys, time, operator, platform\nfrom CommandLine import *\n\ntry:\n    import cPickle\n    pickle = cPickle\nexcept ImportError:\n    import pickle\n\n# Version number; version history: see README file !\n__version__ = '2.1'\n\n### Constants\n\n# Second fractions\nMILLI_SECONDS = 1e3\nMICRO_SECONDS = 1e6\n\n# Percent unit\nPERCENT = 100\n\n# Horizontal line length\nLINE = 79\n\n# Minimum test run-time\nMIN_TEST_RUNTIME = 1e-3\n\n# Number of calibration runs to use for calibrating the tests\nCALIBRATION_RUNS = 20\n\n# Number of calibration loops to run for each calibration run\nCALIBRATION_LOOPS = 20\n\n# Allow skipping calibration ?\nALLOW_SKIPPING_CALIBRATION = 1\n\n# Timer types\nTIMER_TIME_TIME = 'time.time'\nTIMER_TIME_CLOCK = 'time.clock'\nTIMER_SYSTIMES_PROCESSTIME = 'systimes.processtime'\n\n# Choose platform default timer\nif sys.platform[:3] == 'win':\n    # On WinXP this has 2.5ms resolution\n    TIMER_PLATFORM_DEFAULT = TIMER_TIME_CLOCK\nelse:\n    # On Linux this has 1ms resolution\n    TIMER_PLATFORM_DEFAULT = TIMER_TIME_TIME\n\n# Print debug information ?\n_debug = 0\n\n### Helpers\n\ndef get_timer(timertype):\n\n    if timertype == TIMER_TIME_TIME:\n        return time.time\n    elif timertype == TIMER_TIME_CLOCK:\n        return time.clock\n    elif timertype == TIMER_SYSTIMES_PROCESSTIME:\n        import systimes\n        return systimes.processtime\n    else:\n        raise TypeError('unknown timer type: %s' % timertype)\n\ndef get_machine_details():\n\n    if _debug:\n        print('Getting machine details...')\n    buildno, builddate = platform.python_build()\n    python = platform.python_version()\n    if sys.maxunicode == 65535:\n        # UCS2 build (standard)\n        unitype = 'UCS2'\n    else:\n        # UCS4 build (most recent Linux distros)\n        unitype = 'UCS4'\n    bits, linkage = platform.architecture()\n    return {\n        'platform': platform.platform(),\n        'processor': platform.processor(),\n        'executable': sys.executable,\n        'implementation': getattr(platform, 'python_implementation',\n                                  lambda:'n/a')(),\n        'python': platform.python_version(),\n        'compiler': platform.python_compiler(),\n        'buildno': buildno,\n        'builddate': builddate,\n        'unicode': unitype,\n        'bits': bits,\n        }\n\ndef print_machine_details(d, indent=''):\n\n    l = ['Machine Details:',\n         '   Platform ID:    %s' % d.get('platform', 'n/a'),\n         '   Processor:      %s' % d.get('processor', 'n/a'),\n         '',\n         'Python:',\n         '   Implementation: %s' % d.get('implementation', 'n/a'),\n         '   Executable:     %s' % d.get('executable', 'n/a'),\n         '   Version:        %s' % d.get('python', 'n/a'),\n         '   Compiler:       %s' % d.get('compiler', 'n/a'),\n         '   Bits:           %s' % d.get('bits', 'n/a'),\n         '   Build:          %s (#%s)' % (d.get('builddate', 'n/a'),\n                                          d.get('buildno', 'n/a')),\n         '   Unicode:        %s' % d.get('unicode', 'n/a'),\n         ]\n    joiner = '\\n' + indent\n    print(indent + joiner.join(l) + '\\n')\n\n### Test baseclass\n\nclass Test:\n\n    \"\"\" All test must have this class as baseclass. It provides\n        the necessary interface to the benchmark machinery.\n\n        The tests must set .rounds to a value high enough to let the\n        test run between 20-50 seconds. This is needed because\n        clock()-timing only gives rather inaccurate values (on Linux,\n        for example, it is accurate to a few hundreths of a\n        second). If you don't want to wait that long, use a warp\n        factor larger than 1.\n\n        It is also important to set the .operations variable to a\n        value representing the number of \"virtual operations\" done per\n        call of .run().\n\n        If you change a test in some way, don't forget to increase\n        its version number.\n\n    \"\"\"\n\n    ### Instance variables that each test should override\n\n    # Version number of the test as float (x.yy); this is important\n    # for comparisons of benchmark runs - tests with unequal version\n    # number will not get compared.\n    version = 2.1\n\n    # The number of abstract operations done in each round of the\n    # test. An operation is the basic unit of what you want to\n    # measure. The benchmark will output the amount of run-time per\n    # operation. Note that in order to raise the measured timings\n    # significantly above noise level, it is often required to repeat\n    # sets of operations more than once per test round. The measured\n    # overhead per test round should be less than 1 second.\n    operations = 1\n\n    # Number of rounds to execute per test run. This should be\n    # adjusted to a figure that results in a test run-time of between\n    # 1-2 seconds.\n    rounds = 100000\n\n    ### Internal variables\n\n    # Mark this class as implementing a test\n    is_a_test = 1\n\n    # Last timing: (real, run, overhead)\n    last_timing = (0.0, 0.0, 0.0)\n\n    # Warp factor to use for this test\n    warp = 1\n\n    # Number of calibration runs to use\n    calibration_runs = CALIBRATION_RUNS\n\n    # List of calibration timings\n    overhead_times = None\n\n    # List of test run timings\n    times = []\n\n    # Timer used for the benchmark\n    timer = TIMER_PLATFORM_DEFAULT\n\n    def __init__(self, warp=None, calibration_runs=None, timer=None):\n\n        # Set parameters\n        if warp is not None:\n            self.rounds = int(self.rounds / warp)\n            if self.rounds == 0:\n                raise ValueError('warp factor set too high')\n            self.warp = warp\n        if calibration_runs is not None:\n            if (not ALLOW_SKIPPING_CALIBRATION and\n                calibration_runs < 1):\n                raise ValueError('at least one calibration run is required')\n            self.calibration_runs = calibration_runs\n        if timer is not None:\n            self.timer = timer\n\n        # Init variables\n        self.times = []\n        self.overhead_times = []\n\n        # We want these to be in the instance dict, so that pickle\n        # saves them\n        self.version = self.version\n        self.operations = self.operations\n        self.rounds = self.rounds\n\n    def get_timer(self):\n\n        \"\"\" Return the timer function to use for the test.\n\n        \"\"\"\n        return get_timer(self.timer)\n\n    def compatible(self, other):\n\n        \"\"\" Return 1/0 depending on whether the test is compatible\n            with the other Test instance or not.\n\n        \"\"\"\n        if self.version != other.version:\n            return 0\n        if self.rounds != other.rounds:\n            return 0\n        return 1\n\n    def calibrate_test(self):\n\n        if self.calibration_runs == 0:\n            self.overhead_times = [0.0]\n            return\n\n        calibrate = self.calibrate\n        timer = self.get_timer()\n        calibration_loops = range(CALIBRATION_LOOPS)\n\n        # Time the calibration loop overhead\n        prep_times = []\n        for i in range(self.calibration_runs):\n            t = timer()\n            for i in calibration_loops:\n                pass\n            t = timer() - t\n            prep_times.append(t)\n        min_prep_time = min(prep_times)\n        if _debug:\n            print()\n            print('Calib. prep time     = %.6fms' % (\n                min_prep_time * MILLI_SECONDS))\n\n        # Time the calibration runs (doing CALIBRATION_LOOPS loops of\n        # .calibrate() method calls each)\n        for i in range(self.calibration_runs):\n            t = timer()\n            for i in calibration_loops:\n                calibrate()\n            t = timer() - t\n            self.overhead_times.append(t / CALIBRATION_LOOPS\n                                       - min_prep_time)\n\n        # Check the measured times\n        min_overhead = min(self.overhead_times)\n        max_overhead = max(self.overhead_times)\n        if _debug:\n            print('Calib. overhead time = %.6fms' % (\n                min_overhead * MILLI_SECONDS))\n        if min_overhead < 0.0:\n            raise ValueError('calibration setup did not work')\n        if max_overhead - min_overhead > 0.1:\n            raise ValueError(\n                'overhead calibration timing range too inaccurate: '\n                '%r - %r' % (min_overhead, max_overhead))\n\n    def run(self):\n\n        \"\"\" Run the test in two phases: first calibrate, then\n            do the actual test. Be careful to keep the calibration\n            timing low w/r to the test timing.\n\n        \"\"\"\n        test = self.test\n        timer = self.get_timer()\n\n        # Get calibration\n        min_overhead = min(self.overhead_times)\n\n        # Test run\n        t = timer()\n        test()\n        t = timer() - t\n        if t < MIN_TEST_RUNTIME:\n            raise ValueError('warp factor too high: '\n                             'test times are < 10ms')\n        eff_time = t - min_overhead\n        if eff_time < 0:\n            raise ValueError('wrong calibration')\n        self.last_timing = (eff_time, t, min_overhead)\n        self.times.append(eff_time)\n\n    def calibrate(self):\n\n        \"\"\" Calibrate the test.\n\n            This method should execute everything that is needed to\n            setup and run the test - except for the actual operations\n            that you intend to measure. pybench uses this method to\n            measure the test implementation overhead.\n\n        \"\"\"\n        return\n\n    def test(self):\n\n        \"\"\" Run the test.\n\n            The test needs to run self.rounds executing\n            self.operations number of operations each.\n\n        \"\"\"\n        return\n\n    def stat(self):\n\n        \"\"\" Return test run statistics as tuple:\n\n            (minimum run time,\n             average run time,\n             total run time,\n             average time per operation,\n             minimum overhead time)\n\n        \"\"\"\n        runs = len(self.times)\n        if runs == 0:\n            return 0.0, 0.0, 0.0, 0.0\n        min_time = min(self.times)\n        total_time = sum(self.times)\n        avg_time = total_time / float(runs)\n        operation_avg = total_time / float(runs\n                                           * self.rounds\n                                           * self.operations)\n        if self.overhead_times:\n            min_overhead = min(self.overhead_times)\n        else:\n            min_overhead = self.last_timing[2]\n        return min_time, avg_time, total_time, operation_avg, min_overhead\n\n### Load Setup\n\n# This has to be done after the definition of the Test class, since\n# the Setup module will import subclasses using this class.\n\nimport Setup\n\n### Benchmark base class\n\nclass Benchmark:\n\n    # Name of the benchmark\n    name = ''\n\n    # Number of benchmark rounds to run\n    rounds = 1\n\n    # Warp factor use to run the tests\n    warp = 1                    # Warp factor\n\n    # Average benchmark round time\n    roundtime = 0\n\n    # Benchmark version number as float x.yy\n    version = 2.1\n\n    # Produce verbose output ?\n    verbose = 0\n\n    # Dictionary with the machine details\n    machine_details = None\n\n    # Timer used for the benchmark\n    timer = TIMER_PLATFORM_DEFAULT\n\n    def __init__(self, name, verbose=None, timer=None, warp=None,\n                 calibration_runs=None):\n\n        if name:\n            self.name = name\n        else:\n            self.name = '%04i-%02i-%02i %02i:%02i:%02i' % \\\n                        (time.localtime(time.time())[:6])\n        if verbose is not None:\n            self.verbose = verbose\n        if timer is not None:\n            self.timer = timer\n        if warp is not None:\n            self.warp = warp\n        if calibration_runs is not None:\n            self.calibration_runs = calibration_runs\n\n        # Init vars\n        self.tests = {}\n        if _debug:\n            print('Getting machine details...')\n        self.machine_details = get_machine_details()\n\n        # Make .version an instance attribute to have it saved in the\n        # Benchmark pickle\n        self.version = self.version\n\n    def get_timer(self):\n\n        \"\"\" Return the timer function to use for the test.\n\n        \"\"\"\n        return get_timer(self.timer)\n\n    def compatible(self, other):\n\n        \"\"\" Return 1/0 depending on whether the benchmark is\n            compatible with the other Benchmark instance or not.\n\n        \"\"\"\n        if self.version != other.version:\n            return 0\n        if (self.machine_details == other.machine_details and\n            self.timer != other.timer):\n            return 0\n        if (self.calibration_runs == 0 and\n            other.calibration_runs != 0):\n            return 0\n        if (self.calibration_runs != 0 and\n            other.calibration_runs == 0):\n            return 0\n        return 1\n\n    def load_tests(self, setupmod, limitnames=None):\n\n        # Add tests\n        if self.verbose:\n            print('Searching for tests ...')\n            print('--------------------------------------')\n        for testclass in setupmod.__dict__.values():\n            if not hasattr(testclass, 'is_a_test'):\n                continue\n            name = testclass.__name__\n            if  name == 'Test':\n                continue\n            if (limitnames is not None and\n                limitnames.search(name) is None):\n                continue\n            self.tests[name] = testclass(\n                warp=self.warp,\n                calibration_runs=self.calibration_runs,\n                timer=self.timer)\n        l = sorted(self.tests)\n        if self.verbose:\n            for name in l:\n                print('  %s' % name)\n            print('--------------------------------------')\n            print('  %i tests found' % len(l))\n            print()\n\n    def calibrate(self):\n\n        print('Calibrating tests. Please wait...', end=' ')\n        sys.stdout.flush()\n        if self.verbose:\n            print()\n            print()\n            print('Test                              min      max')\n            print('-' * LINE)\n        tests = sorted(self.tests.items())\n        for i in range(len(tests)):\n            name, test = tests[i]\n            test.calibrate_test()\n            if self.verbose:\n                print('%30s:  %6.3fms  %6.3fms' % \\\n                      (name,\n                       min(test.overhead_times) * MILLI_SECONDS,\n                       max(test.overhead_times) * MILLI_SECONDS))\n        if self.verbose:\n            print()\n            print('Done with the calibration.')\n        else:\n            print('done.')\n        print()\n\n    def run(self):\n\n        tests = sorted(self.tests.items())\n        timer = self.get_timer()\n        print('Running %i round(s) of the suite at warp factor %i:' % \\\n              (self.rounds, self.warp))\n        print()\n        self.roundtimes = []\n        for i in range(self.rounds):\n            if self.verbose:\n                print(' Round %-25i  effective   absolute  overhead' % (i+1))\n            total_eff_time = 0.0\n            for j in range(len(tests)):\n                name, test = tests[j]\n                if self.verbose:\n                    print('%30s:' % name, end=' ')\n                test.run()\n                (eff_time, abs_time, min_overhead) = test.last_timing\n                total_eff_time = total_eff_time + eff_time\n                if self.verbose:\n                    print('    %5.0fms    %5.0fms %7.3fms' % \\\n                          (eff_time * MILLI_SECONDS,\n                           abs_time * MILLI_SECONDS,\n                           min_overhead * MILLI_SECONDS))\n            self.roundtimes.append(total_eff_time)\n            if self.verbose:\n                print('                   '\n                       '               ------------------------------')\n                print('                   '\n                       '     Totals:    %6.0fms' %\n                       (total_eff_time * MILLI_SECONDS))\n                print()\n            else:\n                print('* Round %i done in %.3f seconds.' % (i+1,\n                                                            total_eff_time))\n        print()\n\n    def stat(self):\n\n        \"\"\" Return benchmark run statistics as tuple:\n\n            (minimum round time,\n             average round time,\n             maximum round time)\n\n            XXX Currently not used, since the benchmark does test\n                statistics across all rounds.\n\n        \"\"\"\n        runs = len(self.roundtimes)\n        if runs == 0:\n            return 0.0, 0.0\n        min_time = min(self.roundtimes)\n        total_time = sum(self.roundtimes)\n        avg_time = total_time / float(runs)\n        max_time = max(self.roundtimes)\n        return (min_time, avg_time, max_time)\n\n    def print_header(self, title='Benchmark'):\n\n        print('-' * LINE)\n        print('%s: %s' % (title, self.name))\n        print('-' * LINE)\n        print()\n        print('    Rounds: %s' % self.rounds)\n        print('    Warp:   %s' % self.warp)\n        print('    Timer:  %s' % self.timer)\n        print()\n        if self.machine_details:\n            print_machine_details(self.machine_details, indent='    ')\n            print()\n\n    def print_benchmark(self, hidenoise=0, limitnames=None):\n\n        print('Test                          '\n               '   minimum  average  operation  overhead')\n        print('-' * LINE)\n        tests = sorted(self.tests.items())\n        total_min_time = 0.0\n        total_avg_time = 0.0\n        for name, test in tests:\n            if (limitnames is not None and\n                limitnames.search(name) is None):\n                continue\n            (min_time,\n             avg_time,\n             total_time,\n             op_avg,\n             min_overhead) = test.stat()\n            total_min_time = total_min_time + min_time\n            total_avg_time = total_avg_time + avg_time\n            print('%30s:  %5.0fms  %5.0fms  %6.2fus  %7.3fms' % \\\n                  (name,\n                   min_time * MILLI_SECONDS,\n                   avg_time * MILLI_SECONDS,\n                   op_avg * MICRO_SECONDS,\n                   min_overhead *MILLI_SECONDS))\n        print('-' * LINE)\n        print('Totals:                        '\n               ' %6.0fms %6.0fms' %\n               (total_min_time * MILLI_SECONDS,\n                total_avg_time * MILLI_SECONDS,\n                ))\n        print()\n\n    def print_comparison(self, compare_to, hidenoise=0, limitnames=None):\n\n        # Check benchmark versions\n        if compare_to.version != self.version:\n            print('* Benchmark versions differ: '\n                   'cannot compare this benchmark to \"%s\" !' %\n                   compare_to.name)\n            print()\n            self.print_benchmark(hidenoise=hidenoise,\n                                 limitnames=limitnames)\n            return\n\n        # Print header\n        compare_to.print_header('Comparing with')\n        print('Test                          '\n               '   minimum run-time        average  run-time')\n        print('                              '\n               '   this    other   diff    this    other   diff')\n        print('-' * LINE)\n\n        # Print test comparisons\n        tests = sorted(self.tests.items())\n        total_min_time = other_total_min_time = 0.0\n        total_avg_time = other_total_avg_time = 0.0\n        benchmarks_compatible = self.compatible(compare_to)\n        tests_compatible = 1\n        for name, test in tests:\n            if (limitnames is not None and\n                limitnames.search(name) is None):\n                continue\n            (min_time,\n             avg_time,\n             total_time,\n             op_avg,\n             min_overhead) = test.stat()\n            total_min_time = total_min_time + min_time\n            total_avg_time = total_avg_time + avg_time\n            try:\n                other = compare_to.tests[name]\n            except KeyError:\n                other = None\n            if other is None:\n                # Other benchmark doesn't include the given test\n                min_diff, avg_diff = 'n/a', 'n/a'\n                other_min_time = 0.0\n                other_avg_time = 0.0\n                tests_compatible = 0\n            else:\n                (other_min_time,\n                 other_avg_time,\n                 other_total_time,\n                 other_op_avg,\n                 other_min_overhead) = other.stat()\n                other_total_min_time = other_total_min_time + other_min_time\n                other_total_avg_time = other_total_avg_time + other_avg_time\n                if (benchmarks_compatible and\n                    test.compatible(other)):\n                    # Both benchmark and tests are comparible\n                    min_diff = ((min_time * self.warp) /\n                                (other_min_time * other.warp) - 1.0)\n                    avg_diff = ((avg_time * self.warp) /\n                                (other_avg_time * other.warp) - 1.0)\n                    if hidenoise and abs(min_diff) < 10.0:\n                        min_diff = ''\n                    else:\n                        min_diff = '%+5.1f%%' % (min_diff * PERCENT)\n                    if hidenoise and abs(avg_diff) < 10.0:\n                        avg_diff = ''\n                    else:\n                        avg_diff = '%+5.1f%%' % (avg_diff * PERCENT)\n                else:\n                    # Benchmark or tests are not comparible\n                    min_diff, avg_diff = 'n/a', 'n/a'\n                    tests_compatible = 0\n            print('%30s: %5.0fms %5.0fms %7s %5.0fms %5.0fms %7s' % \\\n                  (name,\n                   min_time * MILLI_SECONDS,\n                   other_min_time * MILLI_SECONDS * compare_to.warp / self.warp,\n                   min_diff,\n                   avg_time * MILLI_SECONDS,\n                   other_avg_time * MILLI_SECONDS * compare_to.warp / self.warp,\n                   avg_diff))\n        print('-' * LINE)\n\n        # Summarise test results\n        if not benchmarks_compatible or not tests_compatible:\n            min_diff, avg_diff = 'n/a', 'n/a'\n        else:\n            if other_total_min_time != 0.0:\n                min_diff = '%+5.1f%%' % (\n                    ((total_min_time * self.warp) /\n                     (other_total_min_time * compare_to.warp) - 1.0) * PERCENT)\n            else:\n                min_diff = 'n/a'\n            if other_total_avg_time != 0.0:\n                avg_diff = '%+5.1f%%' % (\n                    ((total_avg_time * self.warp) /\n                     (other_total_avg_time * compare_to.warp) - 1.0) * PERCENT)\n            else:\n                avg_diff = 'n/a'\n        print('Totals:                       '\n               '  %5.0fms %5.0fms %7s %5.0fms %5.0fms %7s' %\n               (total_min_time * MILLI_SECONDS,\n                (other_total_min_time * compare_to.warp/self.warp\n                 * MILLI_SECONDS),\n                min_diff,\n                total_avg_time * MILLI_SECONDS,\n                (other_total_avg_time * compare_to.warp/self.warp\n                 * MILLI_SECONDS),\n                avg_diff\n               ))\n        print()\n        print('(this=%s, other=%s)' % (self.name,\n                                       compare_to.name))\n        print()\n\nclass PyBenchCmdline(Application):\n\n    header = (\"PYBENCH - a benchmark test suite for Python \"\n              \"interpreters/compilers.\")\n\n    version = __version__\n\n    debug = _debug\n\n    options = [ArgumentOption('-n',\n                              'number of rounds',\n                              Setup.Number_of_rounds),\n               ArgumentOption('-f',\n                              'save benchmark to file arg',\n                              ''),\n               ArgumentOption('-c',\n                              'compare benchmark with the one in file arg',\n                              ''),\n               ArgumentOption('-s',\n                              'show benchmark in file arg, then exit',\n                              ''),\n               ArgumentOption('-w',\n                              'set warp factor to arg',\n                              Setup.Warp_factor),\n               ArgumentOption('-t',\n                              'run only tests with names matching arg',\n                              ''),\n               ArgumentOption('-C',\n                              'set the number of calibration runs to arg',\n                              CALIBRATION_RUNS),\n               SwitchOption('-d',\n                            'hide noise in comparisons',\n                            0),\n               SwitchOption('-v',\n                            'verbose output (not recommended)',\n                            0),\n               SwitchOption('--with-gc',\n                            'enable garbage collection',\n                            0),\n               SwitchOption('--with-syscheck',\n                            'use default sys check interval',\n                            0),\n               ArgumentOption('--timer',\n                            'use given timer',\n                            TIMER_PLATFORM_DEFAULT),\n               ]\n\n    about = \"\"\"\\\nThe normal operation is to run the suite and display the\nresults. Use -f to save them for later reuse or comparisons.\n\nAvailable timers:\n\n   time.time\n   time.clock\n   systimes.processtime\n\nExamples:\n\npython2.1 pybench.py -f p21.pybench\npython2.5 pybench.py -f p25.pybench\npython pybench.py -s p25.pybench -c p21.pybench\n\"\"\"\n    copyright = __copyright__\n\n    def main(self):\n\n        rounds = self.values['-n']\n        reportfile = self.values['-f']\n        show_bench = self.values['-s']\n        compare_to = self.values['-c']\n        hidenoise = self.values['-d']\n        warp = int(self.values['-w'])\n        withgc = self.values['--with-gc']\n        limitnames = self.values['-t']\n        if limitnames:\n            if _debug:\n                print('* limiting test names to one with substring \"%s\"' % \\\n                      limitnames)\n            limitnames = re.compile(limitnames, re.I)\n        else:\n            limitnames = None\n        verbose = self.verbose\n        withsyscheck = self.values['--with-syscheck']\n        calibration_runs = self.values['-C']\n        timer = self.values['--timer']\n\n        print('-' * LINE)\n        print('PYBENCH %s' % __version__)\n        print('-' * LINE)\n        print('* using %s %s' % (\n            getattr(platform, 'python_implementation', lambda:'Python')(),\n            ' '.join(sys.version.split())))\n\n        # Switch off garbage collection\n        if not withgc:\n            try:\n                import gc\n            except ImportError:\n                print('* Python version doesn\\'t support garbage collection')\n            else:\n                try:\n                    gc.disable()\n                except NotImplementedError:\n                    print('* Python version doesn\\'t support gc.disable')\n                else:\n                    print('* disabled garbage collection')\n\n        # \"Disable\" sys check interval\n        if not withsyscheck:\n            # Too bad the check interval uses an int instead of a long...\n            value = 2147483647\n            try:\n                sys.setcheckinterval(value)\n            except (AttributeError, NotImplementedError):\n                print('* Python version doesn\\'t support sys.setcheckinterval')\n            else:\n                print('* system check interval set to maximum: %s' % value)\n\n        if timer == TIMER_SYSTIMES_PROCESSTIME:\n            import systimes\n            print('* using timer: systimes.processtime (%s)' % \\\n                  systimes.SYSTIMES_IMPLEMENTATION)\n        else:\n            print('* using timer: %s' % timer)\n\n        print()\n\n        if compare_to:\n            try:\n                f = open(compare_to,'rb')\n                bench = pickle.load(f)\n                bench.name = compare_to\n                f.close()\n                compare_to = bench\n            except IOError as reason:\n                print('* Error opening/reading file %s: %s' % (\n                    repr(compare_to),\n                    reason))\n                compare_to = None\n\n        if show_bench:\n            try:\n                f = open(show_bench,'rb')\n                bench = pickle.load(f)\n                bench.name = show_bench\n                f.close()\n                bench.print_header()\n                if compare_to:\n                    bench.print_comparison(compare_to,\n                                           hidenoise=hidenoise,\n                                           limitnames=limitnames)\n                else:\n                    bench.print_benchmark(hidenoise=hidenoise,\n                                          limitnames=limitnames)\n            except IOError as reason:\n                print('* Error opening/reading file %s: %s' % (\n                    repr(show_bench),\n                    reason))\n                print()\n            return\n\n        if reportfile:\n            print('Creating benchmark: %s (rounds=%i, warp=%i)' % \\\n                  (reportfile, rounds, warp))\n            print()\n\n        # Create benchmark object\n        bench = Benchmark(reportfile,\n                          verbose=verbose,\n                          timer=timer,\n                          warp=warp,\n                          calibration_runs=calibration_runs)\n        bench.rounds = rounds\n        bench.load_tests(Setup, limitnames=limitnames)\n        try:\n            bench.calibrate()\n            bench.run()\n        except KeyboardInterrupt:\n            print()\n            print('*** KeyboardInterrupt -- Aborting')\n            print()\n            return\n        bench.print_header()\n        if compare_to:\n            bench.print_comparison(compare_to,\n                                   hidenoise=hidenoise,\n                                   limitnames=limitnames)\n        else:\n            bench.print_benchmark(hidenoise=hidenoise,\n                                  limitnames=limitnames)\n\n        # Ring bell\n        sys.stderr.write('\\007')\n\n        if reportfile:\n            try:\n                f = open(reportfile,'wb')\n                bench.name = reportfile\n                pickle.dump(bench,f)\n                f.close()\n            except IOError as reason:\n                print('* Error opening/writing reportfile')\n            except IOError as reason:\n                print('* Error opening/writing reportfile %s: %s' % (\n                    reportfile,\n                    reason))\n                print()\n\nif __name__ == '__main__':\n    PyBenchCmdline()\n\n\nFile: pyarmor/examples/pybench/Strings.py\nfrom pybench import Test\nimport sys\n\ntry:\n    intern\nexcept NameError:\n    intern = sys.intern\n\n\nclass ConcatStrings(Test):\n\n    version = 2.0\n    operations = 10 * 5\n    rounds = 100000\n\n    def test(self):\n\n        # Make sure the strings are *not* interned\n        s = ''.join(map(str,range(100)))\n        t = ''.join(map(str,range(1,101)))\n\n        for i in range(self.rounds):\n            t + s\n            t + s\n            t + s\n            t + s\n            t + s\n\n            t + s\n            t + s\n            t + s\n            t + s\n            t + s\n\n            t + s\n            t + s\n            t + s\n            t + s\n            t + s\n\n            t + s\n            t + s\n            t + s\n            t + s\n            t + s\n\n            t + s\n            t + s\n            t + s\n            t + s\n            t + s\n\n            t + s\n            t + s\n            t + s\n            t + s\n            t + s\n\n            t + s\n            t + s\n            t + s\n            t + s\n            t + s\n\n            t + s\n            t + s\n            t + s\n            t + s\n            t + s\n\n            t + s\n            t + s\n            t + s\n            t + s\n            t + s\n\n            t + s\n            t + s\n            t + s\n            t + s\n            t + s\n\n    def calibrate(self):\n\n        s = ''.join(map(str,range(100)))\n        t = ''.join(map(str,range(1,101)))\n\n        for i in range(self.rounds):\n            pass\n\n\nclass CompareStrings(Test):\n\n    version = 2.0\n    operations = 10 * 5\n    rounds = 200000\n\n    def test(self):\n\n        # Make sure the strings are *not* interned\n        s = ''.join(map(str,range(10)))\n        t = ''.join(map(str,range(10))) + \"abc\"\n\n        for i in range(self.rounds):\n            t < s\n            t > s\n            t == s\n            t > s\n            t < s\n\n            t < s\n            t > s\n            t == s\n            t > s\n            t < s\n\n            t < s\n            t > s\n            t == s\n            t > s\n            t < s\n\n            t < s\n            t > s\n            t == s\n            t > s\n            t < s\n\n            t < s\n            t > s\n            t == s\n            t > s\n            t < s\n\n            t < s\n            t > s\n            t == s\n            t > s\n            t < s\n\n            t < s\n            t > s\n            t == s\n            t > s\n            t < s\n\n            t < s\n            t > s\n            t == s\n            t > s\n            t < s\n\n            t < s\n            t > s\n            t == s\n            t > s\n            t < s\n\n            t < s\n            t > s\n            t == s\n            t > s\n            t < s\n\n    def calibrate(self):\n\n        s = ''.join(map(str,range(10)))\n        t = ''.join(map(str,range(10))) + \"abc\"\n\n        for i in range(self.rounds):\n            pass\n\n\nclass CompareInternedStrings(Test):\n\n    version = 2.0\n    operations = 10 * 5\n    rounds = 300000\n\n    def test(self):\n\n        # Make sure the strings *are* interned\n        s = intern(''.join(map(str,range(10))))\n        t = s\n\n        for i in range(self.rounds):\n            t == s\n            t == s\n            t >= s\n            t > s\n            t < s\n\n            t == s\n            t == s\n            t >= s\n            t > s\n            t < s\n\n            t == s\n            t == s\n            t >= s\n            t > s\n            t < s\n\n            t == s\n            t == s\n            t >= s\n            t > s\n            t < s\n\n            t == s\n            t == s\n            t >= s\n            t > s\n            t < s\n\n            t == s\n            t == s\n            t >= s\n            t > s\n            t < s\n\n            t == s\n            t == s\n            t >= s\n            t > s\n            t < s\n\n            t == s\n            t == s\n            t >= s\n            t > s\n            t < s\n\n            t == s\n            t == s\n            t >= s\n            t > s\n            t < s\n\n            t == s\n            t == s\n            t >= s\n            t > s\n            t < s\n\n    def calibrate(self):\n\n        s = intern(''.join(map(str,range(10))))\n        t = s\n\n        for i in range(self.rounds):\n            pass\n\n\nclass CreateStringsWithConcat(Test):\n\n    version = 2.0\n    operations = 10 * 5\n    rounds = 200000\n\n    def test(self):\n\n        for i in range(self.rounds):\n            s = 'om'\n            s = s + 'xbx'\n            s = s + 'xcx'\n            s = s + 'xdx'\n            s = s + 'xex'\n\n            s = s + 'xax'\n            s = s + 'xbx'\n            s = s + 'xcx'\n            s = s + 'xdx'\n            s = s + 'xex'\n\n            s = s + 'xax'\n            s = s + 'xbx'\n            s = s + 'xcx'\n            s = s + 'xdx'\n            s = s + 'xex'\n\n            s = s + 'xax'\n            s = s + 'xbx'\n            s = s + 'xcx'\n            s = s + 'xdx'\n            s = s + 'xex'\n\n            s = s + 'xax'\n            s = s + 'xbx'\n            s = s + 'xcx'\n            s = s + 'xdx'\n            s = s + 'xex'\n\n            s = s + 'xax'\n            s = s + 'xbx'\n            s = s + 'xcx'\n            s = s + 'xdx'\n            s = s + 'xex'\n\n            s = s + 'xax'\n            s = s + 'xbx'\n            s = s + 'xcx'\n            s = s + 'xdx'\n            s = s + 'xex'\n\n            s = s + 'xax'\n            s = s + 'xbx'\n            s = s + 'xcx'\n            s = s + 'xdx'\n            s = s + 'xex'\n\n            s = s + 'xax'\n            s = s + 'xbx'\n            s = s + 'xcx'\n            s = s + 'xdx'\n            s = s + 'xex'\n\n            s = s + 'xax'\n            s = s + 'xbx'\n            s = s + 'xcx'\n            s = s + 'xdx'\n            s = s + 'xex'\n\n    def calibrate(self):\n\n        for i in range(self.rounds):\n            pass\n\n\nclass StringSlicing(Test):\n\n    version = 2.0\n    operations = 5 * 7\n    rounds = 160000\n\n    def test(self):\n\n        s = ''.join(map(str,range(100)))\n\n        for i in range(self.rounds):\n\n            s[50:]\n            s[:25]\n            s[50:55]\n            s[-1:]\n            s[:1]\n            s[2:]\n            s[11:-11]\n\n            s[50:]\n            s[:25]\n            s[50:55]\n            s[-1:]\n            s[:1]\n            s[2:]\n            s[11:-11]\n\n            s[50:]\n            s[:25]\n            s[50:55]\n            s[-1:]\n            s[:1]\n            s[2:]\n            s[11:-11]\n\n            s[50:]\n            s[:25]\n            s[50:55]\n            s[-1:]\n            s[:1]\n            s[2:]\n            s[11:-11]\n\n            s[50:]\n            s[:25]\n            s[50:55]\n            s[-1:]\n            s[:1]\n            s[2:]\n            s[11:-11]\n\n    def calibrate(self):\n\n        s = ''.join(map(str,range(100)))\n\n        for i in range(self.rounds):\n            pass\n\n### String methods\n\nif hasattr('', 'lower'):\n\n    class StringMappings(Test):\n\n        version = 2.0\n        operations = 3 * (5 + 4 + 2 + 1)\n        rounds = 70000\n\n        def test(self):\n\n            s = ''.join(map(chr,range(20)))\n            t = ''.join(map(chr,range(50)))\n            u = ''.join(map(chr,range(100)))\n            v = ''.join(map(chr,range(256)))\n\n            for i in range(self.rounds):\n\n                s.lower()\n                s.lower()\n                s.lower()\n                s.lower()\n                s.lower()\n\n                s.upper()\n                s.upper()\n                s.upper()\n                s.upper()\n                s.upper()\n\n                s.title()\n                s.title()\n                s.title()\n                s.title()\n                s.title()\n\n                t.lower()\n                t.lower()\n                t.lower()\n                t.lower()\n\n                t.upper()\n                t.upper()\n                t.upper()\n                t.upper()\n\n                t.title()\n                t.title()\n                t.title()\n                t.title()\n\n                u.lower()\n                u.lower()\n\n                u.upper()\n                u.upper()\n\n                u.title()\n                u.title()\n\n                v.lower()\n\n                v.upper()\n\n                v.title()\n\n        def calibrate(self):\n\n            s = ''.join(map(chr,range(20)))\n            t = ''.join(map(chr,range(50)))\n            u = ''.join(map(chr,range(100)))\n            v = ''.join(map(chr,range(256)))\n\n            for i in range(self.rounds):\n                pass\n\n    class StringPredicates(Test):\n\n        version = 2.0\n        operations = 10 * 7\n        rounds = 100000\n\n        def test(self):\n\n            data = ('abc', '123', '   ', '\\xe4\\xf6\\xfc', '\\xdf'*10)\n            len_data = len(data)\n\n            for i in range(self.rounds):\n                s = data[i % len_data]\n\n                s.isalnum()\n                s.isalpha()\n                s.isdigit()\n                s.islower()\n                s.isspace()\n                s.istitle()\n                s.isupper()\n\n                s.isalnum()\n                s.isalpha()\n                s.isdigit()\n                s.islower()\n                s.isspace()\n                s.istitle()\n                s.isupper()\n\n                s.isalnum()\n                s.isalpha()\n                s.isdigit()\n                s.islower()\n                s.isspace()\n                s.istitle()\n                s.isupper()\n\n                s.isalnum()\n                s.isalpha()\n                s.isdigit()\n                s.islower()\n                s.isspace()\n                s.istitle()\n                s.isupper()\n\n                s.isalnum()\n                s.isalpha()\n                s.isdigit()\n                s.islower()\n                s.isspace()\n                s.istitle()\n                s.isupper()\n\n                s.isalnum()\n                s.isalpha()\n                s.isdigit()\n                s.islower()\n                s.isspace()\n                s.istitle()\n                s.isupper()\n\n                s.isalnum()\n                s.isalpha()\n                s.isdigit()\n                s.islower()\n                s.isspace()\n                s.istitle()\n                s.isupper()\n\n                s.isalnum()\n                s.isalpha()\n                s.isdigit()\n                s.islower()\n                s.isspace()\n                s.istitle()\n                s.isupper()\n\n                s.isalnum()\n                s.isalpha()\n                s.isdigit()\n                s.islower()\n                s.isspace()\n                s.istitle()\n                s.isupper()\n\n                s.isalnum()\n                s.isalpha()\n                s.isdigit()\n                s.islower()\n                s.isspace()\n                s.istitle()\n                s.isupper()\n\n        def calibrate(self):\n\n            data = ('abc', '123', '   ', '\\u1234\\u2345\\u3456', '\\uFFFF'*10)\n            data = ('abc', '123', '   ', '\\xe4\\xf6\\xfc', '\\xdf'*10)\n            len_data = len(data)\n\n            for i in range(self.rounds):\n                s = data[i % len_data]\n\n\nFile: pyarmor/examples/pybench/With.py\nfrom __future__ import with_statement\nfrom pybench import Test\n\nclass WithFinally(Test):\n\n    version = 2.0\n    operations = 20\n    rounds = 80000\n\n    class ContextManager(object):\n        def __enter__(self):\n            pass\n        def __exit__(self, exc, val, tb):\n            pass\n\n    def test(self):\n\n        cm = self.ContextManager()\n\n        for i in range(self.rounds):\n            with cm: pass\n            with cm: pass\n            with cm: pass\n            with cm: pass\n            with cm: pass\n            with cm: pass\n            with cm: pass\n            with cm: pass\n            with cm: pass\n            with cm: pass\n            with cm: pass\n            with cm: pass\n            with cm: pass\n            with cm: pass\n            with cm: pass\n            with cm: pass\n            with cm: pass\n            with cm: pass\n            with cm: pass\n            with cm: pass\n\n    def calibrate(self):\n\n        cm = self.ContextManager()\n\n        for i in range(self.rounds):\n            pass\n\n\nclass TryFinally(Test):\n\n    version = 2.0\n    operations = 20\n    rounds = 80000\n\n    class ContextManager(object):\n        def __enter__(self):\n            pass\n        def __exit__(self):\n            # \"Context manager\" objects used just for their cleanup\n            # actions in finally blocks usually don't have parameters.\n            pass\n\n    def test(self):\n\n        cm = self.ContextManager()\n\n        for i in range(self.rounds):\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n            cm.__enter__()\n            try: pass\n            finally: cm.__exit__()\n\n    def calibrate(self):\n\n        cm = self.ContextManager()\n\n        for i in range(self.rounds):\n            pass\n\n\nclass WithRaiseExcept(Test):\n\n    version = 2.0\n    operations = 2 + 3 + 3\n    rounds = 100000\n\n    class BlockExceptions(object):\n        def __enter__(self):\n            pass\n        def __exit__(self, exc, val, tb):\n            return True\n\n    def test(self):\n\n        error = ValueError\n        be = self.BlockExceptions()\n\n        for i in range(self.rounds):\n            with be: raise error\n            with be: raise error\n            with be: raise error(\"something\")\n            with be: raise error(\"something\")\n            with be: raise error(\"something\")\n            with be: raise error(\"something\")\n            with be: raise error(\"something\")\n            with be: raise error(\"something\")\n\n    def calibrate(self):\n\n        error = ValueError\n        be = self.BlockExceptions()\n\n        for i in range(self.rounds):\n            pass\n\n\nFile: pyarmor/examples/pybench/Dict.py\nfrom pybench import Test\n\nclass DictCreation(Test):\n\n    version = 2.0\n    operations = 5*(5 + 5)\n    rounds = 80000\n\n    def test(self):\n\n        for i in range(self.rounds):\n\n            d1 = {}\n            d2 = {}\n            d3 = {}\n            d4 = {}\n            d5 = {}\n\n            d1 = {1:2,3:4,5:6}\n            d2 = {2:3,4:5,6:7}\n            d3 = {3:4,5:6,7:8}\n            d4 = {4:5,6:7,8:9}\n            d5 = {6:7,8:9,10:11}\n\n            d1 = {}\n            d2 = {}\n            d3 = {}\n            d4 = {}\n            d5 = {}\n\n            d1 = {1:2,3:4,5:6}\n            d2 = {2:3,4:5,6:7}\n            d3 = {3:4,5:6,7:8}\n            d4 = {4:5,6:7,8:9}\n            d5 = {6:7,8:9,10:11}\n\n            d1 = {}\n            d2 = {}\n            d3 = {}\n            d4 = {}\n            d5 = {}\n\n            d1 = {1:2,3:4,5:6}\n            d2 = {2:3,4:5,6:7}\n            d3 = {3:4,5:6,7:8}\n            d4 = {4:5,6:7,8:9}\n            d5 = {6:7,8:9,10:11}\n\n            d1 = {}\n            d2 = {}\n            d3 = {}\n            d4 = {}\n            d5 = {}\n\n            d1 = {1:2,3:4,5:6}\n            d2 = {2:3,4:5,6:7}\n            d3 = {3:4,5:6,7:8}\n            d4 = {4:5,6:7,8:9}\n            d5 = {6:7,8:9,10:11}\n\n            d1 = {}\n            d2 = {}\n            d3 = {}\n            d4 = {}\n            d5 = {}\n\n            d1 = {1:2,3:4,5:6}\n            d2 = {2:3,4:5,6:7}\n            d3 = {3:4,5:6,7:8}\n            d4 = {4:5,6:7,8:9}\n            d5 = {6:7,8:9,10:11}\n\n    def calibrate(self):\n\n        for i in range(self.rounds):\n            pass\n\nclass DictWithStringKeys(Test):\n\n    version = 2.0\n    operations = 5*(6 + 6)\n    rounds = 200000\n\n    def test(self):\n\n        d = {}\n\n        for i in range(self.rounds):\n\n            d['abc'] = 1\n            d['def'] = 2\n            d['ghi'] = 3\n            d['jkl'] = 4\n            d['mno'] = 5\n            d['pqr'] = 6\n\n            d['abc']\n            d['def']\n            d['ghi']\n            d['jkl']\n            d['mno']\n            d['pqr']\n\n            d['abc'] = 1\n            d['def'] = 2\n            d['ghi'] = 3\n            d['jkl'] = 4\n            d['mno'] = 5\n            d['pqr'] = 6\n\n            d['abc']\n            d['def']\n            d['ghi']\n            d['jkl']\n            d['mno']\n            d['pqr']\n\n            d['abc'] = 1\n            d['def'] = 2\n            d['ghi'] = 3\n            d['jkl'] = 4\n            d['mno'] = 5\n            d['pqr'] = 6\n\n            d['abc']\n            d['def']\n            d['ghi']\n            d['jkl']\n            d['mno']\n            d['pqr']\n\n            d['abc'] = 1\n            d['def'] = 2\n            d['ghi'] = 3\n            d['jkl'] = 4\n            d['mno'] = 5\n            d['pqr'] = 6\n\n            d['abc']\n            d['def']\n            d['ghi']\n            d['jkl']\n            d['mno']\n            d['pqr']\n\n            d['abc'] = 1\n            d['def'] = 2\n            d['ghi'] = 3\n            d['jkl'] = 4\n            d['mno'] = 5\n            d['pqr'] = 6\n\n            d['abc']\n            d['def']\n            d['ghi']\n            d['jkl']\n            d['mno']\n            d['pqr']\n\n    def calibrate(self):\n\n        d = {}\n\n        for i in range(self.rounds):\n            pass\n\nclass DictWithFloatKeys(Test):\n\n    version = 2.0\n    operations = 5*(6 + 6)\n    rounds = 150000\n\n    def test(self):\n\n        d = {}\n\n        for i in range(self.rounds):\n\n            d[1.234] = 1\n            d[2.345] = 2\n            d[3.456] = 3\n            d[4.567] = 4\n            d[5.678] = 5\n            d[6.789] = 6\n\n            d[1.234]\n            d[2.345]\n            d[3.456]\n            d[4.567]\n            d[5.678]\n            d[6.789]\n\n            d[1.234] = 1\n            d[2.345] = 2\n            d[3.456] = 3\n            d[4.567] = 4\n            d[5.678] = 5\n            d[6.789] = 6\n\n            d[1.234]\n            d[2.345]\n            d[3.456]\n            d[4.567]\n            d[5.678]\n            d[6.789]\n\n            d[1.234] = 1\n            d[2.345] = 2\n            d[3.456] = 3\n            d[4.567] = 4\n            d[5.678] = 5\n            d[6.789] = 6\n\n            d[1.234]\n            d[2.345]\n            d[3.456]\n            d[4.567]\n            d[5.678]\n            d[6.789]\n\n            d[1.234] = 1\n            d[2.345] = 2\n            d[3.456] = 3\n            d[4.567] = 4\n            d[5.678] = 5\n            d[6.789] = 6\n\n            d[1.234]\n            d[2.345]\n            d[3.456]\n            d[4.567]\n            d[5.678]\n            d[6.789]\n\n            d[1.234] = 1\n            d[2.345] = 2\n            d[3.456] = 3\n            d[4.567] = 4\n            d[5.678] = 5\n            d[6.789] = 6\n\n            d[1.234]\n            d[2.345]\n            d[3.456]\n            d[4.567]\n            d[5.678]\n            d[6.789]\n\n    def calibrate(self):\n\n        d = {}\n\n        for i in range(self.rounds):\n            pass\n\nclass DictWithIntegerKeys(Test):\n\n    version = 2.0\n    operations = 5*(6 + 6)\n    rounds = 200000\n\n    def test(self):\n\n        d = {}\n\n        for i in range(self.rounds):\n\n            d[1] = 1\n            d[2] = 2\n            d[3] = 3\n            d[4] = 4\n            d[5] = 5\n            d[6] = 6\n\n            d[1]\n            d[2]\n            d[3]\n            d[4]\n            d[5]\n            d[6]\n\n            d[1] = 1\n            d[2] = 2\n            d[3] = 3\n            d[4] = 4\n            d[5] = 5\n            d[6] = 6\n\n            d[1]\n            d[2]\n            d[3]\n            d[4]\n            d[5]\n            d[6]\n\n            d[1] = 1\n            d[2] = 2\n            d[3] = 3\n            d[4] = 4\n            d[5] = 5\n            d[6] = 6\n\n            d[1]\n            d[2]\n            d[3]\n            d[4]\n            d[5]\n            d[6]\n\n            d[1] = 1\n            d[2] = 2\n            d[3] = 3\n            d[4] = 4\n            d[5] = 5\n            d[6] = 6\n\n            d[1]\n            d[2]\n            d[3]\n            d[4]\n            d[5]\n            d[6]\n\n            d[1] = 1\n            d[2] = 2\n            d[3] = 3\n            d[4] = 4\n            d[5] = 5\n            d[6] = 6\n\n            d[1]\n            d[2]\n            d[3]\n            d[4]\n            d[5]\n            d[6]\n\n    def calibrate(self):\n\n        d = {}\n\n        for i in range(self.rounds):\n            pass\n\nclass SimpleDictManipulation(Test):\n\n    version = 2.0\n    operations = 5*(6 + 6 + 6 + 6)\n    rounds = 100000\n\n    def test(self):\n\n        d = {}\n        has_key = lambda key: key in d\n\n        for i in range(self.rounds):\n\n            d[0] = 3\n            d[1] = 4\n            d[2] = 5\n            d[3] = 3\n            d[4] = 4\n            d[5] = 5\n\n            x = d[0]\n            x = d[1]\n            x = d[2]\n            x = d[3]\n            x = d[4]\n            x = d[5]\n\n            has_key(0)\n            has_key(2)\n            has_key(4)\n            has_key(6)\n            has_key(8)\n            has_key(10)\n\n            del d[0]\n            del d[1]\n            del d[2]\n            del d[3]\n            del d[4]\n            del d[5]\n\n            d[0] = 3\n            d[1] = 4\n            d[2] = 5\n            d[3] = 3\n            d[4] = 4\n            d[5] = 5\n\n            x = d[0]\n            x = d[1]\n            x = d[2]\n            x = d[3]\n            x = d[4]\n            x = d[5]\n\n            has_key(0)\n            has_key(2)\n            has_key(4)\n            has_key(6)\n            has_key(8)\n            has_key(10)\n\n            del d[0]\n            del d[1]\n            del d[2]\n            del d[3]\n            del d[4]\n            del d[5]\n\n            d[0] = 3\n            d[1] = 4\n            d[2] = 5\n            d[3] = 3\n            d[4] = 4\n            d[5] = 5\n\n            x = d[0]\n            x = d[1]\n            x = d[2]\n            x = d[3]\n            x = d[4]\n            x = d[5]\n\n            has_key(0)\n            has_key(2)\n            has_key(4)\n            has_key(6)\n            has_key(8)\n            has_key(10)\n\n            del d[0]\n            del d[1]\n            del d[2]\n            del d[3]\n            del d[4]\n            del d[5]\n\n            d[0] = 3\n            d[1] = 4\n            d[2] = 5\n            d[3] = 3\n            d[4] = 4\n            d[5] = 5\n\n            x = d[0]\n            x = d[1]\n            x = d[2]\n            x = d[3]\n            x = d[4]\n            x = d[5]\n\n            has_key(0)\n            has_key(2)\n            has_key(4)\n            has_key(6)\n            has_key(8)\n            has_key(10)\n\n            del d[0]\n            del d[1]\n            del d[2]\n            del d[3]\n            del d[4]\n            del d[5]\n\n            d[0] = 3\n            d[1] = 4\n            d[2] = 5\n            d[3] = 3\n            d[4] = 4\n            d[5] = 5\n\n            x = d[0]\n            x = d[1]\n            x = d[2]\n            x = d[3]\n            x = d[4]\n            x = d[5]\n\n            has_key(0)\n            has_key(2)\n            has_key(4)\n            has_key(6)\n            has_key(8)\n            has_key(10)\n\n            del d[0]\n            del d[1]\n            del d[2]\n            del d[3]\n            del d[4]\n            del d[5]\n\n    def calibrate(self):\n\n        d = {}\n        has_key = lambda key: key in d\n\n        for i in range(self.rounds):\n            pass\n\n\nFile: pyarmor/examples/pybench/Lookups.py\nfrom pybench import Test\n\nclass SpecialClassAttribute(Test):\n\n    version = 2.0\n    operations = 5*(12 + 12)\n    rounds = 100000\n\n    def test(self):\n\n        class c:\n            pass\n\n        for i in range(self.rounds):\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            c.__a = 2\n            c.__b = 3\n            c.__c = 4\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n            x = c.__a\n            x = c.__b\n            x = c.__c\n\n    def calibrate(self):\n\n        class c:\n            pass\n\n        for i in range(self.rounds):\n            pass\n\nclass NormalClassAttribute(Test):\n\n    version = 2.0\n    operations = 5*(12 + 12)\n    rounds = 100000\n\n    def test(self):\n\n        class c:\n            pass\n\n        for i in range(self.rounds):\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n            c.a = 2\n            c.b = 3\n            c.c = 4\n\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n            x = c.a\n            x = c.b\n            x = c.c\n\n    def calibrate(self):\n\n        class c:\n            pass\n\n        for i in range(self.rounds):\n            pass\n\nclass SpecialInstanceAttribute(Test):\n\n    version = 2.0\n    operations = 5*(12 + 12)\n    rounds = 100000\n\n    def test(self):\n\n        class c:\n            pass\n        o = c()\n\n        for i in range(self.rounds):\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n            o.__a__ = 2\n            o.__b__ = 3\n            o.__c__ = 4\n\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n            x = o.__a__\n            x = o.__b__\n            x = o.__c__\n\n    def calibrate(self):\n\n        class c:\n            pass\n        o = c()\n\n        for i in range(self.rounds):\n            pass\n\nclass NormalInstanceAttribute(Test):\n\n    version = 2.0\n    operations = 5*(12 + 12)\n    rounds = 100000\n\n    def test(self):\n\n        class c:\n            pass\n        o = c()\n\n        for i in range(self.rounds):\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n            o.a = 2\n            o.b = 3\n            o.c = 4\n\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n            x = o.a\n            x = o.b\n            x = o.c\n\n    def calibrate(self):\n\n        class c:\n            pass\n        o = c()\n\n        for i in range(self.rounds):\n            pass\n\nclass BuiltinMethodLookup(Test):\n\n    version = 2.0\n    operations = 5*(3*5 + 3*5)\n    rounds = 70000\n\n    def test(self):\n\n        l = []\n        d = {}\n\n        for i in range(self.rounds):\n\n            l.append\n            l.append\n            l.append\n            l.append\n            l.append\n\n            l.insert\n            l.insert\n            l.insert\n            l.insert\n            l.insert\n\n            l.sort\n            l.sort\n            l.sort\n            l.sort\n            l.sort\n\n            # d.has_key\n            # d.has_key\n            # d.has_key\n            # d.has_key\n            # d.has_key\n\n            d.items\n            d.items\n            d.items\n            d.items\n            d.items\n\n            d.get\n            d.get\n            d.get\n            d.get\n            d.get\n\n            l.append\n            l.append\n            l.append\n            l.append\n            l.append\n\n            l.insert\n            l.insert\n            l.insert\n            l.insert\n            l.insert\n\n            l.sort\n            l.sort\n            l.sort\n            l.sort\n            l.sort\n\n            # d.has_key\n            # d.has_key\n            # d.has_key\n            # d.has_key\n            # d.has_key\n\n            d.items\n            d.items\n            d.items\n            d.items\n            d.items\n\n            d.get\n            d.get\n            d.get\n            d.get\n            d.get\n\n            l.append\n            l.append\n            l.append\n            l.append\n            l.append\n\n            l.insert\n            l.insert\n            l.insert\n            l.insert\n            l.insert\n\n            l.sort\n            l.sort\n            l.sort\n            l.sort\n            l.sort\n\n            # d.has_key\n            # d.has_key\n            # d.has_key\n            # d.has_key\n            # d.has_key\n\n            d.items\n            d.items\n            d.items\n            d.items\n            d.items\n\n            d.get\n            d.get\n            d.get\n            d.get\n            d.get\n\n            l.append\n            l.append\n            l.append\n            l.append\n            l.append\n\n            l.insert\n            l.insert\n            l.insert\n            l.insert\n            l.insert\n\n            l.sort\n            l.sort\n            l.sort\n            l.sort\n            l.sort\n\n            # d.has_key\n            # d.has_key\n            # d.has_key\n            # d.has_key\n            # d.has_key\n\n            d.items\n            d.items\n            d.items\n            d.items\n            d.items\n\n            d.get\n            d.get\n            d.get\n            d.get\n            d.get\n\n            l.append\n            l.append\n            l.append\n            l.append\n            l.append\n\n            l.insert\n            l.insert\n            l.insert\n            l.insert\n            l.insert\n\n            l.sort\n            l.sort\n            l.sort\n            l.sort\n            l.sort\n\n            # d.has_key\n            # d.has_key\n            # d.has_key\n            # d.has_key\n            # d.has_key\n\n            d.items\n            d.items\n            d.items\n            d.items\n            d.items\n\n            d.get\n            d.get\n            d.get\n            d.get\n            d.get\n\n    def calibrate(self):\n\n        l = []\n        d = {}\n\n        for i in range(self.rounds):\n            pass\n\n\nFile: pyarmor/examples/pybench/Imports.py\nfrom pybench import Test\n\n# First imports:\nimport os\nimport package.submodule\n\nclass SecondImport(Test):\n\n    version = 2.0\n    operations = 5 * 5\n    rounds = 40000\n\n    def test(self):\n\n        for i in range(self.rounds):\n            import os\n            import os\n            import os\n            import os\n            import os\n\n            import os\n            import os\n            import os\n            import os\n            import os\n\n            import os\n            import os\n            import os\n            import os\n            import os\n\n            import os\n            import os\n            import os\n            import os\n            import os\n\n            import os\n            import os\n            import os\n            import os\n            import os\n\n    def calibrate(self):\n\n        for i in range(self.rounds):\n            pass\n\n\nclass SecondPackageImport(Test):\n\n    version = 2.0\n    operations = 5 * 5\n    rounds = 40000\n\n    def test(self):\n\n        for i in range(self.rounds):\n            import package\n            import package\n            import package\n            import package\n            import package\n\n            import package\n            import package\n            import package\n            import package\n            import package\n\n            import package\n            import package\n            import package\n            import package\n            import package\n\n            import package\n            import package\n            import package\n            import package\n            import package\n\n            import package\n            import package\n            import package\n            import package\n            import package\n\n    def calibrate(self):\n\n        for i in range(self.rounds):\n            pass\n\nclass SecondSubmoduleImport(Test):\n\n    version = 2.0\n    operations = 5 * 5\n    rounds = 40000\n\n    def test(self):\n\n        for i in range(self.rounds):\n            import package.submodule\n            import package.submodule\n            import package.submodule\n            import package.submodule\n            import package.submodule\n\n            import package.submodule\n            import package.submodule\n            import package.submodule\n            import package.submodule\n            import package.submodule\n\n            import package.submodule\n            import package.submodule\n            import package.submodule\n            import package.submodule\n            import package.submodule\n\n            import package.submodule\n            import package.submodule\n            import package.submodule\n            import package.submodule\n            import package.submodule\n\n            import package.submodule\n            import package.submodule\n            import package.submodule\n            import package.submodule\n            import package.submodule\n\n    def calibrate(self):\n\n        for i in range(self.rounds):\n            pass\n\n\nFile: pyarmor/examples/pybench/Constructs.py\nfrom pybench import Test\n\nclass IfThenElse(Test):\n\n    version = 2.0\n    operations = 30*3 # hard to say...\n    rounds = 150000\n\n    def test(self):\n\n        a,b,c = 1,2,3\n        for i in range(self.rounds):\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n            if a == 1:\n                if b == 2:\n                    if c != 3:\n                        c = 3\n                        b = 3\n                    else:\n                        c = 2\n                elif b == 3:\n                    b = 2\n                    a = 2\n            elif a == 2:\n                a = 3\n            else:\n                a = 1\n\n    def calibrate(self):\n\n        a,b,c = 1,2,3\n        for i in range(self.rounds):\n            pass\n\nclass NestedForLoops(Test):\n\n    version = 2.0\n    operations = 1000*10*5\n    rounds = 300\n\n    def test(self):\n\n        l1 = range(1000)\n        l2 = range(10)\n        l3 = range(5)\n        for i in range(self.rounds):\n            for i in l1:\n                for j in l2:\n                    for k in l3:\n                        pass\n\n    def calibrate(self):\n\n        l1 = range(1000)\n        l2 = range(10)\n        l3 = range(5)\n        for i in range(self.rounds):\n            pass\n\nclass ForLoops(Test):\n\n    version = 2.0\n    operations = 5 * 5\n    rounds = 10000\n\n    def test(self):\n\n        l1 = range(100)\n        for i in range(self.rounds):\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n            for i in l1:\n                pass\n\n    def calibrate(self):\n\n        l1 = range(1000)\n        for i in range(self.rounds):\n            pass\n\n\nFile: pyarmor/examples/pybench/clockres.py\n#!/usr/bin/env python\n\n\"\"\" clockres - calculates the resolution in seconds of a given timer.\n\n    Copyright (c) 2006, Marc-Andre Lemburg (mal@egenix.com). See the\n    documentation for further information on copyrights, or contact\n    the author. All Rights Reserved.\n\n\"\"\"\nimport time\n\nTEST_TIME = 1.0\n\ndef clockres(timer):\n    d = {}\n    wallclock = time.time\n    start = wallclock()\n    stop = wallclock() + TEST_TIME\n    spin_loops = range(1000)\n    while 1:\n        now = wallclock()\n        if now >= stop:\n            break\n        for i in spin_loops:\n            d[timer()] = 1\n    values = sorted(d.keys())\n    min_diff = TEST_TIME\n    for i in range(len(values) - 1):\n        diff = values[i+1] - values[i]\n        if diff < min_diff:\n            min_diff = diff\n    return min_diff\n\nif __name__ == '__main__':\n    print('Clock resolution of various timer implementations:')\n    print('time.clock:           %10.3fus' % (clockres(time.clock) * 1e6))\n    print('time.time:            %10.3fus' % (clockres(time.time) * 1e6))\n    try:\n        import systimes\n        print('systimes.processtime: %10.3fus' % (clockres(systimes.processtime) * 1e6))\n    except ImportError:\n        pass\n\n\nFile: pyarmor/examples/pybench/Tuples.py\nfrom pybench import Test\n\nclass TupleSlicing(Test):\n\n    version = 2.0\n    operations = 3 * 25 * 10 * 7\n    rounds = 500\n\n    def test(self):\n\n        r = range(25)\n        t = tuple(range(100))\n\n        for i in range(self.rounds):\n\n            for j in r:\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n                m = t[50:]\n                m = t[:25]\n                m = t[50:55]\n                m = t[:-1]\n                m = t[1:]\n                m = t[-10:]\n                m = t[:10]\n\n    def calibrate(self):\n\n        r = range(25)\n        t = tuple(range(100))\n\n        for i in range(self.rounds):\n            for j in r:\n                pass\n\nclass SmallTuples(Test):\n\n    version = 2.0\n    operations = 5*(1 + 3 + 6 + 2)\n    rounds = 90000\n\n    def test(self):\n\n        for i in range(self.rounds):\n\n            t = (1,2,3,4,5,6)\n\n            a,b,c,d,e,f = t\n            a,b,c,d,e,f = t\n            a,b,c,d,e,f = t\n\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n\n            l = list(t)\n            t = tuple(l)\n\n            t = (1,2,3,4,5,6)\n\n            a,b,c,d,e,f = t\n            a,b,c,d,e,f = t\n            a,b,c,d,e,f = t\n\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n\n            l = list(t)\n            t = tuple(l)\n\n            t = (1,2,3,4,5,6)\n\n            a,b,c,d,e,f = t\n            a,b,c,d,e,f = t\n            a,b,c,d,e,f = t\n\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n\n            l = list(t)\n            t = tuple(l)\n\n            t = (1,2,3,4,5,6)\n\n            a,b,c,d,e,f = t\n            a,b,c,d,e,f = t\n            a,b,c,d,e,f = t\n\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n\n            l = list(t)\n            t = tuple(l)\n\n            t = (1,2,3,4,5,6)\n\n            a,b,c,d,e,f = t\n            a,b,c,d,e,f = t\n            a,b,c,d,e,f = t\n\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n            a,b,c = t[:3]\n\n            l = list(t)\n            t = tuple(l)\n\n    def calibrate(self):\n\n        for i in range(self.rounds):\n            pass\n\n\nFile: pyarmor/examples/pybench/Setup.py\n#!python\n\n# Setup file for pybench\n#\n# This file has to import all tests to be run; it is executed as\n# Python source file, so you can do all kinds of manipulations here\n# rather than having to edit the tests themselves.\n#\n# Note: Please keep this module compatible to Python 1.5.2.\n#\n# Tests may include features in later Python versions, but these\n# should then be embedded in try-except clauses in this configuration\n# module.\n\n# Defaults\nNumber_of_rounds = 10\nWarp_factor = 10\n\n# Import tests\nfrom Arithmetic import *\nfrom Calls import *\nfrom Constructs import *\nfrom Lookups import *\nfrom Instances import *\ntry:\n    from NewInstances import *\nexcept ImportError:\n    pass\nfrom Lists import *\nfrom Tuples import *\nfrom Dict import *\nfrom Exceptions import *\ntry:\n    from With import *\nexcept SyntaxError:\n    pass\nfrom Imports import *\nfrom Strings import *\nfrom Numbers import *\ntry:\n    from Unicode import *\nexcept (ImportError, SyntaxError):\n    pass\n\n\nFile: pyarmor/examples/pybench/Numbers.py\nfrom pybench import Test\n\nclass CompareIntegers(Test):\n\n    version = 2.0\n    operations = 30 * 5\n    rounds = 120000\n\n    def test(self):\n\n        for i in range(self.rounds):\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n            2 < 3\n            2 > 3\n            2 == 3\n            2 > 3\n            2 < 3\n\n    def calibrate(self):\n\n        for i in range(self.rounds):\n            pass\n\n\nclass CompareFloats(Test):\n\n    version = 2.0\n    operations = 30 * 5\n    rounds = 80000\n\n    def test(self):\n\n        for i in range(self.rounds):\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n            2.1 < 3.31\n            2.1 > 3.31\n            2.1 == 3.31\n            2.1 > 3.31\n            2.1 < 3.31\n\n    def calibrate(self):\n\n        for i in range(self.rounds):\n            pass\n\n\nclass CompareFloatsIntegers(Test):\n\n    version = 2.0\n    operations = 30 * 5\n    rounds = 60000\n\n    def test(self):\n\n        for i in range(self.rounds):\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n            2.1 < 4\n            2.1 > 4\n            2.1 == 4\n            2.1 > 4\n            2.1 < 4\n\n    def calibrate(self):\n\n        for i in range(self.rounds):\n            pass\n\n\nclass CompareLongs(Test):\n\n    version = 2.0\n    operations = 30 * 5\n    rounds = 70000\n\n    def test(self):\n\n        for i in range(self.rounds):\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n            1234567890 < 3456789012345\n            1234567890 > 3456789012345\n            1234567890 == 3456789012345\n            1234567890 > 3456789012345\n            1234567890 < 3456789012345\n\n    def calibrate(self):\n\n        for i in range(self.rounds):\n            pass\n\n\nFile: pyarmor/examples/pybench/Calls.py\nfrom pybench import Test\n\nclass PythonFunctionCalls(Test):\n\n    version = 2.1\n    operations = 5*(1+4+4+2)\n    rounds = 60000\n\n    def test(self):\n\n        global f,f1,g,h\n\n        # define functions\n        def f():\n            pass\n\n        def f1(x):\n            pass\n\n        def g(a,b,c):\n            return a,b,c\n\n        def h(a,b,c,d=1,e=2,f=3):\n            return d,e,f\n\n        # do calls\n        for i in range(self.rounds):\n\n            f()\n            f1(i)\n            f1(i)\n            f1(i)\n            f1(i)\n            g(i,i,i)\n            g(i,i,i)\n            g(i,i,i)\n            g(i,i,i)\n            h(i,i,3,i,i)\n            h(i,i,i,2,i,3)\n\n            f()\n            f1(i)\n            f1(i)\n            f1(i)\n            f1(i)\n            g(i,i,i)\n            g(i,i,i)\n            g(i,i,i)\n            g(i,i,i)\n            h(i,i,3,i,i)\n            h(i,i,i,2,i,3)\n\n            f()\n            f1(i)\n            f1(i)\n            f1(i)\n            f1(i)\n            g(i,i,i)\n            g(i,i,i)\n            g(i,i,i)\n            g(i,i,i)\n            h(i,i,3,i,i)\n            h(i,i,i,2,i,3)\n\n            f()\n            f1(i)\n            f1(i)\n            f1(i)\n            f1(i)\n            g(i,i,i)\n            g(i,i,i)\n            g(i,i,i)\n            g(i,i,i)\n            h(i,i,3,i,i)\n            h(i,i,i,2,i,3)\n\n            f()\n            f1(i)\n            f1(i)\n            f1(i)\n            f1(i)\n            g(i,i,i)\n            g(i,i,i)\n            g(i,i,i)\n            g(i,i,i)\n            h(i,i,3,i,i)\n            h(i,i,i,2,i,3)\n\n    def calibrate(self):\n\n        global f,f1,g,h\n\n        # define functions\n        def f():\n            pass\n\n        def f1(x):\n            pass\n\n        def g(a,b,c):\n            return a,b,c\n\n        def h(a,b,c,d=1,e=2,f=3):\n            return d,e,f\n\n        # do calls\n        for i in range(self.rounds):\n            pass\n\n###\n\nclass ComplexPythonFunctionCalls(Test):\n\n    version = 2.0\n    operations = 4*5\n    rounds = 100000\n\n    def test(self):\n\n        # define functions\n        def f(a,b,c,d=1,e=2,f=3):\n            return f\n\n        args = 1,2\n        kwargs = dict(c=3,d=4,e=5)\n\n        # do calls\n        for i in range(self.rounds):\n            f(a=i,b=i,c=i)\n            f(f=i,e=i,d=i,c=2,b=i,a=3)\n            f(1,b=i,**kwargs)\n            f(*args,**kwargs)\n\n            f(a=i,b=i,c=i)\n            f(f=i,e=i,d=i,c=2,b=i,a=3)\n            f(1,b=i,**kwargs)\n            f(*args,**kwargs)\n\n            f(a=i,b=i,c=i)\n            f(f=i,e=i,d=i,c=2,b=i,a=3)\n            f(1,b=i,**kwargs)\n            f(*args,**kwargs)\n\n            f(a=i,b=i,c=i)\n            f(f=i,e=i,d=i,c=2,b=i,a=3)\n            f(1,b=i,**kwargs)\n            f(*args,**kwargs)\n\n            f(a=i,b=i,c=i)\n            f(f=i,e=i,d=i,c=2,b=i,a=3)\n            f(1,b=i,**kwargs)\n            f(*args,**kwargs)\n\n\n    def calibrate(self):\n\n        # define functions\n        def f(a,b,c,d=1,e=2,f=3):\n            return f\n\n        args = 1,2\n        kwargs = dict(c=3,d=4,e=5)\n\n        # do calls\n        for i in range(self.rounds):\n            pass\n\n###\n\nclass BuiltinFunctionCalls(Test):\n\n    version = 2.0\n    operations = 5*(2+5+5+5)\n    rounds = 60000\n\n    def test(self):\n\n        # localize functions\n        f0 = globals\n        f1 = hash\n        f2 = divmod\n        f3 = max\n\n        # do calls\n        for i in range(self.rounds):\n\n            f0()\n            f0()\n            f1(i)\n            f1(i)\n            f1(i)\n            f1(i)\n            f1(i)\n            f2(1,2)\n            f2(1,2)\n            f2(1,2)\n            f2(1,2)\n            f2(1,2)\n            f3(1,3,2)\n            f3(1,3,2)\n            f3(1,3,2)\n            f3(1,3,2)\n            f3(1,3,2)\n\n            f0()\n            f0()\n            f1(i)\n            f1(i)\n            f1(i)\n            f1(i)\n            f1(i)\n            f2(1,2)\n            f2(1,2)\n            f2(1,2)\n            f2(1,2)\n            f2(1,2)\n            f3(1,3,2)\n            f3(1,3,2)\n            f3(1,3,2)\n            f3(1,3,2)\n            f3(1,3,2)\n\n            f0()\n            f0()\n            f1(i)\n            f1(i)\n            f1(i)\n            f1(i)\n            f1(i)\n            f2(1,2)\n            f2(1,2)\n            f2(1,2)\n            f2(1,2)\n            f2(1,2)\n            f3(1,3,2)\n            f3(1,3,2)\n            f3(1,3,2)\n            f3(1,3,2)\n            f3(1,3,2)\n\n            f0()\n            f0()\n            f1(i)\n            f1(i)\n            f1(i)\n            f1(i)\n            f1(i)\n            f2(1,2)\n            f2(1,2)\n            f2(1,2)\n            f2(1,2)\n            f2(1,2)\n            f3(1,3,2)\n            f3(1,3,2)\n            f3(1,3,2)\n            f3(1,3,2)\n            f3(1,3,2)\n\n            f0()\n            f0()\n            f1(i)\n            f1(i)\n            f1(i)\n            f1(i)\n            f1(i)\n            f2(1,2)\n            f2(1,2)\n            f2(1,2)\n            f2(1,2)\n            f2(1,2)\n            f3(1,3,2)\n            f3(1,3,2)\n            f3(1,3,2)\n            f3(1,3,2)\n            f3(1,3,2)\n\n    def calibrate(self):\n\n        # localize functions\n        f0 = dir\n        f1 = hash\n        f2 = divmod\n        f3 = max\n\n        # do calls\n        for i in range(self.rounds):\n            pass\n\n###\n\nclass PythonMethodCalls(Test):\n\n    version = 2.0\n    operations = 5*(6 + 5 + 4)\n    rounds = 30000\n\n    def test(self):\n\n        class c:\n\n            x = 2\n            s = 'string'\n\n            def f(self):\n\n                return self.x\n\n            def j(self,a,b):\n\n                self.y = a\n                self.t = b\n                return self.y\n\n            def k(self,a,b,c=3):\n\n                self.y = a\n                self.s = b\n                self.t = c\n\n        o = c()\n\n        for i in range(self.rounds):\n\n            o.f()\n            o.f()\n            o.f()\n            o.f()\n            o.f()\n            o.f()\n            o.j(i,i)\n            o.j(i,i)\n            o.j(i,2)\n            o.j(i,2)\n            o.j(2,2)\n            o.k(i,i)\n            o.k(i,2)\n            o.k(i,2,3)\n            o.k(i,i,c=4)\n\n            o.f()\n            o.f()\n            o.f()\n            o.f()\n            o.f()\n            o.f()\n            o.j(i,i)\n            o.j(i,i)\n            o.j(i,2)\n            o.j(i,2)\n            o.j(2,2)\n            o.k(i,i)\n            o.k(i,2)\n            o.k(i,2,3)\n            o.k(i,i,c=4)\n\n            o.f()\n            o.f()\n            o.f()\n            o.f()\n            o.f()\n            o.f()\n            o.j(i,i)\n            o.j(i,i)\n            o.j(i,2)\n            o.j(i,2)\n            o.j(2,2)\n            o.k(i,i)\n            o.k(i,2)\n            o.k(i,2,3)\n            o.k(i,i,c=4)\n\n            o.f()\n            o.f()\n            o.f()\n            o.f()\n            o.f()\n            o.f()\n            o.j(i,i)\n            o.j(i,i)\n            o.j(i,2)\n            o.j(i,2)\n            o.j(2,2)\n            o.k(i,i)\n            o.k(i,2)\n            o.k(i,2,3)\n            o.k(i,i,c=4)\n\n            o.f()\n            o.f()\n            o.f()\n            o.f()\n            o.f()\n            o.f()\n            o.j(i,i)\n            o.j(i,i)\n            o.j(i,2)\n            o.j(i,2)\n            o.j(2,2)\n            o.k(i,i)\n            o.k(i,2)\n            o.k(i,2,3)\n            o.k(i,i,c=4)\n\n    def calibrate(self):\n\n        class c:\n\n            x = 2\n            s = 'string'\n\n            def f(self):\n\n                return self.x\n\n            def j(self,a,b):\n\n                self.y = a\n                self.t = b\n\n            def k(self,a,b,c=3):\n\n                self.y = a\n                self.s = b\n                self.t = c\n\n        o = c\n\n        for i in range(self.rounds):\n            pass\n\n###\n\nclass Recursion(Test):\n\n    version = 2.0\n    operations = 5\n    rounds = 100000\n\n    def test(self):\n\n        global f\n\n        def f(x):\n\n            if x > 1:\n                return f(x-1)\n            return 1\n\n        for i in range(self.rounds):\n            f(10)\n            f(10)\n            f(10)\n            f(10)\n            f(10)\n\n    def calibrate(self):\n\n        global f\n\n        def f(x):\n\n            if x > 0:\n                return f(x-1)\n            return 1\n\n        for i in range(self.rounds):\n            pass\n\n\n### Test to make Fredrik happy...\n\nif __name__ == '__main__':\n    import timeit\n    if 0:\n        timeit.TestClass = PythonFunctionCalls\n        timeit.main(['-s', 'test = TestClass(); test.rounds = 1000',\n                     'test.test()'])\n    else:\n        setup = \"\"\"\\\nglobal f,f1,g,h\n\n# define functions\ndef f():\n    pass\n\ndef f1(x):\n    pass\n\ndef g(a,b,c):\n    return a,b,c\n\ndef h(a,b,c,d=1,e=2,f=3):\n    return d,e,f\n\ni = 1\n\"\"\"\n        test = \"\"\"\\\nf()\nf1(i)\nf1(i)\nf1(i)\nf1(i)\ng(i,i,i)\ng(i,i,i)\ng(i,i,i)\ng(i,i,i)\nh(i,i,3,i,i)\nh(i,i,i,2,i,3)\n\nf()\nf1(i)\nf1(i)\nf1(i)\nf1(i)\ng(i,i,i)\ng(i,i,i)\ng(i,i,i)\ng(i,i,i)\nh(i,i,3,i,i)\nh(i,i,i,2,i,3)\n\nf()\nf1(i)\nf1(i)\nf1(i)\nf1(i)\ng(i,i,i)\ng(i,i,i)\ng(i,i,i)\ng(i,i,i)\nh(i,i,3,i,i)\nh(i,i,i,2,i,3)\n\nf()\nf1(i)\nf1(i)\nf1(i)\nf1(i)\ng(i,i,i)\ng(i,i,i)\ng(i,i,i)\ng(i,i,i)\nh(i,i,3,i,i)\nh(i,i,i,2,i,3)\n\nf()\nf1(i)\nf1(i)\nf1(i)\nf1(i)\ng(i,i,i)\ng(i,i,i)\ng(i,i,i)\ng(i,i,i)\nh(i,i,3,i,i)\nh(i,i,i,2,i,3)\n\"\"\"\n\n        timeit.main(['-s', setup,\n                     test])\n\n\nFile: pyarmor/examples/pybench/Arithmetic.py\nfrom pybench import Test\n\nclass SimpleIntegerArithmetic(Test):\n\n    version = 2.0\n    operations = 5 * (3 + 5 + 5 + 3 + 3 + 3)\n    rounds = 120000\n\n    def test(self):\n\n        for i in range(self.rounds):\n\n            a = 2\n            b = 3\n            c = 3\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2\n            b = 3\n            c = 3\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2\n            b = 3\n            c = 3\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2\n            b = 3\n            c = 3\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2\n            b = 3\n            c = 3\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n    def calibrate(self):\n\n        for i in range(self.rounds):\n            pass\n\nclass SimpleFloatArithmetic(Test):\n\n    version = 2.0\n    operations = 5 * (3 + 5 + 5 + 3 + 3 + 3)\n    rounds = 120000\n\n    def test(self):\n\n        for i in range(self.rounds):\n\n            a = 2.1\n            b = 3.3332\n            c = 3.14159\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2.1\n            b = 3.3332\n            c = 3.14159\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2.1\n            b = 3.3332\n            c = 3.14159\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2.1\n            b = 3.3332\n            c = 3.14159\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2.1\n            b = 3.3332\n            c = 3.14159\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n    def calibrate(self):\n\n        for i in range(self.rounds):\n            pass\n\nclass SimpleIntFloatArithmetic(Test):\n\n    version = 2.0\n    operations = 5 * (3 + 5 + 5 + 3 + 3 + 3)\n    rounds = 120000\n\n    def test(self):\n\n        for i in range(self.rounds):\n\n            a = 2\n            b = 3\n            c = 3.14159\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2\n            b = 3\n            c = 3.14159\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2\n            b = 3\n            c = 3.14159\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2\n            b = 3\n            c = 3.14159\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2\n            b = 3\n            c = 3.14159\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n    def calibrate(self):\n\n        for i in range(self.rounds):\n            pass\n\n\nclass SimpleLongArithmetic(Test):\n\n    version = 2.0\n    operations = 5 * (3 + 5 + 5 + 3 + 3 + 3)\n    rounds = 60000\n\n    def test(self):\n\n        for i in range(self.rounds):\n\n            a = 2220001\n            b = 100001\n            c = 30005\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2220001\n            b = 100001\n            c = 30005\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2220001\n            b = 100001\n            c = 30005\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2220001\n            b = 100001\n            c = 30005\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2220001\n            b = 100001\n            c = 30005\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n    def calibrate(self):\n\n        for i in range(self.rounds):\n            pass\n\nclass SimpleComplexArithmetic(Test):\n\n    version = 2.0\n    operations = 5 * (3 + 5 + 5 + 3 + 3 + 3)\n    rounds = 80000\n\n    def test(self):\n\n        for i in range(self.rounds):\n\n            a = 2 + 3j\n            b = 2.5 + 4.5j\n            c = 1.2 + 6.2j\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2 + 3j\n            b = 2.5 + 4.5j\n            c = 1.2 + 6.2j\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2 + 3j\n            b = 2.5 + 4.5j\n            c = 1.2 + 6.2j\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2 + 3j\n            b = 2.5 + 4.5j\n            c = 1.2 + 6.2j\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            a = 2 + 3j\n            b = 2.5 + 4.5j\n            c = 1.2 + 6.2j\n\n            c = a + b\n            c = b + c\n            c = c + a\n            c = a + b\n            c = b + c\n\n            c = c - a\n            c = a - b\n            c = b - c\n            c = c - a\n            c = b - c\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n            c = a * b\n            c = b * a\n            c = c * b\n\n            c = a / b\n            c = b / a\n            c = c / b\n\n    def calibrate(self):\n\n        for i in range(self.rounds):\n            pass\n\n\nFile: pyarmor/examples/pybench/Exceptions.py\nfrom pybench import Test\n\nclass TryRaiseExcept(Test):\n\n    version = 2.0\n    operations = 2 + 3 + 3\n    rounds = 80000\n\n    def test(self):\n\n        error = ValueError\n\n        for i in range(self.rounds):\n            try:\n                raise error\n            except:\n                pass\n            try:\n                raise error\n            except:\n                pass\n            try:\n                raise error(\"something\")\n            except:\n                pass\n            try:\n                raise error(\"something\")\n            except:\n                pass\n            try:\n                raise error(\"something\")\n            except:\n                pass\n            try:\n                raise error(\"something\")\n            except:\n                pass\n            try:\n                raise error(\"something\")\n            except:\n                pass\n            try:\n                raise error(\"something\")\n            except:\n                pass\n\n    def calibrate(self):\n\n        error = ValueError\n\n        for i in range(self.rounds):\n            pass\n\n\nclass TryExcept(Test):\n\n    version = 2.0\n    operations = 15 * 10\n    rounds = 150000\n\n    def test(self):\n\n        for i in range(self.rounds):\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n\n\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n\n\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n\n\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n\n\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n\n\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n\n\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n\n\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n\n\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n\n\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n            try:\n                pass\n            except:\n                pass\n\n    def calibrate(self):\n\n        for i in range(self.rounds):\n            pass\n\n### Test to make Fredrik happy...\n\nif __name__ == '__main__':\n    import timeit\n    timeit.TestClass = TryRaiseExcept\n    timeit.main(['-s', 'test = TestClass(); test.rounds = 1000',\n                 'test.test()'])\n\n\nFile: pyarmor/examples/pybench/CommandLine.py\n\"\"\" CommandLine - Get and parse command line options\n\n    NOTE: This still is very much work in progress !!!\n\n    Different version are likely to be incompatible.\n\n    TODO:\n\n    * Incorporate the changes made by (see Inbox)\n    * Add number range option using srange()\n\n\"\"\"\n\nfrom __future__ import print_function\n\n__copyright__ = \"\"\"\\\nCopyright (c), 1997-2006, Marc-Andre Lemburg (mal@lemburg.com)\nCopyright (c), 2000-2006, eGenix.com Software GmbH (info@egenix.com)\nSee the documentation for further information on copyrights,\nor contact the author. All Rights Reserved.\n\"\"\"\n\n__version__ = '1.2'\n\nimport sys, getopt, glob, os, re, traceback\n\n### Helpers\n\ndef _getopt_flags(options):\n\n    \"\"\" Convert the option list to a getopt flag string and long opt\n        list\n\n    \"\"\"\n    s = []\n    l = []\n    for o in options:\n        if o.prefix == '-':\n            # short option\n            s.append(o.name)\n            if o.takes_argument:\n                s.append(':')\n        else:\n            # long option\n            if o.takes_argument:\n                l.append(o.name+'=')\n            else:\n                l.append(o.name)\n    return ''.join(s), l\n\ndef invisible_input(prompt='>>> '):\n\n    \"\"\" Get raw input from a terminal without echoing the characters to\n        the terminal, e.g. for password queries.\n\n    \"\"\"\n    import getpass\n    entry = getpass.getpass(prompt)\n    if entry is None:\n        raise KeyboardInterrupt\n    return entry\n\ndef fileopen(name, mode='wb', encoding=None):\n\n    \"\"\" Open a file using mode.\n\n        Default mode is 'wb' meaning to open the file for writing in\n        binary mode. If encoding is given, I/O to and from the file is\n        transparently encoded using the given encoding.\n\n        Files opened for writing are chmod()ed to 0600.\n\n    \"\"\"\n    if name == 'stdout':\n        return sys.stdout\n    elif name == 'stderr':\n        return sys.stderr\n    elif name == 'stdin':\n        return sys.stdin\n    else:\n        if encoding is not None:\n            import codecs\n            f = codecs.open(name, mode, encoding)\n        else:\n            f = open(name, mode)\n        if 'w' in mode:\n            os.chmod(name, 0o600)\n        return f\n\ndef option_dict(options):\n\n    \"\"\" Return a dictionary mapping option names to Option instances.\n    \"\"\"\n    d = {}\n    for option in options:\n        d[option.name] = option\n    return d\n\n# Alias\ngetpasswd = invisible_input\n\n_integerRE = re.compile('\\s*(-?\\d+)\\s*$')\n_integerRangeRE = re.compile('\\s*(-?\\d+)\\s*-\\s*(-?\\d+)\\s*$')\n\ndef srange(s,\n\n           integer=_integerRE,\n           integerRange=_integerRangeRE):\n\n    \"\"\" Converts a textual representation of integer numbers and ranges\n        to a Python list.\n\n        Supported formats: 2,3,4,2-10,-1 - -3, 5 - -2\n\n        Values are appended to the created list in the order specified\n        in the string.\n\n    \"\"\"\n    l = []\n    append = l.append\n    for entry in s.split(','):\n        m = integer.match(entry)\n        if m:\n            append(int(m.groups()[0]))\n            continue\n        m = integerRange.match(entry)\n        if m:\n            start,end = map(int,m.groups())\n            l[len(l):] = range(start,end+1)\n    return l\n\ndef abspath(path,\n\n            expandvars=os.path.expandvars,expanduser=os.path.expanduser,\n            join=os.path.join,getcwd=os.getcwd):\n\n    \"\"\" Return the corresponding absolute path for path.\n\n        path is expanded in the usual shell ways before\n        joining it with the current working directory.\n\n    \"\"\"\n    try:\n        path = expandvars(path)\n    except AttributeError:\n        pass\n    try:\n        path = expanduser(path)\n    except AttributeError:\n        pass\n    return join(getcwd(), path)\n\n### Option classes\n\nclass Option:\n\n    \"\"\" Option base class. Takes no argument.\n\n    \"\"\"\n    default = None\n    helptext = ''\n    prefix = '-'\n    takes_argument = 0\n    has_default = 0\n    tab = 15\n\n    def __init__(self,name,help=None):\n\n        if not name[:1] == '-':\n            raise TypeError('option names must start with \"-\"')\n        if name[1:2] == '-':\n            self.prefix = '--'\n            self.name = name[2:]\n        else:\n            self.name = name[1:]\n        if help:\n            self.help = help\n\n    def __str__(self):\n\n        o = self\n        name = o.prefix + o.name\n        if o.takes_argument:\n            name = name + ' arg'\n        if len(name) > self.tab:\n            name = name + '\\n' + ' ' * (self.tab + 1 + len(o.prefix))\n        else:\n            name = '%-*s ' % (self.tab, name)\n        description = o.help\n        if o.has_default:\n            description = description + ' (%s)' % o.default\n        return '%s %s' % (name, description)\n\nclass ArgumentOption(Option):\n\n    \"\"\" Option that takes an argument.\n\n        An optional default argument can be given.\n\n    \"\"\"\n    def __init__(self,name,help=None,default=None):\n\n        # Basemethod\n        Option.__init__(self,name,help)\n\n        if default is not None:\n            self.default = default\n            self.has_default = 1\n        self.takes_argument = 1\n\nclass SwitchOption(Option):\n\n    \"\"\" Options that can be on or off. Has an optional default value.\n\n    \"\"\"\n    def __init__(self,name,help=None,default=None):\n\n        # Basemethod\n        Option.__init__(self,name,help)\n\n        if default is not None:\n            self.default = default\n            self.has_default = 1\n\n### Application baseclass\n\nclass Application:\n\n    \"\"\" Command line application interface with builtin argument\n        parsing.\n\n    \"\"\"\n    # Options the program accepts (Option instances)\n    options = []\n\n    # Standard settings; these are appended to options in __init__\n    preset_options = [SwitchOption('-v',\n                                   'generate verbose output'),\n                      SwitchOption('-h',\n                                   'show this help text'),\n                      SwitchOption('--help',\n                                   'show this help text'),\n                      SwitchOption('--debug',\n                                   'enable debugging'),\n                      SwitchOption('--copyright',\n                                   'show copyright'),\n                      SwitchOption('--examples',\n                                   'show examples of usage')]\n\n    # The help layout looks like this:\n    # [header]   - defaults to ''\n    #\n    # [synopsis] - formatted as '<self.name> %s' % self.synopsis\n    #\n    # options:\n    # [options]  - formatted from self.options\n    #\n    # [version]  - formatted as 'Version:\\n %s' % self.version, if given\n    #\n    # [about]    - defaults to ''\n    #\n    # Note: all fields that do not behave as template are formatted\n    #       using the instances dictionary as substitution namespace,\n    #       e.g. %(name)s will be replaced by the applications name.\n    #\n\n    # Header (default to program name)\n    header = ''\n\n    # Name (defaults to program name)\n    name = ''\n\n    # Synopsis (%(name)s is replaced by the program name)\n    synopsis = '%(name)s [option] files...'\n\n    # Version (optional)\n    version = ''\n\n    # General information printed after the possible options (optional)\n    about = ''\n\n    # Examples of usage to show when the --examples option is given (optional)\n    examples = ''\n\n    # Copyright to show\n    copyright = __copyright__\n\n    # Apply file globbing ?\n    globbing = 1\n\n    # Generate debug output ?\n    debug = 0\n\n    # Generate verbose output ?\n    verbose = 0\n\n    # Internal errors to catch\n    InternalError = BaseException\n\n    # Instance variables:\n    values = None       # Dictionary of passed options (or default values)\n                        # indexed by the options name, e.g. '-h'\n    files = None        # List of passed filenames\n    optionlist = None   # List of passed options\n\n    def __init__(self,argv=None):\n\n        # Setup application specs\n        if argv is None:\n            argv = sys.argv\n        self.filename = os.path.split(argv[0])[1]\n        if not self.name:\n            self.name = os.path.split(self.filename)[1]\n        else:\n            self.name = self.name\n        if not self.header:\n            self.header = self.name\n        else:\n            self.header = self.header\n\n        # Init .arguments list\n        self.arguments = argv[1:]\n\n        # Setup Option mapping\n        self.option_map = option_dict(self.options)\n\n        # Append preset options\n        for option in self.preset_options:\n            if not option.name in self.option_map:\n                self.add_option(option)\n\n        # Init .files list\n        self.files = []\n\n        # Start Application\n        rc = 0\n        try:\n            # Process startup\n            rc = self.startup()\n            if rc is not None:\n                raise SystemExit(rc)\n\n            # Parse command line\n            rc = self.parse()\n            if rc is not None:\n                raise SystemExit(rc)\n\n            # Start application\n            rc = self.main()\n            if rc is None:\n                rc = 0\n\n        except SystemExit as rcException:\n            rc = rcException\n            pass\n\n        except KeyboardInterrupt:\n            print()\n            print('* User Break')\n            print()\n            rc = 1\n\n        except self.InternalError:\n            print()\n            print('* Internal Error (use --debug to display the traceback)')\n            if self.debug:\n                print()\n                traceback.print_exc(20, sys.stdout)\n            elif self.verbose:\n                print('  %s: %s' % sys.exc_info()[:2])\n            print()\n            rc = 1\n\n        raise SystemExit(rc)\n\n    def add_option(self, option):\n\n        \"\"\" Add a new Option instance to the Application dynamically.\n\n            Note that this has to be done *before* .parse() is being\n            executed.\n\n        \"\"\"\n        self.options.append(option)\n        self.option_map[option.name] = option\n\n    def startup(self):\n\n        \"\"\" Set user defined instance variables.\n\n            If this method returns anything other than None, the\n            process is terminated with the return value as exit code.\n\n        \"\"\"\n        return None\n\n    def exit(self, rc=0):\n\n        \"\"\" Exit the program.\n\n            rc is used as exit code and passed back to the calling\n            program. It defaults to 0 which usually means: OK.\n\n        \"\"\"\n        raise SystemExit(rc)\n\n    def parse(self):\n\n        \"\"\" Parse the command line and fill in self.values and self.files.\n\n            After having parsed the options, the remaining command line\n            arguments are interpreted as files and passed to .handle_files()\n            for processing.\n\n            As final step the option handlers are called in the order\n            of the options given on the command line.\n\n        \"\"\"\n        # Parse arguments\n        self.values = values = {}\n        for o in self.options:\n            if o.has_default:\n                values[o.prefix+o.name] = o.default\n            else:\n                values[o.prefix+o.name] = 0\n        flags,lflags = _getopt_flags(self.options)\n        try:\n            optlist,files = getopt.getopt(self.arguments,flags,lflags)\n            if self.globbing:\n                l = []\n                for f in files:\n                    gf = glob.glob(f)\n                    if not gf:\n                        l.append(f)\n                    else:\n                        l[len(l):] = gf\n                files = l\n            self.optionlist = optlist\n            self.files = files + self.files\n        except getopt.error as why:\n            self.help(why)\n            sys.exit(1)\n\n        # Call file handler\n        rc = self.handle_files(self.files)\n        if rc is not None:\n            sys.exit(rc)\n\n        # Call option handlers\n        for optionname, value in optlist:\n\n            # Try to convert value to integer\n            try:\n                value = int(value)\n            except ValueError:\n                pass\n\n            # Find handler and call it (or count the number of option\n            # instances on the command line)\n            handlername = 'handle' + optionname.replace('-', '_')\n            try:\n                handler = getattr(self, handlername)\n            except AttributeError:\n                if value == '':\n                    # count the number of occurances\n                    if optionname in values:\n                        values[optionname] = values[optionname] + 1\n                    else:\n                        values[optionname] = 1\n                else:\n                    values[optionname] = value\n            else:\n             